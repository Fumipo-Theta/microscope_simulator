!function(g){var I={};function n(e){if(I[e])return I[e].exports;var t=I[e]={i:e,l:!1,exports:{}};return g[e].call(t.exports,t,t.exports,n),t.l=!0,t.exports}n.m=g,n.c=I,n.d=function(g,I,e){n.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:e})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,I){if(1&I&&(g=n(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var e=Object.create(null);if(n.r(e),Object.defineProperty(e,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var t in g)n.d(e,t,function(I){return g[I]}.bind(null,t));return e},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/deleteOldVersionDatabase.js\n// This should be method of DB handler class\nfunction deleteOldVersionDatabase() {\n    indexedDB.deleteDatabase("db_v2");\n    indexedDB.deleteDatabase("zipfiles");\n}\n\n// CONCATENATED MODULE: ./src/js/clipGeometryFromImageCenter.js\nfunction clipGeometoryFromImageCenter(state) {\n\n    return [\n        state.rotate_center.to_right - state.imageRadius,\n        state.rotate_center.to_bottom - state.imageRadius,\n        state.imageRadius * 2,\n        state.imageRadius * 2\n    ]\n}\n\n// CONCATENATED MODULE: ./src/js/viewer_canvas.js\nconst viewer = document.querySelector("#main-viewer")\nconst viewer_ctx = viewer.getContext("2d")\n\n// CONCATENATED MODULE: ./src/js/local_storage/NativeLocalStorage.js\nclass NativeLocalStorage {\n    constructor() {\n        this.db = window.localStorage\n    }\n\n    put(key, value) {\n        this.db.setItem(key, value);\n    }\n\n    get(key) {\n        const value = this.db.getItem(key)\n        return (value == null)\n            ? undefined\n            : value\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/local_storage/DummyLocalStorage.js\nclass DummyLocalStorage {\n    constructor() {\n        this.db = {}\n    }\n\n    put(key, value) {\n        this.db[key] = value;\n    }\n\n    get(key) {\n        return (this.db.hasOwnProperty("key"))\n            ? this.db[key]\n            : undefined\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/config/config.js\n/**\n * TODO split these config as different objects\n *\n * - Package list endpoint\n * - Package CDN endpoint\n * - Cache DB version name\n * - Cache DB table name\n */\n\n\n\nclass Config {\n    constructor() {\n        this.endpoint = compileEnv == "production"\n            ? "https://d3uqzv7l1ih05d.cloudfront.net/"\n            : "../../image_package_root/"\n\n        this.indexedDBName = "db_v3"\n        this.storageName = "files"\n    }\n\n    getSampleListURL() {\n        return this.endpoint + "rock_list.json"\n    }\n\n    getSampleCategoryURL() {\n        return this.endpoint + "category.json"\n    }\n\n    getImageDataPath(packageName) {\n        return this.endpoint + "packages/" + packageName + "/"\n    }\n\n    getDBName() {\n        return this.indexedDBName;\n    }\n\n    getStorageName() {\n        return this.storageName\n    }\n}\n\n\nconst compileEnv = "production"\n\nconsole.info("config.js: compileEnv: ", compileEnv)\n\nconst staticSettings = new Config()\n\nconst VIEW_PADDING = 0 // px\n\nconst cacheStorage = window.localStorage\n    ? new NativeLocalStorage()\n    : new DummyLocalStorage()\n// CONCATENATED MODULE: ./src/js/rotation_degree_handlers.js\nconst stepBy = unit => val => Math.floor(val / unit)\n\nconst cycleBy = unit => val => {\n    const cycle_count = Math.floor(val / unit)\n    return val < 0\n        ? val + unit\n        : (unit <= val)\n            ? val - unit * cycle_count\n            : val\n}\n\nconst rotation_degree_handlers_mirrorBy = (center) => val => val > center ? 2 * center - val : val\n\nconst isInverse = degree => (180 <= degree)\n\nconst rotateSign = (clockwise = true) => clockwise ? -1 : 1\n\n// CONCATENATED MODULE: ./src/js/draw_state_updators.js\n\n\n\n\n\nfunction clearView(state) {\n    viewer_ctx.clearRect(-state.canvasWidth * 0.5, -state.canvasHeight * 0.5, state.canvasWidth, state.canvasHeight)\n    return state\n}\n\nfunction blobToCanvas(state) {\n\n    const image_srcs = state.isCrossNicol\n        ? state.cross_images\n        : state.open_images\n\n    // view window circle\n\n    viewer_ctx.save()\n    viewer_ctx.beginPath()\n    viewer_ctx.arc(0, 0, state.canvasWidth / 2 - VIEW_PADDING, 0, Math.PI * 2, false)\n    viewer_ctx.clip()\n\n    // Draw a image\n    const alpha = state.getAlpha(state.rotate)\n\n    viewer_ctx.rotate(\n        rotateSign(state.isClockwise) * (state.rotate + state.getImageNumber(state.rotate) * state.rotate_degree_step) / 180 * Math.PI\n    )\n\n    viewer_ctx.globalAlpha = 1\n    const image1 = image_srcs[state.getImageNumber(state.rotate)]\n\n    try {\n        viewer_ctx.drawImage(\n            image1,\n            ...clipGeometoryFromImageCenter(state),\n            -state.canvasWidth / 2,\n            -state.canvasHeight / 2,\n            state.canvasWidth,\n            state.canvasHeight\n        );\n    } catch (e) {\n\n    }\n\n    viewer_ctx.restore()\n\n    // Draw next image\n    viewer_ctx.save()\n    viewer_ctx.beginPath()\n    viewer_ctx.arc(0, 0, state.canvasWidth / 2 - VIEW_PADDING, 0, Math.PI * 2, false)\n    viewer_ctx.clip()\n\n    viewer_ctx.rotate(\n        rotateSign(state.isClockwise) * (state.rotate + state.getImageNumber(state.rotate + state.rotate_degree_step) * state.rotate_degree_step) / 180 * Math.PI\n    )\n\n    viewer_ctx.globalAlpha = 1 - alpha\n    const image2 = image_srcs[state.getImageNumber(state.rotate + state.rotate_degree_step)]\n    try {\n        viewer_ctx.drawImage(\n            image2,\n            ...clipGeometoryFromImageCenter(state),\n            -state.canvasWidth / 2,\n            -state.canvasHeight / 2,\n            state.canvasWidth,\n            state.canvasHeight)\n    } catch (e) {\n\n    }\n    viewer_ctx.restore()\n    return state\n}\n\nfunction drawHairLine(state) {\n    if (!state.drawHairLine) return\n    viewer_ctx.strokeStyle = state.isCrossNicol\n        ? "white"\n        : "black";\n    viewer_ctx.globalAlpha = 1\n    viewer_ctx.beginPath()\n    viewer_ctx.moveTo(0, -state.canvasHeight * 0.5 + VIEW_PADDING)\n    viewer_ctx.lineTo(0, state.canvasHeight * 0.5 - VIEW_PADDING)\n    viewer_ctx.moveTo(-state.canvasWidth * 0.5 + VIEW_PADDING, 0)\n    viewer_ctx.lineTo(state.canvasWidth * 0.5 - VIEW_PADDING, 0)\n    viewer_ctx.closePath()\n    viewer_ctx.stroke()\n    return state\n}\n\nconst scaleLength = (canvasWidth, imageWidth, scaleWidth) => canvasWidth * scaleWidth / imageWidth\n\nfunction drawScale(state) {\n    if (!state["scaleWidth"]) return;\n    let scalePixel = scaleLength(state.canvasWidth, state.imageRadius * 2, state.scaleWidth)\n    const canvasWidth = state.canvasWidth;\n    const scaleBar = document.querySelector("#scalebar")\n\n\n    let scaleNumber = state.scaleText.match(/(\\d+\\.?\\d*)/)[0] * 1\n    const scaleUnit = state.scaleText.match(/\\D*$/)[0]\n\n    while (scalePixel >= canvasWidth) {\n        scalePixel *= 0.5\n        scaleNumber *= 0.5\n    }\n    scaleBar.style.width = scalePixel + "px";\n    scaleBar.querySelector("div:first-child").innerHTML = `${scaleNumber} ${scaleUnit}`;\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/updateView.js\n\n\nfunction updateView(state) {\n    clearView(state)\n    blobToCanvas(state)\n    drawHairLine(state)\n    drawScale(state)\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/setToggleNicolEvents.js\n\n\nfunction setToggleNicolEvents(state) {\n\n    const toggleNicolButton = document.querySelector("#change_nicol")\n    const toggleNicolLabel = document.querySelector("#change_nicol + label")\n\n    const toggleNicolHandler = state => new Promise((res, rej) => {\n\n        toggleNicolButton.checked = state.isCrossNicol\n        state.isCrossNicol = !state.isCrossNicol;\n\n\n        res(state)\n    })\n\n    toggleNicolButton.addEventListener(\n        "click",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n    toggleNicolLabel.addEventListener(\n        "touch",\n        e => { e.preventDefault() },\n        false\n    )\n\n    toggleNicolButton.addEventListener(\n        "touch",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n    toggleNicolLabel.addEventListener(\n        "mouseup",\n        e => toggleNicolHandler(state)\n            .then(updateView),\n        false\n    )\n\n    toggleNicolLabel.addEventListener(\n        "touchend",\n        e => toggleNicolHandler(state)\n            .then(updateView)\n            .then(_ => {\n                if (e.cancelable) {\n                    e.preventDefault();\n                }\n            }),\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/MessageBarActivitySwitcher.js\nclass MessageBarActivitySwitcher {\n    constructor(messageBarSelector) {\n        this.root = document.querySelector(messageBarSelector)\n        this.hook = {}\n        return this\n    }\n\n    activate() {\n        this.hook["activate"](this.root)\n        this.root.classList.remove("inactive")\n    }\n\n    inactivate() {\n        this.hook["inactivate"](this.root)\n        this.root.classList.add("inactive")\n    }\n\n    setHookOnActivate(hook = rootNode => { }) {\n        this.hook["activate"] = hook\n        return this\n    }\n\n    setHookOnInactivate(hook = rootNode => { }) {\n        this.hook["inactivate"] = hook\n        return this\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/error_indicator_handler.js\n\n\nconst switchErrorMessage = new MessageBarActivitySwitcher(\n    "#error_message_bar"\n).setHookOnInactivate(\n    rootNode => {\n        rootNode.classList.remove("message-error")\n    }\n)\n\nfunction hideErrorMessage(state) {\n    switchErrorMessage.inactivate()\n    return state\n}\n\nfunction showErrorMessage(message) {\n    return (_) => {\n        switchErrorMessage.setHookOnActivate(\n            rootDOM => {\n                rootDOM.querySelector(".message_space").innerHTML = message\n                rootDOM.classList.add("message-error")\n            }\n        )\n        switchErrorMessage.activate()\n        return _\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/loading_indicator_handler.js\n\n\nconst switchLoadingMessage = new MessageBarActivitySwitcher(\n    "#loading_message_bar"\n).setHookOnActivate(\n    rootNode => {\n        rootNode.querySelector(".message_space").innerHTML = "Loading images..."\n        rootNode.classList.add("message-loading")\n    }\n).setHookOnInactivate(\n    rootNode => {\n        rootNode.classList.remove("message-loading")\n    }\n)\n\nconst showLoadingMessage = state => {\n    switchLoadingMessage.activate()\n    return state\n}\n\nconst hideLoadingMessage = state => {\n    switchLoadingMessage.inactivate()\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/viewer_handlers.js\n\n\nconst hideWelcomeBoard = state => {\n    const board = document.querySelector("#welcome-card")\n    board.classList.add("inactive");\n    return state\n}\n\nconst showViewer = state => {\n    const card = document.querySelector("#viewer_wrapper")\n    card.classList.remove("inactive")\n    return state\n}\n\nconst showNicolButton = state => {\n    const button = document.querySelector("#low-navigation")\n    button.classList.remove("inactive");\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/sanitizeID.js\nfunction sanitizeID(id) {\n    return id.replace(/\\//g, "_").replace(/\\./g, "")\n}\n\n// CONCATENATED MODULE: ./src/js/data_translaters.js\nif (!HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, \'toBlob\', {\n        value: function (callback, type, quality) {\n\n            var binStr = atob(this.toDataURL(type, quality).split(\',\')[1]),\n                len = binStr.length,\n                arr = new Uint8Array(len);\n\n            for (var i = 0; i < len; i++) {\n                arr[i] = binStr.charCodeAt(i);\n            }\n\n            callback(new Blob([arr], { type: type || \'image/png\' }));\n        }\n    });\n}\n\nfunction bufferToBase64(buffer, ext) {\n    return new Promise((res, rej) => {\n\n        var bytes = new Uint8Array(buffer);\n        var binary = \'\';\n        var len = bytes.byteLength;\n        for (var i = 0; i < len; i++) {\n            binary += String.fromCharCode(bytes[i]);\n        }\n        res(`data:image/${ext};base64,` + window.btoa(binary));\n    })\n}\n\n\nfunction blobToBase64(blob) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader;\n        reader.onerror = reject;\n        reader.onload = () => {\n            resolve(reader.result);\n        };\n        reader.readAsDataURL(blob);\n    });\n}\n\n// CONCATENATED MODULE: ./src/js/progress_bar_handlers.js\nfunction progressLoading(selector) {\n    const progress = document.querySelector(selector)\n    const bar = progress.querySelector(".bar")\n    bar.style.width = "0%"\n    const total = progress.clientWidth\n    return e => {\n        bar.style.width = `${(e.loaded / e.total) * 100}%`\n    }\n}\n\nfunction completeLoading(selector) {\n    const progress = document.querySelector(selector)\n    const bar = progress.querySelector(".bar")\n    return e => {\n        bar.style.width = "0%"\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/unzipper.js\n\n\nfunction unzipper(url) {\n    return new Promise((res, rej) => {\n\n        Zip.inflate_file(url, res, rej, progressLoading("#progress_bar"), completeLoading("#progress_bar"))\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/extractFile.js\n\n\n/**\n *\n * @param {*} zip\n * @return {Object[meta,zip]}\n */\nasync function extractFile(zipByte) {\n    const zip = Zip.inflate(zipByte)\n    const inflated_zip = {}\n    await Promise.all(Object.entries(zip.files).map(async kv => {\n        if (kv[0].includes(".json")) {\n            inflated_zip[kv[0]] = kv[1].inflate()\n        } else {\n            const type = kv[0].match(/.*\\.(\\w+)$/)[1]\n            const base64 = await bufferToBase64(kv[1].inflate(), type)\n            const mime = base64.match(/^data:(image\\/\\w+);/)[1]\n            const mime_type = mime.split("/")[1]\n\n            const new_file_name = kv[0].split(".")[0] + "." + mime_type\n\n            inflated_zip[new_file_name] = base64\n\n        }\n\n        return true\n    }))\n\n    return inflated_zip\n}\n\n// CONCATENATED MODULE: ./src/js/queryImagePackage.js\n\n\n\n\n\n\n/**\n *\n * @param {String} url\n * @return {Array[String, Boolean]} [lastModified, networkDisconnected]\n */\nasync function queryLastModified(url) {\n    try {\n        const header = await fetch(url, { method: \'HEAD\', mode: \'cors\' }).catch(e => {\n            console.log("Package metadata cannot be fetched.")\n            throw Error(e)\n        })\n        var lastModified = header.headers.get("last-modified")\n        var networkDisconnected = false\n        return [lastModified, networkDisconnected]\n    } catch (e) {\n        var lastModified = "none"\n        var networkDisconnected = true\n        return [lastModified, networkDisconnected]\n    }\n}\n\nclass queryImagePackage_AdhocPackageRepo {\n    constructor(state) {\n        this.state = state\n    }\n\n    resolveImagePackage(packageId, desiredFormat, manifest) {\n        function selectFormatWithFallbackToJpg(list, format) {\n            if (list.includes(format)) {\n                return format\n            } else {\n                return "jpg"\n            }\n        }\n        const format = manifest.hasOwnProperty(\'image_formats\') && manifest["image_formats"] != null\n            ? selectFormatWithFallbackToJpg(manifest.image_formats, desiredFormat)\n            : desiredFormat\n        console.log(format)\n        return [staticSettings.getImageDataPath(packageId) + format + ".zip", format]\n    }\n\n    /**\n     * この関数の返り値の構造をもつobjectを返すのが責務。\n     * よってこの関数で画像パッケージのunzipも行っている。\n     * \n     * @param {String} packageId\n     * @returns {Promise}\n     *     zip: Object<String, Image Blob>\n     */\n    async retrieve(packageId, desiredFormat) {\n        const manifestUrl = staticSettings.getImageDataPath(packageId) + "manifest.json";\n        const open_thumbnailUrl = staticSettings.getImageDataPath(packageId) + "o1.jpg";\n        const cross_thumbnailUrl = staticSettings.getImageDataPath(packageId) + "c1.jpg";\n        const manifestText = await fetch(manifestUrl, { mode: \'cors\' }).then(response => response.text())\n        const manifest = JSON.parse(manifestText);\n\n        const [zipUrl, format] = this.resolveImagePackage(packageId, desiredFormat, manifest)\n        const [lastModified, _] = await queryLastModified(zipUrl)\n        const unzipped = async () => unzipper(zipUrl).then(extractFile)\n\n        const response = {\n            manifest: manifestText, // もしIndexedDBにObjectを保存できるならシリアライズ不要\n            thumbnail: {\n                "o1.jpg": await fetch(open_thumbnailUrl, { mode: \'cors\' })\n                    .then(response => response.blob())\n                    .then(blobToBase64),\n                "c1.jpg": await fetch(cross_thumbnailUrl, { mode: \'cors\' })\n                    .then(response => response.blob())\n                    .then(blobToBase64)\n            },\n            lastModified: lastModified,\n            id: packageId,\n            zip: unzipped,\n            image_format: format\n        }\n        return response\n    }\n\n    async getImagesLastModified(packageId, desiredFormat) {\n        const manifestUrl = staticSettings.getImageDataPath(packageId) + "manifest.json";\n        const manifest = await fetch(manifestUrl, { mode: \'cors\' }).then(response => response.json())\n        const [zipUrl, _] = this.resolveImagePackage(packageId, desiredFormat, manifest)\n        const [lastModified, networkDisconnected] = await queryLastModified(zipUrl)\n        return [lastModified, networkDisconnected]\n    }\n}\n\n/**\n * 指定したkeyのデータがDBの中にある場合, DBからデータを取得する.\n * サーバとDBでデータの最終更新時刻が一致すれば,\n *  DBのデータを返す.\n * ネットワークエラーの場合, DBのデータか無を返す\n *\n * そうでなければサーバからmanifestとthumbnailを取得して返す.\n * また, 画像本体のzipファイルをfetchするアクションを起こす関数を返す.\n *\n * @param {Object} state\n * @param {String} packageName\n * @return {Array[Object,Boolean]} [response, toBeStored]\n */\nasync function queryImagePackage(\n    state,\n    packageName\n) {\n    const id = sanitizeID(packageName)\n    const storedData = await state.zipDBHandler.get(state.zipDB, id)\n    const repo = new queryImagePackage_AdhocPackageRepo(state)\n    const [lastModified, networkDisconnected] = await repo.getImagesLastModified(id, state.supportedImageType)\n\n    if (storedData !== undefined && storedData.lastModified === lastModified) {\n        var toBeStored = false\n        return [storedData, toBeStored]\n    }\n    if (networkDisconnected) {\n        if (storedData !== undefined) {\n            var toBeStored = false\n            return [storedData, toBeStored]\n        } else {\n            return [null, false]\n        }\n    } else {\n        const response = await repo.retrieve(id, state.supportedImageType)\n        var toBeStored = true\n        return [response, toBeStored]\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateStateByMeta.js\n\n\n\nfunction getRotationCenter(meta) {\n    return (meta.hasOwnProperty("rotate_center"))\n        ? {\n            "to_right": meta.rotate_center[0],\n            "to_bottom": meta.rotate_center[1]\n        }\n        : {\n            "to_right": meta.image_width * 0.5,\n            "to_bottom": meta.image_height * 0.5\n        }\n}\n\nfunction getImageRadius(meta) {\n    const shift = getRotationCenter(meta);\n    const image_center = {\n        "x": meta.image_width * 0.5,\n        "y": meta.image_height * 0.5\n    }\n    return Math.min(\n        image_center.x - Math.abs(image_center.x - shift.to_right),\n        image_center.y - Math.abs(image_center.y - shift.to_bottom)\n    )\n}\n\nfunction mapMetadata(meta) {\n    const rotate_degree_step = parseInt(meta.rotate_by_degree)\n\n    return {\n        isClockwise: meta.rotate_clockwise,\n        location: meta.location,\n        rockType: meta.rock_type,\n        owner: meta.owner,\n        description: meta.hasOwnProperty("discription")\n            ? meta.discription\n            : meta.hasOwnProperty("description")\n                ? meta.description\n                : {},\n        rotate_center: getRotationCenter(meta),\n        imageWidth: meta.image_width,\n        imageHeight: meta.image_height,\n        imageRadius: getImageRadius(meta),\n        imageRadiusOriginal: getImageRadius(meta),\n        scaleWidth: meta.hasOwnProperty("scale-pixel")\n            ? parseInt(meta["scale-pixel"])\n            : false,\n        scaleText: meta.hasOwnProperty("scale-unit")\n            ? meta["scale-unit"]\n            : false,\n        rotate_degree_step: rotate_degree_step\n    }\n}\n\nfunction updateStateByMeta(state) {\n    return (containorID, meta) => new Promise((res, rej) => {\n\n        state.containorID = sanitizeID(containorID);\n\n        const rotate_degree_step = parseInt(meta.rotate_by_degree)\n        const cycle_degree = meta.hasOwnProperty("cycle_rotate_degree")\n            ? parseInt(meta.cycle_rotate_degree)\n            : 90;\n        const image_number = cycle_degree / rotate_degree_step + 1\n        const mirror_at = (image_number - 1)\n        const total_step = (image_number - 1) * 2\n\n        state.image_number = image_number\n        state.getImageNumber = cycle_degree > 0\n            ? degree => cycleBy(image_number - 1)(\n                stepBy(rotate_degree_step)(state.isClockwise ? 360 - degree : degree)\n            )\n            : degree => mirrorBy(mirror_at)(\n                cycleBy(total_step)(\n                    stepBy(rotate_degree_step)(degree)\n                )\n            )\n\n        state.getAlpha = degree => {\n            const nth = cycleBy(total_step * 2)(\n                stepBy(rotate_degree_step)(degree)\n            )\n            return 1 - (degree - rotate_degree_step * nth) / rotate_degree_step\n        }\n\n        state.open_images = []\n        state.cross_images = []\n\n        state.rotate = 0;\n\n        state = Object.assign(state, mapMetadata(meta))\n\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/selectFromMultiLanguage.js\n/**\n *\n * @param {String,Object[String,String]} multiLanguageTextObj\n * @return {String}\n */\nfunction selectFromMultiLanguage(multiLanguageTextObj, languageCode) {\n    if (typeof (multiLanguageTextObj) === "string") {\n        return multiLanguageTextObj\n    } else if (typeof (multiLanguageTextObj) === "object") {\n        if (multiLanguageTextObj.hasOwnProperty(languageCode)) {\n            return multiLanguageTextObj[languageCode]\n        } else {\n            const keys = Object.keys(multiLanguageTextObj)\n            return (keys.length > 0)\n                ? multiLanguageTextObj[keys[0]]\n                : ""\n        }\n    } else {\n        return ""\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateViewDescription.js\n\n\nfunction updateViewDescription(state) {\n    const descriptionBox = document.querySelector("#view_description")\n    const lang = state.uiState.language\n\n    const rockFrom = `${selectFromMultiLanguage(state.rockType, lang)} ${state.location ? "(" + selectFromMultiLanguage(state.location, lang) + ")" : ""}`\n    const rockDisc = selectFromMultiLanguage(state.description, lang)\n    const rockOwner = selectFromMultiLanguage(state.owner, lang)\n\n    const textTemplate = `<ul style="list-style-type:none;">\n            <li>${rockFrom}</li>\n            <li>${rockDisc}</li>\n            <li>${rockOwner}</li>\n        </ul>`\n\n    descriptionBox.innerHTML = textTemplate;\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/setOpenAndCrossImages.js\nfunction setOpenAndCrossImages(state) {\n    return imgSets => new Promise((res, rej) => {\n        state.open_images = imgSets.open\n        state.cross_images = imgSets.cross\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/loadImageSrc.js\nfunction handleImgSrc(src) {\n    if (src instanceof Blob) {\n        const url = window.URL || window.webkitURL;\n        return url.createObjectURL(src)\n    } else if (src instanceof String) {\n        return src\n    } else {\n        return src\n    }\n}\n\n/**\n * @parameter src {dataURL}\n */\nfunction loadImageSrc(src) {\n    return new Promise((res, rej) => {\n\n        const img = new Image()\n\n        img.onload = _ => {\n            img.onnerror = null;\n            res(img)\n        }\n        img.onerror = e => {\n            res(img)\n        }\n\n        img.src = handleImgSrc(src)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/updateImageSrc.js\n\n\n\nfunction selectImageInContainor(containor, prefix) {\n    if (prefix in containor) {\n        return containor[prefix]\n    }\n    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII="\n}\n\nfunction updateImageSrc(imagesMap, ext) {\n    return (state) => new Promise(async (res, rej) => {\n\n        Promise.all([\n            Promise.all(Array(state.image_number - 1).fill(0)\n                .map((_, i) => selectImageInContainor(imagesMap, `o${i + 1}.${ext}`))\n                .map(loadImageSrc)\n            ),\n            Promise.all(Array(state.image_number - 1).fill(0)\n                .map((_, i) => selectImageInContainor(imagesMap, `c${i + 1}.${ext}`))\n                .map(loadImageSrc)\n            )\n        ]).then(imgDOMs => {\n            const open_imgs = imgDOMs[0]\n\n            const cross_imgs = imgDOMs[1]\n\n            return { open: open_imgs, cross: cross_imgs }\n        })\n            .then(setOpenAndCrossImages(state))\n            .then(res)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/registerZip.js\n/**\n *\n * @param {*} state\n * @param {*} key\n * @return {Object[meta,zip]}\n */\nfunction registerZip(state) {\n    return async (entry) => {\n\n        const _newOne = await state.zipDBHandler.put(state.zipDB, entry)\n\n        state.uiState.storedKeys.push(entry.id)\n\n        if (state.uiState.storedKeys.length > 20) {\n            const oldest = state.uiState.storedKeys.shift()\n            const _deleted = await state.zipDBHandler.delete(state.zipDB, oldest)\n            Array.from(document.querySelectorAll(`#rock_selector>option[value=${oldest}]`)).forEach(option => {\n                const label = option.innerHTML.replace("✓ ", "")\n                option.innerHTML = label\n                option.classList.remove("downloaded")\n            })\n        }\n\n        return state\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/register.js\n\n\nfunction register(state, isNewData) {\n    if (isNewData) {\n        return entry => new Promise((res, rej) => {\n            registerZip(state)(entry)\n                .then(res)\n        })\n    } else {\n        return _ => new Promise((res, rej) => {\n            res(state)\n        })\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/markDownloadedOption.js\n/**\n *\n * @param {*} packageName\n * @return {Object[meta,zip]}\n */\nfunction markDownloadedOption(packageName) {\n    return manifest => _ => new Promise((res, rej) => {\n        Array.from(document.querySelectorAll(`#rock_selector>option[value=${packageName}]`)).forEach(option => {\n            const label = option.innerHTML.replace("✓ ", "")\n            option.innerHTML = "✓ " + label\n            option.classList.add("downloaded")\n        })\n        res(_)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/rockNameSelectHandler.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * fetch lastmodified\n * fetch manifest\n * fetch sumbnail\n *\n * show sumbnail\n * show discription\n *\n * load images\n *  from db\n *  fetch\n *\n * store data\n */\nfunction rockNameSelectHandler(state) {\n    return new Promise(async (res, rej) => {\n        const rock_selector = document.querySelector("#rock_selector")\n        const packageName = rock_selector.options[rock_selector.selectedIndex].value\n        location.hash = packageName\n\n        state.canRotate = false;\n        hideErrorMessage()\n        showLoadingMessage()\n        hideWelcomeBoard()\n        showViewer()\n        showNicolButton()\n\n        try {\n            const [response, isNewData] = await queryImagePackage(state, packageName);\n            const manifest = JSON.parse(response.manifest);\n\n            const new_state = await updateStateByMeta(state)(packageName, manifest)\n                .then(updateViewDescription)\n                .then(updateImageSrc(response.thumbnail, "jpg"))\n                .then(updateView)\n\n            new_state.canRotate = true\n\n            if (isNewData) {\n                response.zip = await response.zip()\n            }\n\n            updateImageSrc(response.zip, response.image_format)(new_state)\n                .then(state => register(state, isNewData)(response))\n                .then(markDownloadedOption(packageName)(manifest))\n                .then(updateView)\n                .then(res)\n        } catch (e) {\n            rej(e)\n        }\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/setRockSelectEventHandlers.js\n\n\n\n\n\nfunction setRockSelectEventHandlers(state) {\n    const rock_selector = document.querySelector("#rock_selector")\n\n    rock_selector.addEventListener(\n        "change",\n        e => {\n            rockNameSelectHandler(state)\n                .then(updateView)\n                .then(hideErrorMessage)\n                .then(hideLoadingMessage)\n                .catch(e => {\n                    console.log("Sample cannot be loaded because of network error.")\n                    showErrorMessage("Internet disconnected.")(e)\n                })\n        },\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/getCoordinateOnCanvas.js\nfunction getCoordinateOnCanvas(canvas) {\n    return (e, fingur = 0) => {\n        if (e instanceof MouseEvent) {\n            return (e instanceof WheelEvent)\n                ? [\n                    e.deltaX,\n                    e.deltaY\n                ]\n                : [\n                    e.pageX - canvas.offsetLeft,\n                    e.pageY - canvas.offsetTop\n                ]\n        } else if (e instanceof TouchEvent && e.touches.length > fingur) {\n            return [\n                e.touches[fingur].pageX - canvas.offsetLeft,\n                e.touches[fingur].pageY - canvas.offsetTop\n            ]\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/radiunBetween.js\nfunction radiunBetween(cx, cy) {\n    return (_x1, _y1, _x2, _y2) => {\n        const x1 = _x1 - cx\n        const x2 = _x2 - cx\n        const y1 = _y1 - cy\n        const y2 = _y2 - cy\n\n        const cos = (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n        return Math.sign(x1 * y2 - x2 * y1) * Math.acos(cos)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/coordinate_updators.js\n\n\n\n\n\nconst canvasCoordinate = getCoordinateOnCanvas(viewer)\n\n/**\n * Update start and end position\n * @param {*} state\n * @param {*} e\n */\nfunction updateCoordinate(state, e) {\n    state.drag_start = state.drag_end || undefined\n    state.drag_end = canvasCoordinate(e)\n\n    state.pinch_start = state.pinch_end || undefined\n    state.pinch_end = canvasCoordinate(e, 1)\n    return state\n}\n\n/**\n * Calculate small difference of rotation.\n * Update total rotation.\n *\n * @param {*} state\n * @param {*} e\n */\nfunction updateRotate(state, e) {\n    if (!state.canRotate) return;\n    if (state.drag_start === undefined) return\n    // delta rotate radius\n    const rotate_end = radiunBetween(\n        state.canvasWidth * 0.5,\n        state.canvasHeight * 0.5\n    )(...state.drag_end, ...state.drag_start)\n\n    state.rotate += rotate_end / Math.PI * 180\n    if (state.rotate >= 360) {\n        state.rotate -= 360\n    } else if (state.rotate < 0) {\n        state.rotate += 360\n    }\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/rotateImage.js\n\n\n\nfunction rotateImage(state, e) {\n    return () => {\n        updateCoordinate(state, e)\n        updateRotate(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateMagnify.js\n\n\nfunction updateMagnifyByPinch(state, e) {\n    if (state.drag_start === undefined) return\n    if (state.pinch_start === undefined) return\n\n    const x1 = [...state.drag_start]\n    const y1 = [...state.pinch_start]\n    const x2 = [...state.drag_end]\n    const y2 = [...state.pinch_end]\n\n    const expansion = Math.sqrt((x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2) / Math.sqrt((x1[0] - y1[0]) ** 2 + (x1[1] - y1[1]) ** 2)\n\n    const newRadius = (expansion > 2)\n        ? state.imageRadius\n        : state.imageRadius / expansion\n    state.imageRadius = (newRadius) > state.imageRadiusOriginal\n        ? state.imageRadiusOriginal\n        : (newRadius < 100)\n            ? 100\n            : newRadius\n    return state\n}\n\nfunction updateMagnifyByWheel(state, e) {\n    const scrolled = canvasCoordinate(e)[1]\n\n    const newRadius = state.imageRadius + scrolled\n    state.imageRadius = (newRadius) > state.imageRadiusOriginal\n        ? state.imageRadiusOriginal\n        : (newRadius < 100)\n            ? 100\n            : newRadius\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/pinchImage.js\n\n\n\n\nfunction pinchImage(state, e) {\n    return () => {\n        updateCoordinate(state, e)\n        updateMagnifyByPinch(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n        drawScale(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/touchEventHandlers.js\n\n\n\n\nconst touchStartHandler = state => e => {\n    state.isMousedown = true\n    state.drag_end = canvasCoordinate(e)\n    e.preventDefault();\n}\n\nconst touchMoveHandler = state => e => {\n    if (!state.isMousedown) return\n    if (e instanceof MouseEvent || e.touches.length === 1) {\n        e.preventDefault();\n        requestAnimationFrame(\n            rotateImage(state, e)\n        )\n    } else if (e.touches.length === 2) {\n        e.preventDefault()\n        requestAnimationFrame(\n            pinchImage(state, e)\n        )\n    }\n}\n\nconst touchEndHandler = state => e => {\n    state.isMousedown = false\n    state.drag_end = undefined\n    state.pinch_end = undefined\n    e.preventDefault()\n}\n\n// CONCATENATED MODULE: ./src/js/wheelImage.js\n\n\n\nfunction wheelImage(state, e) {\n    return () => {\n        updateMagnifyByWheel(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n        drawScale(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/wheelEventHandler.js\n\n\nconst wheelHandler = state => e => {\n    e.preventDefault();\n    requestAnimationFrame(\n        wheelImage(state, e)\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/setCanvasEventHandlers.js\n\n\n\n\nfunction setCanvasEventHandlers(state) {\n    viewer.addEventListener(\n        "mousedown",\n        touchStartHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "dragstart",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "drag",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "dragend",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n\n    viewer.addEventListener(\n        "touchstart",\n        touchStartHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "mousemove",\n        touchMoveHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "touchmove",\n        touchMoveHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "mouseup",\n        touchEndHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "touchend",\n        touchEndHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "wheel",\n        wheelHandler(state),\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/sample_list/fetch_sample_list_with_cache.js\n\n\nfunction fetchSampleListWithCache() {\n    return new Promise(async (res, rej) => {\n        const listURL = staticSettings.getSampleListURL();\n        try {\n            var response = await fetch(listURL, { mode: \'cors\' })\n                .catch((e) => { throw Error(e) })\n                .then(r => r.json())\n            cacheStorage.put("list_of_sample", JSON.stringify(response["list_of_sample"]))\n        } catch (e) {\n            var stored_list = cacheStorage.get("list_of_sample")\n            var response = { "list_of_sample": JSON.parse(stored_list) }\n            rej(e)\n        }\n        res(response)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/sample_list/show_sample_list.js\n/**\n * サンプルリストをselectタグ内に追加する\n */\nfunction showSampleList(sampleList, lang, cachedList = []) { // this function should take state as arg\n    return new Promise((res, rej) => {\n        const sampleSelectDOM = document.querySelector("#rock_selector");\n        sampleSelectDOM.innerHTML = "<option value=\'\' disabled selected style=\'display:none;\'>Select sample</option>";\n        const options = sampleList.map((v, i) => {\n            const option = document.createElement("option")\n            option.value = v["package-name"];\n            option.innerHTML = (cachedList.includes(v["package-name"]) ? "✓ " : "") + `${i + 1}. ${v["list-name"][lang]}`\n            if (cachedList.includes(v["package-name"])) {\n                option.classList.add("downloaded")\n            }\n            return option\n        })\n        options.forEach(v => {\n            sampleSelectDOM.appendChild(v)\n        })\n\n        document.querySelector("#top-navigation").classList.add("isready");\n        sampleSelectDOM.classList.add("isready")\n        res();\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/remote_repo/static/filter_by_category.js\nclass SampleFilter {\n    constructor(queries = []) {\n        this.queries = new Set(queries.map(this.listToQuery))\n    }\n\n    add(query) {\n        this.queries.add(this.listToQuery(query))\n    }\n\n    addMany(queries) {\n        queries.forEach(v => {\n            this.queries.add(this.listToQuery(v))\n        })\n    }\n\n    remove(value) {\n        this.queries.delete(this.listToQuery(value))\n    }\n\n    removeMany(values) {\n        values.forEach(v => {\n            this.queries.delete(this.listToQuery(v))\n        })\n    }\n\n    reset(queries) {\n        this.queries = new Set(queries.map(this.listToQuery))\n    }\n\n    list() {\n        return this.queries\n    }\n\n    listToQuery(path) {\n        return path.reduce((acc, e) => {\n            if (acc === "") return e\n            return acc + "::" + e\n        }, "")\n    }\n\n    filter(sampleList) {\n        if (this.queries.size === 0) return sampleList\n\n        const queries = [...this.queries].map(v => v.split("::"))\n        return sampleList.filter(sample => {\n            if (!sample.hasOwnProperty("category")) return false\n            const superset = new Set(sample.category)\n            for (let query of queries) {\n                if (isSubset(query, superset)) return true\n            }\n        })\n    }\n}\n\n\n/**\n *\n * @param {Set} set\n * @param {Set} superset\n */\nfunction isSubset(set, superset) {\n    if (set.size == 0) {\n        return true\n    }\n    for (let elem of set) {\n        if (!superset.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// CONCATENATED MODULE: ./src/js/usecase/update_sample_list.js\n\n\n\n\n/**\n * \n * Language = "en" | "ja"\n * SampleKeys: Array<String>\n *\n * @param {Language} uiLanguage\n * @param {SampleKeys} cachedSampleKeys\n * @param {SampleFilter} sampleFilter\n * @return {Promise}\n */\nasync function updateSampleList(uiLanguage, cachedSampleKeys, sampleFilter) {\n    const responseJson = await fetchSampleListWithCache() // sampleFilter should be passed to this function\n    const samplesToBeShown = sampleFilter.filter(responseJson["list_of_sample"])\n    showSampleList(samplesToBeShown, uiLanguage, cachedSampleKeys)\n    return samplesToBeShown\n}\n\n// CONCATENATED MODULE: ./src/js/category_selector/generate_category.js\n\n\nclass CategoryState {\n    constructor(path, selected) {\n        this.path = path\n        this.selected = selected\n    }\n\n    getPath() {\n        return this.path\n    }\n\n    isSelected() {\n        return this.selected\n    }\n}\n\n/**\n * \n * @param {HtmlElement} wrapper\n * @param {"ja" | "en"} lang\n */\nasync function generateCategorySelector(wrapper, state) {\n    const category = await fetch(staticSettings.getSampleCategoryURL())\n        .then(response => response.json())\n    const activeCategories = category.categories.map(cat => {\n        const [child, categories] = makeCategoryImpl(cat, state.uiState.language)\n        if (child) {\n            wrapper.appendChild(child)\n        }\n        return categories\n    }).flat()\n    state.uiState.sampleFilter.reset(\n        activeCategories.filter(catState => catState.isSelected())\n            .map(catState => catState.getPath())\n    )\n    return state\n}\n\n/**\n * SampleCategory = {\n *  id: String,\n *  label: {\n *    ja: String,\n *    en: String\n *  },\n *  subcategories: Array<Category>\n * }\n * @param {SampleCategory} category\n */\nfunction makeCategoryImpl(category, lang, level = 0, parentCategory = []) {\n    const categoryPath = appendCategory(parentCategory, category.id)\n    const checkboxId = `category-group__${concatCategory(categoryPath, "__")}`\n    const checkboxElem = document.querySelector(`#${checkboxId}`)\n    const catState = new CategoryState(categoryPath, checkboxElem === null ? false : checkboxElem.checked)\n    // Because category is static, update label if the category selector exists.\n    if (checkboxElem) {\n        const label = document.querySelector(`#${checkboxId}+label`)\n        label.innerText = category.label[lang]\n        let subcategories = category.subcategories.map(subcat => {\n            const [_nextInner, cat] = makeCategoryImpl(subcat, lang, level + 1, categoryPath)\n            return cat\n        }).flat()\n        return [null, [...subcategories, catState]]\n    }\n\n    // Create new elements\n    const [outer, inner] = level >= 3\n        ? makeBottomLevel()\n        : level >= 2\n            ? makeMiddleLevel()\n            : makeTopLevel()\n    const labelClass = category.subcategories.length > 0\n        ? "super_category"\n        : "category"\n    const checkbox = `\n    <input type="checkbox" class="${labelClass}-checkbox ${concatCategory(categoryPath, " ")}" value="${concatCategory(categoryPath, "__")}"\n        id="${checkboxId}">\n    <label for="${checkboxId}" class="${labelClass} ${concatCategory(categoryPath, " ")}">${category.label[lang]}</label>\n    `\n    outer.innerHTML = checkbox\n\n    if (category.subcategories.length > 0) {\n        let subcategories = category.subcategories.map(subcat => {\n            const [nextInner, cat] = makeCategoryImpl(subcat, lang, level + 1, categoryPath)\n            inner.appendChild(nextInner)\n            return cat\n        }).flat()\n        outer.appendChild(inner)\n        return [outer, [...subcategories, catState]]\n    }\n    return [outer, [catState]]\n}\n\nfunction appendCategory(parent, child) {\n    if (parent.length == 0) return [child]\n    return [...parent, child]\n}\n\nfunction concatCategory(categoryList, sep) {\n    return categoryList.reduce((acc, e) => {\n        if (acc === "") return e\n        return acc + sep + e\n    }, "")\n}\n\nfunction splitCategory(category) {\n    return category.split("__")\n}\n\nfunction enumCategoryLevels(categoryPath) {\n    return categoryPath.split("__").reduce((acc, e) => {\n        if (acc.length === 0) {\n            return [e]\n        } else {\n            return [...acc, acc[acc.length - 1] + "__" + e]\n        }\n    }, []\n    )\n}\n\nfunction makeTopLevel() {\n    // level <= 1\n    const thisCategory = document.createElement("div")\n    thisCategory.classList.add("category_group")\n    thisCategory.classList.add("stretched")\n    const innerCategory = document.createElement("div")\n    innerCategory.classList.add("sub_category")\n    return [thisCategory, innerCategory]\n}\n\nfunction makeMiddleLevel() {\n    // level >= 2\n    // ex. rock > igneous rock > volcanic rock\n    const thisCategory = document.createElement("div")\n    thisCategory.classList.add("sub_category_group")\n    const innerCategory = document.createElement("div")\n    innerCategory.classList.add("column-direction")\n    innerCategory.classList.add("sub_category")\n    return [thisCategory, innerCategory]\n}\n\nfunction makeBottomLevel() {\n    // level >= 3\n    // ex. rock > igneous rock > volcanic rock > rhyolite\n    const thisCategory = document.createElement("div")\n    const innerCategory = document.createElement("div")\n    return [thisCategory, innerCategory]\n}\n\nfunction flattenCategory(category) {\n\n}\n// CONCATENATED MODULE: ./src/js/setLanguageSelectEventHandlers.js\n\n\n\n\n\nfunction languageChangeHandler(state) {\n    return function (e) {\n        const languageSelector = document.querySelector("#language_selector")\n        const lang = languageSelector.options[languageSelector.selectedIndex].value;\n        state.uiState.language = lang\n        cacheStorage.put("language", lang)\n        return state\n    }\n}\n\n\nfunction setLanguageSelectEventHandlers(state) {\n    const languageSelector = document.querySelector("#language_selector")\n\n    languageSelector.addEventListener("change",\n        async e => {\n            let newState = languageChangeHandler(state)(e)\n            newState = await generateCategorySelector(\n                document.querySelector("#wrapper-category_selector"),\n                newState\n            )\n            const uiState = newState.uiState\n            updateSampleList(uiState.language, uiState.storedKeys, uiState.sampleFilter)\n            updateViewDescription(newState)\n        },\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/sendContactMessage.js\nasync function sendContactMessage(e, messageDOM) {\n\n    const button = e.target\n    button.classList.add("pending")\n\n    messageDOM.classList.add("inactive")\n    messageDOM.classList.remove("success")\n    messageDOM.classList.remove("error")\n\n    const form = document.querySelector("#form-contact")\n    const selection = form.querySelector("#select-contact_topic")\n    const topic = selection[selection.selectedIndex].value\n    const message = form.querySelector("textarea").value\n    const from = form.querySelector("input[type=email").value\n\n    if (topic === "") {\n        button.classList.remove("pending")\n        messageDOM.innerHTML = "Select topic !"\n        messageDOM.classList.add("error")\n        messageDOM.classList.remove("inactive")\n        return false\n    }\n\n    if (message === undefined || message == "") {\n        button.classList.remove("pending")\n        messageDOM.innerHTML = "Write message !"\n        messageDOM.classList.add("error")\n        messageDOM.classList.remove("inactive")\n        return false\n    }\n\n    const obj = {\n        "from": from,\n        "title": topic,\n        "body": message\n    }\n\n    const method = "POST";\n    const body = JSON.stringify(obj);\n    const headers = {\n        \'Accept\': \'text/plain,application/json\',\n        \'Access-Control-Allow-Origin\': \'*\',\n        \'Access-Control-Allow-Headers\': \'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token\',\n\n    };\n\n    console.log({ method, headers, body })\n\n    try {\n        const response = await fetch("https://dgo96yhuni.execute-api.us-east-1.amazonaws.com/contactapi/contact", { method, headers, body, \'mode\': \'no-cors\' })\n        messageDOM.innerHTML = "Success. Thank you for contributing !"\n        messageDOM.classList.add("success")\n        messageDOM.classList.remove("inactive")\n    } catch (e) {\n        console.log(e)\n        messageDOM.innerHTML = "Network error !"\n        messageDOM.classList.add("error")\n        messageDOM.classList.remove("inactive")\n    }\n    button.classList.remove("pending")\n\n    return false\n}\n\n// CONCATENATED MODULE: ./src/js/setContactFormEventHandlers.js\n\n\nfunction setContactFormEventHandlers(state) {\n    document.querySelector("#form-contact div.button").addEventListener(\n        "click",\n        e => (Array.from(e.target.classList).includes("pending"))\n            ? null\n            : sendContactMessage(\n                e,\n                document.querySelector("#form-contact .form-message")\n            ),\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/getMaxViewerSize.js\nfunction getMaxViewerSize() {\n    const topBarSpaceHeight = 200 // px\n    const width = window.innerWidth\n    const height = window.innerHeight - topBarSpaceHeight\n    return width < height ? width : height\n}\n\n// CONCATENATED MODULE: ./src/js/state/ui_state.js\n\n\n\nfunction overrideLanguageByLocalStorage(systemLanguage) {\n    const langInLocalStorage = cacheStorage.get("language")\n    const lang = (langInLocalStorage !== undefined)\n        ? langInLocalStorage\n        : systemLanguage;\n    document.querySelector("option[value=" + lang + "]").selected = true\n    return lang\n}\n\nfunction getSystemLanguage() {\n    const code = (window.navigator.languages && window.navigator.languages[0]) ||\n        window.navigator.language ||\n        window.navigator.userLanguage ||\n        window.navigator.browserLanguage;\n\n    const lang = code.match("ja") ? "ja" : "en";\n\n    return lang\n}\n\nconst ui_state_uiState = {\n    "sampleFilter": new SampleFilter(),\n    "storedKeys": [],\n    "language": overrideLanguageByLocalStorage(getSystemLanguage()),\n}\n// CONCATENATED MODULE: ./src/js/state/viewer_state.js\n\n\nconst viewerState = {\n    "containorID": "",\n    "imageNumber": 1,\n    "canvasWidth": getMaxViewerSize() <= 500\n        ? getMaxViewerSize()\n        : 500,\n    "canvasHeight": getMaxViewerSize() <= 500\n        ? getMaxViewerSize()\n        : 500,\n    "imageRadius": 0,\n    "open_image_srcs": [],\n    "open_images": [],\n    "cross_image_srcs": [],\n    "cross_images": [],\n    "rotate": 0,\n    "rotate_axis_translate": [],\n    "isClockwise": true,\n    "isCrossNicol": false,\n    "drawHairLine": true,\n    "canRotate": true,\n}\n// CONCATENATED MODULE: ./src/js/state/initState.js\n\n\n\n\nfunction initState() {\n    return {\n        "isMousedown": false,\n        "drag_start": [0, 0],\n        "drag_end": [0, 0],\n        "uiState": ui_state_uiState,\n        ...viewerState // TODO viewerState should be independent\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateViewerGeometry.js\n\n\n\nfunction updateViewerGeometry(state) {\n    return new Promise((res, rej) => {\n        const padding = 20 // px\n        state.canvasWidth = getMaxViewerSize() - padding\n        state.canvasHeight = getMaxViewerSize() - padding\n\n        viewer.width = state.canvasWidth\n        viewer.height = state.canvasHeight\n        viewer_ctx.translate(state.canvasWidth * 0.5, state.canvasHeight * 0.5)\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/es6Available.js\nfunction es6Available() {\n    return (typeof Symbol === "function" && typeof Symbol() === "symbol")\n}\n\n// CONCATENATED MODULE: ./src/js/detect_supported_image.js\nasync function detectWebpSupport() {\n\n    const testImageSources = [\n        "data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==",\n        "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="\n    ]\n\n    const testImage = (src) => {\n        return new Promise((resolve, reject) => {\n            var img = document.createElement("img")\n            img.onerror = error => resolve(false)\n            img.onload = () => resolve(true)\n            img.src = src\n        })\n    }\n\n    const results = await Promise.all(testImageSources.map(testImage))\n\n    return results.every(result => !!result)\n}\n\nasync function detectJ2kSupport() {\n    const testImageSources = [\n        \'data:image/jp2;base64,AAAADGpQICANCocKAAAAFGZ0eXBqcDIgAAAAAGpwMiAAAAAtanAyaAAAABZpaGRyAAAABAAAAAQAAw8HAAAAAAAPY29scgEAAAAAABAAAABpanAyY/9P/1EALwAAAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAw8BAQ8BAQ8BAf9SAAwAAAABAQAEBAAB/1wABECA/5AACgAAAAAAGAAB/5PP/BAQFABcr4CA/9k=\'\n    ]\n\n    const testImage = (src) => {\n        return new Promise((resolve, reject) => {\n            var img = document.createElement("img")\n            img.onerror = error => resolve(false)\n            img.onload = () => resolve(true)\n            img.src = src\n        })\n    }\n\n    const results = await Promise.all(testImageSources.map(testImage))\n\n    return results.every(result => !!result)\n}\n\n// CONCATENATED MODULE: ./src/js/getSupportedImageType.js\n\n\nasync function getSupportedImageType() {\n    if (await detectWebpSupport()) {\n        return "webp"\n    }\n    if (await detectJ2kSupport()) {\n        return "jp2"\n    }\n    return "jpg"\n}\n\n// CONCATENATED MODULE: ./src/js/checkSupportedImageFormat.js\n\n\n\nasync function checkSupportedImageFormat(state) {\n    state.supportWebp = await detectWebpSupport();\n    state.supportJ2k = await detectJ2kSupport();\n    state.supportedImageType = await getSupportedImageType();\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/DatabaseHandler.js\nclass DatabaseHandler {\n    constructor(db_name, version, storeName, primaryKeyName) {\n        this.db = window.indexedDB;\n        this.db_name = db_name;\n        this.db_version = version;\n        this.storeName = storeName;\n        this.primaryKey = primaryKeyName;\n    }\n\n    schemeDef(db) {\n        db.createObjectStore(this.storeName, { keyPath: this.primaryKey, autoIncrement: true });\n    }\n\n    connect() {\n        const dbp = new Promise((resolve, reject) => {\n            const req = this.db.open(this.db_name, this.db_version);\n            req.onsuccess = ev => resolve(ev.target.result);\n            req.onerror = ev => reject(\'fails to open db\');\n            req.onupgradeneeded = ev => this.schemeDef(ev.target.result);\n        });\n        dbp.then(d => d.onerror = ev => alert("error: " + ev.target.errorCode));\n        return dbp;\n    }\n\n    async put(db, obj) { // returns obj in IDB\n        return new Promise((resolve, reject) => {\n            const docs = db.transaction([this.storeName], \'readwrite\').objectStore(this.storeName);\n            const req = docs.put(obj);\n            req.onsuccess = () => resolve(Object.assign({ [this.primaryKey]: req.result }, obj));\n            req.onerror = reject;\n        });\n    }\n\n    async get(db, id) { // NOTE: if not found, resolves with undefined.\n        return new Promise((resolve, reject) => {\n            const docs = db.transaction([this.storeName,]).objectStore(this.storeName);\n            const req = docs.get(id);\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = reject;\n        });\n    }\n\n    async delete(db, id) {\n        return new Promise((resolve, reject) => {\n            const docs = db.transaction([this.storeName,], \'readwrite\')\n                .objectStore(this.storeName);\n            const req = docs.delete(id);\n            req.onsuccess = () => resolve(id);\n            req.onerror = reject;\n        })\n    }\n\n    async loadAllKey(db) {\n        return new Promise(async (resolve, reject) => {\n            const saves = [];\n            var range = IDBKeyRange.lowerBound(0);\n            const req = db.transaction([this.storeName]).objectStore(this.storeName).openCursor(range);\n            req.onsuccess = function (e) {\n                var result = e.target.result;\n                // 注）走査すべきObjectがこれ以上無い場合\n                //     result == null となります！\n                if (!!result == false) {\n                    resolve(saves)\n                } else {\n                    // ここにvalueがくる！\n                    saves.push(result.key);\n                    // カーソルを一個ずらす\n                    result.continue();\n                }\n\n\n            }\n        });\n    }\n\n    async getAllKeys(db) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                var req = db.transaction([this.storeName]).objectStore(this.storeName)\n            } catch (e) {\n                return resolve([])\n            }\n\n            if (req.getAllKeys) {\n                req.getAllKeys().onsuccess = function (event) {\n                    const rows = event.target.result;\n                    resolve(rows);\n                }\n            } else {\n                const entries = await this.loadAllKey(db)\n                resolve(entries)\n            }\n            req.onerror = reject\n        })\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/DummyDatabaseHandler.js\n\n\nclass DummyDatabaseHandler_DummyDatabaseHandler extends DatabaseHandler {\n    constructor(db_name, version, storeName, primaryKeyName) {\n        console.warn("IndexedDB is not available !")\n        super(db_name, version, storeName, primaryKeyName)\n        this.storage = {}\n    }\n\n    connect() {\n        return {}\n    }\n\n    put(db, obj) {\n        if (db.hasOwnProperty(obj[this.primaryKey])) {\n            var old = db[obj[this.primaryKey]]\n        } else {\n            var old = {}\n        }\n        const new_entry = Object.assign(old, obj)\n        db[obj[this.primaryKey]] = new_entry;\n        return { [obj[this.primaryKey]]: new_entry }\n    }\n\n    get(db, id) {\n        if (db.hasOwnProperty(id)) {\n            return db[id]\n        } else {\n            return undefined\n        }\n    }\n\n    delete(db, id) {\n        if (db.hasOwnProperty(id)) {\n            db[id] = null;\n            return id\n        } else {\n            return undefined\n        }\n    }\n\n    loadAll(db) {\n        return Object.entries(db)\n    }\n\n    getAllKeys(db) {\n        return Object.keys(db)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/connectDatabase.js\n\n\n\n\nasync function connectDatabase(state) {\n    state.zipDBHandler = (window.indexedDB)\n        ? (!navigator.userAgent.match("Edge"))\n            ? new DatabaseHandler(staticSettings.getDBName(), 2, staticSettings.getStorageName(), "id")\n            : new DatabaseHandler(staticSettings.getDBName(), 1, staticSettings.getStorageName(), "id")\n        : new DummyDatabaseHandler_DummyDatabaseHandler(staticSettings.getDBName(), 2, staticSettings.getStorageName(), "id")\n    state.zipDB = await state.zipDBHandler.connect()\n    return state\n};\n\n// CONCATENATED MODULE: ./src/js/getStoredDBEntryKeys.js\nasync function getStoredDBEntryKeys(state) {\n    state.uiState.storedKeys = await state.zipDBHandler.getAllKeys(state.zipDB)\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/fetch_package_by_query.js\n\n\n\n\n\n\n\n\n\n\n\nfunction fetchPackageById(state, packageID) {\n    return new Promise(async (res, rej) => {\n\n        state.canRotate = false;\n        hideErrorMessage()\n        showLoadingMessage()\n        hideWelcomeBoard()\n        showViewer()\n        showNicolButton()\n\n        try {\n            const [response, isNewData] = await queryImagePackage(state, packageID);\n            const manifest = JSON.parse(response.manifest);\n\n            const new_state = await updateStateByMeta(state)(packageID, manifest)\n                .then(updateViewDescription)\n                .then(updateImageSrc(response.thumbnail, "jpg"))\n                .then(updateView)\n\n            new_state.canRotate = true\n\n            if (isNewData) {\n                response.zip = await response.zip()\n            }\n\n            updateImageSrc(response.zip, response.image_format)(new_state)\n                .then(state => register(state, isNewData)(response))\n                .then(markDownloadedOption(packageID)(manifest))\n                .then(updateView)\n                .then(res)\n        } catch (e) {\n            rej(e)\n        }\n    })\n}\n// CONCATENATED MODULE: ./src/js/category_selector/ui_event_handler.js\n\n\n\n\n/**\n * This function must be called after element in the\n *   modal window are registered.\n *\n * @param {HTMLElement} modal\n * @param {HTMLElement} categorySelector\n * @param {HTMLElement} toggle_modal_button\n * @param {HTMLElement} close_modal_button\n */\nfunction setEventHandlers(\n    modal,\n    toggleModalButton,\n    closeModalButton,\n    state\n) {\n    [\n        ...modal.querySelectorAll("input.super_category-checkbox")\n    ].forEach((cat, _,) => {\n        cat.addEventListener(\n            "change",\n            e => {\n                const self = e.target\n                const query = [...self.classList].slice(1)\n                const queryClass = ui_event_handler_concatCategory(query, ".")\n                const uiState = state.uiState\n\n                if (self.checked) {\n                    uiState.sampleFilter.add(query);\n                    [...document.querySelectorAll("label." + queryClass)].forEach(elem => {\n                        elem.classList.add("active")\n                    })\n                } else {\n                    uiState.sampleFilter.remove(query);\n                    [...document.querySelectorAll("label." + queryClass)].forEach(elem => {\n                        elem.classList.remove("active")\n                    })\n                }\n                console.log(uiState.sampleFilter.list())\n                updateSampleList(uiState.language, uiState.storedKeys, uiState.sampleFilter)\n            }\n        )\n    });\n\n    [\n        ...modal.querySelectorAll("input.category-checkbox")\n    ].forEach((cat, _,) => {\n        cat.addEventListener(\n            "change",\n            e => {\n                const self = e.target\n                const query = [...self.classList].slice(1)\n                const queryClass = ui_event_handler_concatCategory(query, ".")\n                const uiState = state.uiState\n\n                if (self.checked) {\n                    uiState.sampleFilter.add(query);\n                } else {\n                    uiState.sampleFilter.remove(query);\n                }\n                console.log(uiState.sampleFilter.list())\n                updateSampleList(uiState.language, uiState.storedKeys, uiState.sampleFilter)\n            }\n        )\n    });\n\n\n    toggleModalButton.addEventListener(\n        "change",\n        e => {\n            if (e.target.checked) {\n                show(modal)\n            } else {\n                hide(modal)\n            }\n        },\n        false\n    )\n\n    closeModalButton.addEventListener(\n        "click",\n        e => {\n            hide(modal)\n            toggleModalButton.checked = false\n        },\n        false\n    )\n}\n\nfunction ui_event_handler_isSubset(set, superset) {\n    if (set.size == 0) {\n        return true\n    }\n    for (let elem of set) {\n        if (!superset.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction ui_event_handler_concatCategory(categoryList, sep) {\n    return categoryList.reduce((acc, e) => {\n        if (acc === "") return e\n        return acc + sep + e\n    }, "")\n}\n\nfunction show(elem) {\n    elem.classList.remove("inactive")\n}\n\nfunction hide(elem) {\n    elem.classList.add("inactive")\n}\n\n// CONCATENATED MODULE: ./src/js/index.js\n/**\n *  Language code of sample list is such as "ja" or "en".\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndeleteOldVersionDatabase()\n\n\n\n\nfunction handleErrors(response) {\n    if (response.ok) {\n        return response;\n    }\n\n    switch (response.status) {\n        case 400: throw new Error(\'INVALID_TOKEN\');\n        case 401: throw new Error(\'UNAUTHORIZED\');\n        case 500: throw new Error(\'INTERNAL_SERVER_ERROR\');\n        case 502: throw new Error(\'BAD_GATEWAY\');\n        case 404: throw new Error(\'NOT_FOUND\');\n        default: throw new Error(\'UNHANDLED_ERROR\');\n    }\n}\n\nfunction isMobileEnv(userAgent) {\n    return (userAgent.indexOf("iPhone") >= 0 || userAgent.indexOf("iPad") >= 0 || userAgent.indexOf("Android") >= 0)\n}\n\nfunction notifyIncompatibleEnv() {\n    var warnningCard = document.getElementById("please_use_modern_browser")\n    warnningCard.classList.remove("inactive")\n}\n\nconst get_package_id = () => {\n    const hash = location.hash.slice(1)\n    return hash === "" ? undefined : hash\n}\n\n/**\n    *\n    * Entry point function !\n    */\nfunction init(state) {\n    // Check ES6 availability\n    // Set window event listener\n    //\n    if (!es6Available) {\n        notifyIncompatibleEnv()\n        return\n    }\n\n    // スマートフォンの場合はorientationchangeイベントを監視する\n    if (isMobileEnv(navigator.userAgent))\n        window.addEventListener(\n            "orientationchange",\n            e => updateViewerGeometry(state).then(updateView),\n            false\n        );\n\n\n    window.addEventListener(\n        "resize",\n        e => updateViewerGeometry(state).then(updateView),\n        false\n    );\n\n    function tee(f) {\n        return (value) => {\n            f(value)\n            return value\n        }\n    }\n\n    /* Set event listener for category selector */\n    generateCategorySelector(\n        document.querySelector("#wrapper-category_selector"),\n        state\n    ).then(_ => {\n        setEventHandlers(\n            document.querySelector("#modal-category_selector"),\n            document.querySelector("#toggle_category"),\n            document.querySelector("#button-close-category_selector"),\n            state\n        )\n    })\n\n    updateViewerGeometry(state)\n        .then(checkSupportedImageFormat)\n        .then(connectDatabase)\n        .then(getStoredDBEntryKeys)\n        .then(tee(_ => {\n            const uiState = state.uiState\n            updateSampleList(uiState.language, uiState.storedKeys, uiState.sampleFilter)\n        }))\n        .then(state => {\n            const packageID = get_package_id()\n            if (packageID) {\n                console.log(packageID)\n                return fetchPackageById(state, packageID)\n            } else {\n                return state\n            }\n        })\n        .then(hideLoadingMessage)\n        .catch(e => {\n            console.error(e)\n            showErrorMessage("<p>Internet disconnected.</p>")()\n            hideLoadingMessage(e);\n        })\n\n\n    setToggleNicolEvents(state)\n    setRockSelectEventHandlers(state)\n    setCanvasEventHandlers(state)\n    setLanguageSelectEventHandlers(state)\n    setContactFormEventHandlers(state)\n\n}\n\nwindow.addEventListener(\n    "DOMcontentloaded",\n    init(initState()),\n    false\n)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9kZWxldGVPbGRWZXJzaW9uRGF0YWJhc2UuanM/Y2U2MCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xpcEdlb21ldHJ5RnJvbUltYWdlQ2VudGVyLmpzP2QyY2QiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3ZpZXdlcl9jYW52YXMuanM/Y2Y3NSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9jYWxfc3RvcmFnZS9OYXRpdmVMb2NhbFN0b3JhZ2UuanM/ZjcyYSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9jYWxfc3RvcmFnZS9EdW1teUxvY2FsU3RvcmFnZS5qcz8zNWM1Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb25maWcvY29uZmlnLmpzP2RmYWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JvdGF0aW9uX2RlZ3JlZV9oYW5kbGVycy5qcz9lNWFlIiwid2VicGFjazovLy8uL3NyYy9qcy9kcmF3X3N0YXRlX3VwZGF0b3JzLmpzP2U5MjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3VwZGF0ZVZpZXcuanM/ZDUwZiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0VG9nZ2xlTmljb2xFdmVudHMuanM/NjBhYyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvTWVzc2FnZUJhckFjdGl2aXR5U3dpdGNoZXIuanM/YTBjYiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZXJyb3JfaW5kaWNhdG9yX2hhbmRsZXIuanM/OTVmZSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9hZGluZ19pbmRpY2F0b3JfaGFuZGxlci5qcz9hOGNmIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3ZXJfaGFuZGxlcnMuanM/YTgwNSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2FuaXRpemVJRC5qcz8wNjRjIiwid2VicGFjazovLy8uL3NyYy9qcy9kYXRhX3RyYW5zbGF0ZXJzLmpzPzYwMjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3Byb2dyZXNzX2Jhcl9oYW5kbGVycy5qcz9lZDY2Iiwid2VicGFjazovLy8uL3NyYy9qcy91bnppcHBlci5qcz9hNWQ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9leHRyYWN0RmlsZS5qcz85MmE5Iiwid2VicGFjazovLy8uL3NyYy9qcy9xdWVyeUltYWdlUGFja2FnZS5qcz8yMTQwIiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVTdGF0ZUJ5TWV0YS5qcz85NjEyIiwid2VicGFjazovLy8uL3NyYy9qcy9zZWxlY3RGcm9tTXVsdGlMYW5ndWFnZS5qcz8wNDI3Iiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVWaWV3RGVzY3JpcHRpb24uanM/MTFkMSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0T3BlbkFuZENyb3NzSW1hZ2VzLmpzPzUyNTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xvYWRJbWFnZVNyYy5qcz8yNjI2Iiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVJbWFnZVNyYy5qcz8wZTgxIiwid2VicGFjazovLy8uL3NyYy9qcy9yZWdpc3RlclppcC5qcz84MmRhIiwid2VicGFjazovLy8uL3NyYy9qcy9yZWdpc3Rlci5qcz82ZmE0Iiwid2VicGFjazovLy8uL3NyYy9qcy9tYXJrRG93bmxvYWRlZE9wdGlvbi5qcz85NTQ1Iiwid2VicGFjazovLy8uL3NyYy9qcy9yb2NrTmFtZVNlbGVjdEhhbmRsZXIuanM/MDgyMCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0Um9ja1NlbGVjdEV2ZW50SGFuZGxlcnMuanM/NTkwOCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2V0Q29vcmRpbmF0ZU9uQ2FudmFzLmpzPzBlN2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JhZGl1bkJldHdlZW4uanM/NGYyMyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29vcmRpbmF0ZV91cGRhdG9ycy5qcz8wYmU5Iiwid2VicGFjazovLy8uL3NyYy9qcy9yb3RhdGVJbWFnZS5qcz8xZTgyIiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVNYWduaWZ5LmpzPzdjYWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BpbmNoSW1hZ2UuanM/ODIxNSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdG91Y2hFdmVudEhhbmRsZXJzLmpzP2UzMWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3doZWVsSW1hZ2UuanM/MzI2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvd2hlZWxFdmVudEhhbmRsZXIuanM/YjIxMCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0Q2FudmFzRXZlbnRIYW5kbGVycy5qcz9kYTE0Iiwid2VicGFjazovLy8uL3NyYy9qcy9zYW1wbGVfbGlzdC9mZXRjaF9zYW1wbGVfbGlzdF93aXRoX2NhY2hlLmpzPzE0M2EiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3NhbXBsZV9saXN0L3Nob3dfc2FtcGxlX2xpc3QuanM/YzU5MCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcmVtb3RlX3JlcG8vc3RhdGljL2ZpbHRlcl9ieV9jYXRlZ29yeS5qcz9mZWEwIiwid2VicGFjazovLy8uL3NyYy9qcy91c2VjYXNlL3VwZGF0ZV9zYW1wbGVfbGlzdC5qcz9mODQ1Iiwid2VicGFjazovLy8uL3NyYy9qcy9jYXRlZ29yeV9zZWxlY3Rvci9nZW5lcmF0ZV9jYXRlZ29yeS5qcz9kZmY0Iiwid2VicGFjazovLy8uL3NyYy9qcy9zZXRMYW5ndWFnZVNlbGVjdEV2ZW50SGFuZGxlcnMuanM/YTQ2OSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2VuZENvbnRhY3RNZXNzYWdlLmpzP2VlNmEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3NldENvbnRhY3RGb3JtRXZlbnRIYW5kbGVycy5qcz9lZjg4Iiwid2VicGFjazovLy8uL3NyYy9qcy9nZXRNYXhWaWV3ZXJTaXplLmpzPzg1YTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N0YXRlL3VpX3N0YXRlLmpzPzYzZmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N0YXRlL3ZpZXdlcl9zdGF0ZS5qcz9kOGUxIiwid2VicGFjazovLy8uL3NyYy9qcy9zdGF0ZS9pbml0U3RhdGUuanM/NmRlOSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdXBkYXRlVmlld2VyR2VvbWV0cnkuanM/YjY2MyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZXM2QXZhaWxhYmxlLmpzP2E3ZDYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2RldGVjdF9zdXBwb3J0ZWRfaW1hZ2UuanM/YWY3OCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2V0U3VwcG9ydGVkSW1hZ2VUeXBlLmpzP2Y4ODIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NoZWNrU3VwcG9ydGVkSW1hZ2VGb3JtYXQuanM/ZWZiYSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvRGF0YWJhc2VIYW5kbGVyLmpzP2EzOTciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0R1bW15RGF0YWJhc2VIYW5kbGVyLmpzP2U3YjQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Nvbm5lY3REYXRhYmFzZS5qcz9hZDA5Iiwid2VicGFjazovLy8uL3NyYy9qcy9nZXRTdG9yZWREQkVudHJ5S2V5cy5qcz8zNDlkIiwid2VicGFjazovLy8uL3NyYy9qcy9mZXRjaF9wYWNrYWdlX2J5X3F1ZXJ5LmpzPzM3OTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2NhdGVnb3J5X3NlbGVjdG9yL3VpX2V2ZW50X2hhbmRsZXIuanM/NDJhZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvaW5kZXguanM/N2JhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGlzIHNob3VsZCBiZSBtZXRob2Qgb2YgREIgaGFuZGxlciBjbGFzc1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVsZXRlT2xkVmVyc2lvbkRhdGFiYXNlKCkge1xuICAgIGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShcImRiX3YyXCIpO1xuICAgIGluZGV4ZWREQi5kZWxldGVEYXRhYmFzZShcInppcGZpbGVzXCIpO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xpcEdlb21ldG9yeUZyb21JbWFnZUNlbnRlcihzdGF0ZSkge1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGUucm90YXRlX2NlbnRlci50b19yaWdodCAtIHN0YXRlLmltYWdlUmFkaXVzLFxuICAgICAgICBzdGF0ZS5yb3RhdGVfY2VudGVyLnRvX2JvdHRvbSAtIHN0YXRlLmltYWdlUmFkaXVzLFxuICAgICAgICBzdGF0ZS5pbWFnZVJhZGl1cyAqIDIsXG4gICAgICAgIHN0YXRlLmltYWdlUmFkaXVzICogMlxuICAgIF1cbn1cbiIsImV4cG9ydCBjb25zdCB2aWV3ZXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21haW4tdmlld2VyXCIpXG5leHBvcnQgY29uc3Qgdmlld2VyX2N0eCA9IHZpZXdlci5nZXRDb250ZXh0KFwiMmRcIilcbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdGl2ZUxvY2FsU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGIgPSB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgfVxuXG4gICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYi5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRiLmdldEl0ZW0oa2V5KVxuICAgICAgICByZXR1cm4gKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB2YWx1ZVxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIER1bW15TG9jYWxTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYiA9IHt9XG4gICAgfVxuXG4gICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYltrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZGIuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICA/IHRoaXMuZGJba2V5XVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICB9XG59XG4iLCIvKipcbiAqIFRPRE8gc3BsaXQgdGhlc2UgY29uZmlnIGFzIGRpZmZlcmVudCBvYmplY3RzXG4gKlxuICogLSBQYWNrYWdlIGxpc3QgZW5kcG9pbnRcbiAqIC0gUGFja2FnZSBDRE4gZW5kcG9pbnRcbiAqIC0gQ2FjaGUgREIgdmVyc2lvbiBuYW1lXG4gKiAtIENhY2hlIERCIHRhYmxlIG5hbWVcbiAqL1xuaW1wb3J0IE5hdGl2ZUxvY2FsU3RvcmFnZSBmcm9tIFwiLi4vbG9jYWxfc3RvcmFnZS9OYXRpdmVMb2NhbFN0b3JhZ2UuanNcIjtcbmltcG9ydCBEdW1teUxvY2FsU3RvcmFnZSBmcm9tIFwiLi4vbG9jYWxfc3RvcmFnZS9EdW1teUxvY2FsU3RvcmFnZS5qc1wiO1xuXG5jbGFzcyBDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmVuZHBvaW50ID0gY29tcGlsZUVudiA9PSBcInByb2R1Y3Rpb25cIlxuICAgICAgICAgICAgPyBcImh0dHBzOi8vZDN1cXp2N2wxaWgwNWQuY2xvdWRmcm9udC5uZXQvXCJcbiAgICAgICAgICAgIDogXCIuLi8uLi9pbWFnZV9wYWNrYWdlX3Jvb3QvXCJcblxuICAgICAgICB0aGlzLmluZGV4ZWREQk5hbWUgPSBcImRiX3YzXCJcbiAgICAgICAgdGhpcy5zdG9yYWdlTmFtZSA9IFwiZmlsZXNcIlxuICAgIH1cblxuICAgIGdldFNhbXBsZUxpc3RVUkwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZHBvaW50ICsgXCJyb2NrX2xpc3QuanNvblwiXG4gICAgfVxuXG4gICAgZ2V0U2FtcGxlQ2F0ZWdvcnlVUkwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZHBvaW50ICsgXCJjYXRlZ29yeS5qc29uXCJcbiAgICB9XG5cbiAgICBnZXRJbWFnZURhdGFQYXRoKHBhY2thZ2VOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuZHBvaW50ICsgXCJwYWNrYWdlcy9cIiArIHBhY2thZ2VOYW1lICsgXCIvXCJcbiAgICB9XG5cbiAgICBnZXREQk5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluZGV4ZWREQk5hbWU7XG4gICAgfVxuXG4gICAgZ2V0U3RvcmFnZU5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2VOYW1lXG4gICAgfVxufVxuXG5cbmNvbnN0IGNvbXBpbGVFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVlxuXG5jb25zb2xlLmluZm8oXCJjb25maWcuanM6IGNvbXBpbGVFbnY6IFwiLCBjb21waWxlRW52KVxuXG5leHBvcnQgY29uc3Qgc3RhdGljU2V0dGluZ3MgPSBuZXcgQ29uZmlnKClcblxuZXhwb3J0IGNvbnN0IFZJRVdfUEFERElORyA9IDAgLy8gcHhcblxuZXhwb3J0IGNvbnN0IGNhY2hlU3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VcbiAgICA/IG5ldyBOYXRpdmVMb2NhbFN0b3JhZ2UoKVxuICAgIDogbmV3IER1bW15TG9jYWxTdG9yYWdlKCkiLCJleHBvcnQgY29uc3Qgc3RlcEJ5ID0gdW5pdCA9PiB2YWwgPT4gTWF0aC5mbG9vcih2YWwgLyB1bml0KVxuXG5leHBvcnQgY29uc3QgY3ljbGVCeSA9IHVuaXQgPT4gdmFsID0+IHtcbiAgICBjb25zdCBjeWNsZV9jb3VudCA9IE1hdGguZmxvb3IodmFsIC8gdW5pdClcbiAgICByZXR1cm4gdmFsIDwgMFxuICAgICAgICA/IHZhbCArIHVuaXRcbiAgICAgICAgOiAodW5pdCA8PSB2YWwpXG4gICAgICAgICAgICA/IHZhbCAtIHVuaXQgKiBjeWNsZV9jb3VudFxuICAgICAgICAgICAgOiB2YWxcbn1cblxuZXhwb3J0IGNvbnN0IG1pcnJvckJ5ID0gKGNlbnRlcikgPT4gdmFsID0+IHZhbCA+IGNlbnRlciA/IDIgKiBjZW50ZXIgLSB2YWwgOiB2YWxcblxuZXhwb3J0IGNvbnN0IGlzSW52ZXJzZSA9IGRlZ3JlZSA9PiAoMTgwIDw9IGRlZ3JlZSlcblxuZXhwb3J0IGNvbnN0IHJvdGF0ZVNpZ24gPSAoY2xvY2t3aXNlID0gdHJ1ZSkgPT4gY2xvY2t3aXNlID8gLTEgOiAxXG4iLCJpbXBvcnQgY2xpcEdlb21ldG9yeUZyb21JbWFnZUNlbnRlciBmcm9tIFwiLi9jbGlwR2VvbWV0cnlGcm9tSW1hZ2VDZW50ZXIuanNcIlxuaW1wb3J0IHsgdmlld2VyX2N0eCB9IGZyb20gXCIuL3ZpZXdlcl9jYW52YXMuanNcIlxuaW1wb3J0IHsgVklFV19QQURESU5HIH0gZnJvbSBcIi4vY29uZmlnL2NvbmZpZy5qc1wiXG5pbXBvcnQgeyByb3RhdGVTaWduIH0gZnJvbSBcIi4vcm90YXRpb25fZGVncmVlX2hhbmRsZXJzLmpzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyVmlldyhzdGF0ZSkge1xuICAgIHZpZXdlcl9jdHguY2xlYXJSZWN0KC1zdGF0ZS5jYW52YXNXaWR0aCAqIDAuNSwgLXN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNSwgc3RhdGUuY2FudmFzV2lkdGgsIHN0YXRlLmNhbnZhc0hlaWdodClcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2JUb0NhbnZhcyhzdGF0ZSkge1xuXG4gICAgY29uc3QgaW1hZ2Vfc3JjcyA9IHN0YXRlLmlzQ3Jvc3NOaWNvbFxuICAgICAgICA/IHN0YXRlLmNyb3NzX2ltYWdlc1xuICAgICAgICA6IHN0YXRlLm9wZW5faW1hZ2VzXG5cbiAgICAvLyB2aWV3IHdpbmRvdyBjaXJjbGVcblxuICAgIHZpZXdlcl9jdHguc2F2ZSgpXG4gICAgdmlld2VyX2N0eC5iZWdpblBhdGgoKVxuICAgIHZpZXdlcl9jdHguYXJjKDAsIDAsIHN0YXRlLmNhbnZhc1dpZHRoIC8gMiAtIFZJRVdfUEFERElORywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKVxuICAgIHZpZXdlcl9jdHguY2xpcCgpXG5cbiAgICAvLyBEcmF3IGEgaW1hZ2VcbiAgICBjb25zdCBhbHBoYSA9IHN0YXRlLmdldEFscGhhKHN0YXRlLnJvdGF0ZSlcblxuICAgIHZpZXdlcl9jdHgucm90YXRlKFxuICAgICAgICByb3RhdGVTaWduKHN0YXRlLmlzQ2xvY2t3aXNlKSAqIChzdGF0ZS5yb3RhdGUgKyBzdGF0ZS5nZXRJbWFnZU51bWJlcihzdGF0ZS5yb3RhdGUpICogc3RhdGUucm90YXRlX2RlZ3JlZV9zdGVwKSAvIDE4MCAqIE1hdGguUElcbiAgICApXG5cbiAgICB2aWV3ZXJfY3R4Lmdsb2JhbEFscGhhID0gMVxuICAgIGNvbnN0IGltYWdlMSA9IGltYWdlX3NyY3Nbc3RhdGUuZ2V0SW1hZ2VOdW1iZXIoc3RhdGUucm90YXRlKV1cblxuICAgIHRyeSB7XG4gICAgICAgIHZpZXdlcl9jdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgaW1hZ2UxLFxuICAgICAgICAgICAgLi4uY2xpcEdlb21ldG9yeUZyb21JbWFnZUNlbnRlcihzdGF0ZSksXG4gICAgICAgICAgICAtc3RhdGUuY2FudmFzV2lkdGggLyAyLFxuICAgICAgICAgICAgLXN0YXRlLmNhbnZhc0hlaWdodCAvIDIsXG4gICAgICAgICAgICBzdGF0ZS5jYW52YXNXaWR0aCxcbiAgICAgICAgICAgIHN0YXRlLmNhbnZhc0hlaWdodFxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgIH1cblxuICAgIHZpZXdlcl9jdHgucmVzdG9yZSgpXG5cbiAgICAvLyBEcmF3IG5leHQgaW1hZ2VcbiAgICB2aWV3ZXJfY3R4LnNhdmUoKVxuICAgIHZpZXdlcl9jdHguYmVnaW5QYXRoKClcbiAgICB2aWV3ZXJfY3R4LmFyYygwLCAwLCBzdGF0ZS5jYW52YXNXaWR0aCAvIDIgLSBWSUVXX1BBRERJTkcsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSlcbiAgICB2aWV3ZXJfY3R4LmNsaXAoKVxuXG4gICAgdmlld2VyX2N0eC5yb3RhdGUoXG4gICAgICAgIHJvdGF0ZVNpZ24oc3RhdGUuaXNDbG9ja3dpc2UpICogKHN0YXRlLnJvdGF0ZSArIHN0YXRlLmdldEltYWdlTnVtYmVyKHN0YXRlLnJvdGF0ZSArIHN0YXRlLnJvdGF0ZV9kZWdyZWVfc3RlcCkgKiBzdGF0ZS5yb3RhdGVfZGVncmVlX3N0ZXApIC8gMTgwICogTWF0aC5QSVxuICAgIClcblxuICAgIHZpZXdlcl9jdHguZ2xvYmFsQWxwaGEgPSAxIC0gYWxwaGFcbiAgICBjb25zdCBpbWFnZTIgPSBpbWFnZV9zcmNzW3N0YXRlLmdldEltYWdlTnVtYmVyKHN0YXRlLnJvdGF0ZSArIHN0YXRlLnJvdGF0ZV9kZWdyZWVfc3RlcCldXG4gICAgdHJ5IHtcbiAgICAgICAgdmlld2VyX2N0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBpbWFnZTIsXG4gICAgICAgICAgICAuLi5jbGlwR2VvbWV0b3J5RnJvbUltYWdlQ2VudGVyKHN0YXRlKSxcbiAgICAgICAgICAgIC1zdGF0ZS5jYW52YXNXaWR0aCAvIDIsXG4gICAgICAgICAgICAtc3RhdGUuY2FudmFzSGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHN0YXRlLmNhbnZhc1dpZHRoLFxuICAgICAgICAgICAgc3RhdGUuY2FudmFzSGVpZ2h0KVxuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgIH1cbiAgICB2aWV3ZXJfY3R4LnJlc3RvcmUoKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd0hhaXJMaW5lKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5kcmF3SGFpckxpbmUpIHJldHVyblxuICAgIHZpZXdlcl9jdHguc3Ryb2tlU3R5bGUgPSBzdGF0ZS5pc0Nyb3NzTmljb2xcbiAgICAgICAgPyBcIndoaXRlXCJcbiAgICAgICAgOiBcImJsYWNrXCI7XG4gICAgdmlld2VyX2N0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB2aWV3ZXJfY3R4LmJlZ2luUGF0aCgpXG4gICAgdmlld2VyX2N0eC5tb3ZlVG8oMCwgLXN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNSArIFZJRVdfUEFERElORylcbiAgICB2aWV3ZXJfY3R4LmxpbmVUbygwLCBzdGF0ZS5jYW52YXNIZWlnaHQgKiAwLjUgLSBWSUVXX1BBRERJTkcpXG4gICAgdmlld2VyX2N0eC5tb3ZlVG8oLXN0YXRlLmNhbnZhc1dpZHRoICogMC41ICsgVklFV19QQURESU5HLCAwKVxuICAgIHZpZXdlcl9jdHgubGluZVRvKHN0YXRlLmNhbnZhc1dpZHRoICogMC41IC0gVklFV19QQURESU5HLCAwKVxuICAgIHZpZXdlcl9jdHguY2xvc2VQYXRoKClcbiAgICB2aWV3ZXJfY3R4LnN0cm9rZSgpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbmNvbnN0IHNjYWxlTGVuZ3RoID0gKGNhbnZhc1dpZHRoLCBpbWFnZVdpZHRoLCBzY2FsZVdpZHRoKSA9PiBjYW52YXNXaWR0aCAqIHNjYWxlV2lkdGggLyBpbWFnZVdpZHRoXG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3U2NhbGUoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlW1wic2NhbGVXaWR0aFwiXSkgcmV0dXJuO1xuICAgIGxldCBzY2FsZVBpeGVsID0gc2NhbGVMZW5ndGgoc3RhdGUuY2FudmFzV2lkdGgsIHN0YXRlLmltYWdlUmFkaXVzICogMiwgc3RhdGUuc2NhbGVXaWR0aClcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IHN0YXRlLmNhbnZhc1dpZHRoO1xuICAgIGNvbnN0IHNjYWxlQmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNzY2FsZWJhclwiKVxuXG5cbiAgICBsZXQgc2NhbGVOdW1iZXIgPSBzdGF0ZS5zY2FsZVRleHQubWF0Y2goLyhcXGQrXFwuP1xcZCopLylbMF0gKiAxXG4gICAgY29uc3Qgc2NhbGVVbml0ID0gc3RhdGUuc2NhbGVUZXh0Lm1hdGNoKC9cXEQqJC8pWzBdXG5cbiAgICB3aGlsZSAoc2NhbGVQaXhlbCA+PSBjYW52YXNXaWR0aCkge1xuICAgICAgICBzY2FsZVBpeGVsICo9IDAuNVxuICAgICAgICBzY2FsZU51bWJlciAqPSAwLjVcbiAgICB9XG4gICAgc2NhbGVCYXIuc3R5bGUud2lkdGggPSBzY2FsZVBpeGVsICsgXCJweFwiO1xuICAgIHNjYWxlQmFyLnF1ZXJ5U2VsZWN0b3IoXCJkaXY6Zmlyc3QtY2hpbGRcIikuaW5uZXJIVE1MID0gYCR7c2NhbGVOdW1iZXJ9ICR7c2NhbGVVbml0fWA7XG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJpbXBvcnQgeyBjbGVhclZpZXcsIGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lLCBkcmF3U2NhbGUgfSBmcm9tIFwiLi9kcmF3X3N0YXRlX3VwZGF0b3JzLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlVmlldyhzdGF0ZSkge1xuICAgIGNsZWFyVmlldyhzdGF0ZSlcbiAgICBibG9iVG9DYW52YXMoc3RhdGUpXG4gICAgZHJhd0hhaXJMaW5lKHN0YXRlKVxuICAgIGRyYXdTY2FsZShzdGF0ZSlcbiAgICByZXR1cm4gc3RhdGVcbn1cbiIsImltcG9ydCB1cGRhdGVWaWV3IGZyb20gXCIuL3VwZGF0ZVZpZXcuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRUb2dnbGVOaWNvbEV2ZW50cyhzdGF0ZSkge1xuXG4gICAgY29uc3QgdG9nZ2xlTmljb2xCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2NoYW5nZV9uaWNvbFwiKVxuICAgIGNvbnN0IHRvZ2dsZU5pY29sTGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2NoYW5nZV9uaWNvbCArIGxhYmVsXCIpXG5cbiAgICBjb25zdCB0b2dnbGVOaWNvbEhhbmRsZXIgPSBzdGF0ZSA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblxuICAgICAgICB0b2dnbGVOaWNvbEJ1dHRvbi5jaGVja2VkID0gc3RhdGUuaXNDcm9zc05pY29sXG4gICAgICAgIHN0YXRlLmlzQ3Jvc3NOaWNvbCA9ICFzdGF0ZS5pc0Nyb3NzTmljb2w7XG5cblxuICAgICAgICByZXMoc3RhdGUpXG4gICAgfSlcblxuICAgIHRvZ2dsZU5pY29sQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuXG4gICAgdG9nZ2xlTmljb2xMYWJlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInRvdWNoXCIsXG4gICAgICAgIGUgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB0b2dnbGVOaWNvbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInRvdWNoXCIsXG4gICAgICAgIGUgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cblxuICAgIHRvZ2dsZU5pY29sTGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZXVwXCIsXG4gICAgICAgIGUgPT4gdG9nZ2xlTmljb2xIYW5kbGVyKHN0YXRlKVxuICAgICAgICAgICAgLnRoZW4odXBkYXRlVmlldyksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdG9nZ2xlTmljb2xMYWJlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInRvdWNoZW5kXCIsXG4gICAgICAgIGUgPT4gdG9nZ2xlTmljb2xIYW5kbGVyKHN0YXRlKVxuICAgICAgICAgICAgLnRoZW4odXBkYXRlVmlldylcbiAgICAgICAgICAgIC50aGVuKF8gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlLmNhbmNlbGFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICBmYWxzZVxuICAgIClcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE1lc3NhZ2VCYXJBY3Rpdml0eVN3aXRjaGVyIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlQmFyU2VsZWN0b3IpIHtcbiAgICAgICAgdGhpcy5yb290ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihtZXNzYWdlQmFyU2VsZWN0b3IpXG4gICAgICAgIHRoaXMuaG9vayA9IHt9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuaG9va1tcImFjdGl2YXRlXCJdKHRoaXMucm9vdClcbiAgICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKVxuICAgIH1cblxuICAgIGluYWN0aXZhdGUoKSB7XG4gICAgICAgIHRoaXMuaG9va1tcImluYWN0aXZhdGVcIl0odGhpcy5yb290KVxuICAgICAgICB0aGlzLnJvb3QuY2xhc3NMaXN0LmFkZChcImluYWN0aXZlXCIpXG4gICAgfVxuXG4gICAgc2V0SG9va09uQWN0aXZhdGUoaG9vayA9IHJvb3ROb2RlID0+IHsgfSkge1xuICAgICAgICB0aGlzLmhvb2tbXCJhY3RpdmF0ZVwiXSA9IGhvb2tcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBzZXRIb29rT25JbmFjdGl2YXRlKGhvb2sgPSByb290Tm9kZSA9PiB7IH0pIHtcbiAgICAgICAgdGhpcy5ob29rW1wiaW5hY3RpdmF0ZVwiXSA9IGhvb2tcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG59XG4iLCJpbXBvcnQgTWVzc2FnZUJhckFjdGl2aXR5U3dpdGNoZXIgZnJvbSBcIi4vTWVzc2FnZUJhckFjdGl2aXR5U3dpdGNoZXIuanNcIlxuXG5jb25zdCBzd2l0Y2hFcnJvck1lc3NhZ2UgPSBuZXcgTWVzc2FnZUJhckFjdGl2aXR5U3dpdGNoZXIoXG4gICAgXCIjZXJyb3JfbWVzc2FnZV9iYXJcIlxuKS5zZXRIb29rT25JbmFjdGl2YXRlKFxuICAgIHJvb3ROb2RlID0+IHtcbiAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnJlbW92ZShcIm1lc3NhZ2UtZXJyb3JcIilcbiAgICB9XG4pXG5cbmV4cG9ydCBmdW5jdGlvbiBoaWRlRXJyb3JNZXNzYWdlKHN0YXRlKSB7XG4gICAgc3dpdGNoRXJyb3JNZXNzYWdlLmluYWN0aXZhdGUoKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2hvd0Vycm9yTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgcmV0dXJuIChfKSA9PiB7XG4gICAgICAgIHN3aXRjaEVycm9yTWVzc2FnZS5zZXRIb29rT25BY3RpdmF0ZShcbiAgICAgICAgICAgIHJvb3RET00gPT4ge1xuICAgICAgICAgICAgICAgIHJvb3RET00ucXVlcnlTZWxlY3RvcihcIi5tZXNzYWdlX3NwYWNlXCIpLmlubmVySFRNTCA9IG1lc3NhZ2VcbiAgICAgICAgICAgICAgICByb290RE9NLmNsYXNzTGlzdC5hZGQoXCJtZXNzYWdlLWVycm9yXCIpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICAgICAgc3dpdGNoRXJyb3JNZXNzYWdlLmFjdGl2YXRlKClcbiAgICAgICAgcmV0dXJuIF9cbiAgICB9XG59XG4iLCJpbXBvcnQgTWVzc2FnZUJhckFjdGl2aXR5U3dpdGNoZXIgZnJvbSBcIi4vTWVzc2FnZUJhckFjdGl2aXR5U3dpdGNoZXIuanNcIlxuXG5jb25zdCBzd2l0Y2hMb2FkaW5nTWVzc2FnZSA9IG5ldyBNZXNzYWdlQmFyQWN0aXZpdHlTd2l0Y2hlcihcbiAgICBcIiNsb2FkaW5nX21lc3NhZ2VfYmFyXCJcbikuc2V0SG9va09uQWN0aXZhdGUoXG4gICAgcm9vdE5vZGUgPT4ge1xuICAgICAgICByb290Tm9kZS5xdWVyeVNlbGVjdG9yKFwiLm1lc3NhZ2Vfc3BhY2VcIikuaW5uZXJIVE1MID0gXCJMb2FkaW5nIGltYWdlcy4uLlwiXG4gICAgICAgIHJvb3ROb2RlLmNsYXNzTGlzdC5hZGQoXCJtZXNzYWdlLWxvYWRpbmdcIilcbiAgICB9XG4pLnNldEhvb2tPbkluYWN0aXZhdGUoXG4gICAgcm9vdE5vZGUgPT4ge1xuICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKFwibWVzc2FnZS1sb2FkaW5nXCIpXG4gICAgfVxuKVxuXG5leHBvcnQgY29uc3Qgc2hvd0xvYWRpbmdNZXNzYWdlID0gc3RhdGUgPT4ge1xuICAgIHN3aXRjaExvYWRpbmdNZXNzYWdlLmFjdGl2YXRlKClcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IGhpZGVMb2FkaW5nTWVzc2FnZSA9IHN0YXRlID0+IHtcbiAgICBzd2l0Y2hMb2FkaW5nTWVzc2FnZS5pbmFjdGl2YXRlKClcbiAgICByZXR1cm4gc3RhdGVcbn1cbiIsIlxuXG5leHBvcnQgY29uc3QgaGlkZVdlbGNvbWVCb2FyZCA9IHN0YXRlID0+IHtcbiAgICBjb25zdCBib2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjd2VsY29tZS1jYXJkXCIpXG4gICAgYm9hcmQuY2xhc3NMaXN0LmFkZChcImluYWN0aXZlXCIpO1xuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3Qgc2hvd1ZpZXdlciA9IHN0YXRlID0+IHtcbiAgICBjb25zdCBjYXJkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN2aWV3ZXJfd3JhcHBlclwiKVxuICAgIGNhcmQuY2xhc3NMaXN0LnJlbW92ZShcImluYWN0aXZlXCIpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBjb25zdCBzaG93Tmljb2xCdXR0b24gPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgYnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNsb3ctbmF2aWdhdGlvblwiKVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwiaW5hY3RpdmVcIik7XG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW5pdGl6ZUlEKGlkKSB7XG4gICAgcmV0dXJuIGlkLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvXFwuL2csIFwiXCIpXG59XG4iLCJpZiAoIUhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZS50b0Jsb2IpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoSFRNTENhbnZhc0VsZW1lbnQucHJvdG90eXBlLCAndG9CbG9iJywge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGNhbGxiYWNrLCB0eXBlLCBxdWFsaXR5KSB7XG5cbiAgICAgICAgICAgIHZhciBiaW5TdHIgPSBhdG9iKHRoaXMudG9EYXRhVVJMKHR5cGUsIHF1YWxpdHkpLnNwbGl0KCcsJylbMV0pLFxuICAgICAgICAgICAgICAgIGxlbiA9IGJpblN0ci5sZW5ndGgsXG4gICAgICAgICAgICAgICAgYXJyID0gbmV3IFVpbnQ4QXJyYXkobGVuKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGFycltpXSA9IGJpblN0ci5jaGFyQ29kZUF0KGkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgQmxvYihbYXJyXSwgeyB0eXBlOiB0eXBlIHx8ICdpbWFnZS9wbmcnIH0pKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYnVmZmVyVG9CYXNlNjQoYnVmZmVyLCBleHQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cbiAgICAgICAgdmFyIGJ5dGVzID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICAgICAgdmFyIGJpbmFyeSA9ICcnO1xuICAgICAgICB2YXIgbGVuID0gYnl0ZXMuYnl0ZUxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgYmluYXJ5ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHJlcyhgZGF0YTppbWFnZS8ke2V4dH07YmFzZTY0LGAgKyB3aW5kb3cuYnRvYShiaW5hcnkpKTtcbiAgICB9KVxufVxuXG5cbmV4cG9ydCBmdW5jdGlvbiBibG9iVG9CYXNlNjQoYmxvYikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyO1xuICAgICAgICByZWFkZXIub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgcmVhZGVyLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUocmVhZGVyLnJlc3VsdCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlYWRlci5yZWFkQXNEYXRhVVJMKGJsb2IpO1xuICAgIH0pO1xufVxuIiwiZXhwb3J0IGZ1bmN0aW9uIHByb2dyZXNzTG9hZGluZyhzZWxlY3Rvcikge1xuICAgIGNvbnN0IHByb2dyZXNzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICBjb25zdCBiYXIgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFwiLmJhclwiKVxuICAgIGJhci5zdHlsZS53aWR0aCA9IFwiMCVcIlxuICAgIGNvbnN0IHRvdGFsID0gcHJvZ3Jlc3MuY2xpZW50V2lkdGhcbiAgICByZXR1cm4gZSA9PiB7XG4gICAgICAgIGJhci5zdHlsZS53aWR0aCA9IGAkeyhlLmxvYWRlZCAvIGUudG90YWwpICogMTAwfSVgXG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY29tcGxldGVMb2FkaW5nKHNlbGVjdG9yKSB7XG4gICAgY29uc3QgcHJvZ3Jlc3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHNlbGVjdG9yKVxuICAgIGNvbnN0IGJhciA9IHByb2dyZXNzLnF1ZXJ5U2VsZWN0b3IoXCIuYmFyXCIpXG4gICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBiYXIuc3R5bGUud2lkdGggPSBcIjAlXCJcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBwcm9ncmVzc0xvYWRpbmcsIGNvbXBsZXRlTG9hZGluZyB9IGZyb20gXCIuL3Byb2dyZXNzX2Jhcl9oYW5kbGVycy5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVuemlwcGVyKHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblxuICAgICAgICBaaXAuaW5mbGF0ZV9maWxlKHVybCwgcmVzLCByZWosIHByb2dyZXNzTG9hZGluZyhcIiNwcm9ncmVzc19iYXJcIiksIGNvbXBsZXRlTG9hZGluZyhcIiNwcm9ncmVzc19iYXJcIikpXG4gICAgfSlcbn1cbiIsImltcG9ydCB7IGJ1ZmZlclRvQmFzZTY0IH0gZnJvbSBcIi4vZGF0YV90cmFuc2xhdGVycy5qc1wiXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gemlwXG4gKiBAcmV0dXJuIHtPYmplY3RbbWV0YSx6aXBdfVxuICovXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBleHRyYWN0RmlsZSh6aXBCeXRlKSB7XG4gICAgY29uc3QgemlwID0gWmlwLmluZmxhdGUoemlwQnl0ZSlcbiAgICBjb25zdCBpbmZsYXRlZF96aXAgPSB7fVxuICAgIGF3YWl0IFByb21pc2UuYWxsKE9iamVjdC5lbnRyaWVzKHppcC5maWxlcykubWFwKGFzeW5jIGt2ID0+IHtcbiAgICAgICAgaWYgKGt2WzBdLmluY2x1ZGVzKFwiLmpzb25cIikpIHtcbiAgICAgICAgICAgIGluZmxhdGVkX3ppcFtrdlswXV0gPSBrdlsxXS5pbmZsYXRlKClcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHR5cGUgPSBrdlswXS5tYXRjaCgvLipcXC4oXFx3KykkLylbMV1cbiAgICAgICAgICAgIGNvbnN0IGJhc2U2NCA9IGF3YWl0IGJ1ZmZlclRvQmFzZTY0KGt2WzFdLmluZmxhdGUoKSwgdHlwZSlcbiAgICAgICAgICAgIGNvbnN0IG1pbWUgPSBiYXNlNjQubWF0Y2goL15kYXRhOihpbWFnZVxcL1xcdyspOy8pWzFdXG4gICAgICAgICAgICBjb25zdCBtaW1lX3R5cGUgPSBtaW1lLnNwbGl0KFwiL1wiKVsxXVxuXG4gICAgICAgICAgICBjb25zdCBuZXdfZmlsZV9uYW1lID0ga3ZbMF0uc3BsaXQoXCIuXCIpWzBdICsgXCIuXCIgKyBtaW1lX3R5cGVcblxuICAgICAgICAgICAgaW5mbGF0ZWRfemlwW25ld19maWxlX25hbWVdID0gYmFzZTY0XG5cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfSkpXG5cbiAgICByZXR1cm4gaW5mbGF0ZWRfemlwXG59XG4iLCJpbXBvcnQgeyBzdGF0aWNTZXR0aW5ncyB9IGZyb20gXCIuL2NvbmZpZy9jb25maWcuanNcIlxuaW1wb3J0IHNhbml0aXplSUQgZnJvbSBcIi4vc2FuaXRpemVJRC5qc1wiXG5pbXBvcnQgeyBibG9iVG9CYXNlNjQgfSBmcm9tIFwiLi9kYXRhX3RyYW5zbGF0ZXJzLmpzXCJcbmltcG9ydCB1bnppcHBlciBmcm9tIFwiLi91bnppcHBlci5qc1wiXG5pbXBvcnQgZXh0cmFjdEZpbGUgZnJvbSBcIi4vZXh0cmFjdEZpbGUuanNcIlxuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcmV0dXJuIHtBcnJheVtTdHJpbmcsIEJvb2xlYW5dfSBbbGFzdE1vZGlmaWVkLCBuZXR3b3JrRGlzY29ubmVjdGVkXVxuICovXG5hc3luYyBmdW5jdGlvbiBxdWVyeUxhc3RNb2RpZmllZCh1cmwpIHtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBhd2FpdCBmZXRjaCh1cmwsIHsgbWV0aG9kOiAnSEVBRCcsIG1vZGU6ICdjb3JzJyB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiUGFja2FnZSBtZXRhZGF0YSBjYW5ub3QgYmUgZmV0Y2hlZC5cIilcbiAgICAgICAgICAgIHRocm93IEVycm9yKGUpXG4gICAgICAgIH0pXG4gICAgICAgIHZhciBsYXN0TW9kaWZpZWQgPSBoZWFkZXIuaGVhZGVycy5nZXQoXCJsYXN0LW1vZGlmaWVkXCIpXG4gICAgICAgIHZhciBuZXR3b3JrRGlzY29ubmVjdGVkID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIFtsYXN0TW9kaWZpZWQsIG5ldHdvcmtEaXNjb25uZWN0ZWRdXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgbGFzdE1vZGlmaWVkID0gXCJub25lXCJcbiAgICAgICAgdmFyIG5ldHdvcmtEaXNjb25uZWN0ZWQgPSB0cnVlXG4gICAgICAgIHJldHVybiBbbGFzdE1vZGlmaWVkLCBuZXR3b3JrRGlzY29ubmVjdGVkXVxuICAgIH1cbn1cblxuY2xhc3MgQWRob2NQYWNrYWdlUmVwbyB7XG4gICAgY29uc3RydWN0b3Ioc3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZSA9IHN0YXRlXG4gICAgfVxuXG4gICAgcmVzb2x2ZUltYWdlUGFja2FnZShwYWNrYWdlSWQsIGRlc2lyZWRGb3JtYXQsIG1hbmlmZXN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIHNlbGVjdEZvcm1hdFdpdGhGYWxsYmFja1RvSnBnKGxpc3QsIGZvcm1hdCkge1xuICAgICAgICAgICAgaWYgKGxpc3QuaW5jbHVkZXMoZm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwianBnXCJcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmb3JtYXQgPSBtYW5pZmVzdC5oYXNPd25Qcm9wZXJ0eSgnaW1hZ2VfZm9ybWF0cycpICYmIG1hbmlmZXN0W1wiaW1hZ2VfZm9ybWF0c1wiXSAhPSBudWxsXG4gICAgICAgICAgICA/IHNlbGVjdEZvcm1hdFdpdGhGYWxsYmFja1RvSnBnKG1hbmlmZXN0LmltYWdlX2Zvcm1hdHMsIGRlc2lyZWRGb3JtYXQpXG4gICAgICAgICAgICA6IGRlc2lyZWRGb3JtYXRcbiAgICAgICAgY29uc29sZS5sb2coZm9ybWF0KVxuICAgICAgICByZXR1cm4gW3N0YXRpY1NldHRpbmdzLmdldEltYWdlRGF0YVBhdGgocGFja2FnZUlkKSArIGZvcm1hdCArIFwiLnppcFwiLCBmb3JtYXRdXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICog44GT44Gu6Zai5pWw44Gu6L+U44KK5YCk44Gu5qeL6YCg44KS44KC44Gkb2JqZWN044KS6L+U44GZ44Gu44GM6LKs5YuZ44CCXG4gICAgICog44KI44Gj44Gm44GT44Gu6Zai5pWw44Gn55S75YOP44OR44OD44Kx44O844K444GudW56aXDjgoLooYzjgaPjgabjgYTjgovjgIJcbiAgICAgKiBcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFja2FnZUlkXG4gICAgICogQHJldHVybnMge1Byb21pc2V9XG4gICAgICogICAgIHppcDogT2JqZWN0PFN0cmluZywgSW1hZ2UgQmxvYj5cbiAgICAgKi9cbiAgICBhc3luYyByZXRyaWV2ZShwYWNrYWdlSWQsIGRlc2lyZWRGb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWFuaWZlc3RVcmwgPSBzdGF0aWNTZXR0aW5ncy5nZXRJbWFnZURhdGFQYXRoKHBhY2thZ2VJZCkgKyBcIm1hbmlmZXN0Lmpzb25cIjtcbiAgICAgICAgY29uc3Qgb3Blbl90aHVtYm5haWxVcmwgPSBzdGF0aWNTZXR0aW5ncy5nZXRJbWFnZURhdGFQYXRoKHBhY2thZ2VJZCkgKyBcIm8xLmpwZ1wiO1xuICAgICAgICBjb25zdCBjcm9zc190aHVtYm5haWxVcmwgPSBzdGF0aWNTZXR0aW5ncy5nZXRJbWFnZURhdGFQYXRoKHBhY2thZ2VJZCkgKyBcImMxLmpwZ1wiO1xuICAgICAgICBjb25zdCBtYW5pZmVzdFRleHQgPSBhd2FpdCBmZXRjaChtYW5pZmVzdFVybCwgeyBtb2RlOiAnY29ycycgfSkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS50ZXh0KCkpXG4gICAgICAgIGNvbnN0IG1hbmlmZXN0ID0gSlNPTi5wYXJzZShtYW5pZmVzdFRleHQpO1xuXG4gICAgICAgIGNvbnN0IFt6aXBVcmwsIGZvcm1hdF0gPSB0aGlzLnJlc29sdmVJbWFnZVBhY2thZ2UocGFja2FnZUlkLCBkZXNpcmVkRm9ybWF0LCBtYW5pZmVzdClcbiAgICAgICAgY29uc3QgW2xhc3RNb2RpZmllZCwgX10gPSBhd2FpdCBxdWVyeUxhc3RNb2RpZmllZCh6aXBVcmwpXG4gICAgICAgIGNvbnN0IHVuemlwcGVkID0gYXN5bmMgKCkgPT4gdW56aXBwZXIoemlwVXJsKS50aGVuKGV4dHJhY3RGaWxlKVxuXG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgbWFuaWZlc3Q6IG1hbmlmZXN0VGV4dCwgLy8g44KC44GXSW5kZXhlZERC44GrT2JqZWN044KS5L+d5a2Y44Gn44GN44KL44Gq44KJ44K344Oq44Ki44Op44Kk44K65LiN6KaBXG4gICAgICAgICAgICB0aHVtYm5haWw6IHtcbiAgICAgICAgICAgICAgICBcIm8xLmpwZ1wiOiBhd2FpdCBmZXRjaChvcGVuX3RodW1ibmFpbFVybCwgeyBtb2RlOiAnY29ycycgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYmxvYigpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihibG9iVG9CYXNlNjQpLFxuICAgICAgICAgICAgICAgIFwiYzEuanBnXCI6IGF3YWl0IGZldGNoKGNyb3NzX3RodW1ibmFpbFVybCwgeyBtb2RlOiAnY29ycycgfSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4ocmVzcG9uc2UgPT4gcmVzcG9uc2UuYmxvYigpKVxuICAgICAgICAgICAgICAgICAgICAudGhlbihibG9iVG9CYXNlNjQpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGFzdE1vZGlmaWVkOiBsYXN0TW9kaWZpZWQsXG4gICAgICAgICAgICBpZDogcGFja2FnZUlkLFxuICAgICAgICAgICAgemlwOiB1bnppcHBlZCxcbiAgICAgICAgICAgIGltYWdlX2Zvcm1hdDogZm9ybWF0XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0SW1hZ2VzTGFzdE1vZGlmaWVkKHBhY2thZ2VJZCwgZGVzaXJlZEZvcm1hdCkge1xuICAgICAgICBjb25zdCBtYW5pZmVzdFVybCA9IHN0YXRpY1NldHRpbmdzLmdldEltYWdlRGF0YVBhdGgocGFja2FnZUlkKSArIFwibWFuaWZlc3QuanNvblwiO1xuICAgICAgICBjb25zdCBtYW5pZmVzdCA9IGF3YWl0IGZldGNoKG1hbmlmZXN0VXJsLCB7IG1vZGU6ICdjb3JzJyB9KS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICAgICAgY29uc3QgW3ppcFVybCwgX10gPSB0aGlzLnJlc29sdmVJbWFnZVBhY2thZ2UocGFja2FnZUlkLCBkZXNpcmVkRm9ybWF0LCBtYW5pZmVzdClcbiAgICAgICAgY29uc3QgW2xhc3RNb2RpZmllZCwgbmV0d29ya0Rpc2Nvbm5lY3RlZF0gPSBhd2FpdCBxdWVyeUxhc3RNb2RpZmllZCh6aXBVcmwpXG4gICAgICAgIHJldHVybiBbbGFzdE1vZGlmaWVkLCBuZXR3b3JrRGlzY29ubmVjdGVkXVxuICAgIH1cbn1cblxuLyoqXG4gKiDmjIflrprjgZfjgZ9rZXnjga7jg4fjg7zjgr/jgYxEQuOBruS4reOBq+OBguOCi+WgtOWQiCwgRELjgYvjgonjg4fjg7zjgr/jgpLlj5blvpfjgZnjgosuXG4gKiDjgrXjg7zjg5DjgahEQuOBp+ODh+ODvOOCv+OBruacgOe1guabtOaWsOaZguWIu+OBjOS4gOiHtOOBmeOCjOOBsCxcbiAqICBEQuOBruODh+ODvOOCv+OCkui/lOOBmS5cbiAqIOODjeODg+ODiOODr+ODvOOCr+OCqOODqeODvOOBruWgtOWQiCwgRELjga7jg4fjg7zjgr/jgYvnhKHjgpLov5TjgZlcbiAqXG4gKiDjgZ3jgYbjgafjgarjgZHjgozjgbDjgrXjg7zjg5DjgYvjgoltYW5pZmVzdOOBqHRodW1ibmFpbOOCkuWPluW+l+OBl+OBpui/lOOBmS5cbiAqIOOBvuOBnywg55S75YOP5pys5L2T44Guemlw44OV44Kh44Kk44Or44KSZmV0Y2jjgZnjgovjgqLjgq/jgrfjg6fjg7PjgpLotbfjgZPjgZnplqLmlbDjgpLov5TjgZkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFja2FnZU5hbWVcbiAqIEByZXR1cm4ge0FycmF5W09iamVjdCxCb29sZWFuXX0gW3Jlc3BvbnNlLCB0b0JlU3RvcmVkXVxuICovXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBxdWVyeUltYWdlUGFja2FnZShcbiAgICBzdGF0ZSxcbiAgICBwYWNrYWdlTmFtZVxuKSB7XG4gICAgY29uc3QgaWQgPSBzYW5pdGl6ZUlEKHBhY2thZ2VOYW1lKVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSBhd2FpdCBzdGF0ZS56aXBEQkhhbmRsZXIuZ2V0KHN0YXRlLnppcERCLCBpZClcbiAgICBjb25zdCByZXBvID0gbmV3IEFkaG9jUGFja2FnZVJlcG8oc3RhdGUpXG4gICAgY29uc3QgW2xhc3RNb2RpZmllZCwgbmV0d29ya0Rpc2Nvbm5lY3RlZF0gPSBhd2FpdCByZXBvLmdldEltYWdlc0xhc3RNb2RpZmllZChpZCwgc3RhdGUuc3VwcG9ydGVkSW1hZ2VUeXBlKVxuXG4gICAgaWYgKHN0b3JlZERhdGEgIT09IHVuZGVmaW5lZCAmJiBzdG9yZWREYXRhLmxhc3RNb2RpZmllZCA9PT0gbGFzdE1vZGlmaWVkKSB7XG4gICAgICAgIHZhciB0b0JlU3RvcmVkID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIFtzdG9yZWREYXRhLCB0b0JlU3RvcmVkXVxuICAgIH1cbiAgICBpZiAobmV0d29ya0Rpc2Nvbm5lY3RlZCkge1xuICAgICAgICBpZiAoc3RvcmVkRGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB2YXIgdG9CZVN0b3JlZCA9IGZhbHNlXG4gICAgICAgICAgICByZXR1cm4gW3N0b3JlZERhdGEsIHRvQmVTdG9yZWRdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW251bGwsIGZhbHNlXVxuICAgICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXBvLnJldHJpZXZlKGlkLCBzdGF0ZS5zdXBwb3J0ZWRJbWFnZVR5cGUpXG4gICAgICAgIHZhciB0b0JlU3RvcmVkID0gdHJ1ZVxuICAgICAgICByZXR1cm4gW3Jlc3BvbnNlLCB0b0JlU3RvcmVkXVxuICAgIH1cbn1cbiIsImltcG9ydCBzYW5pdGl6ZUlEIGZyb20gXCIuL3Nhbml0aXplSUQuanNcIlxuaW1wb3J0IHsgY3ljbGVCeSwgc3RlcEJ5IH0gZnJvbSBcIi4vcm90YXRpb25fZGVncmVlX2hhbmRsZXJzLmpzXCJcblxuZnVuY3Rpb24gZ2V0Um90YXRpb25DZW50ZXIobWV0YSkge1xuICAgIHJldHVybiAobWV0YS5oYXNPd25Qcm9wZXJ0eShcInJvdGF0ZV9jZW50ZXJcIikpXG4gICAgICAgID8ge1xuICAgICAgICAgICAgXCJ0b19yaWdodFwiOiBtZXRhLnJvdGF0ZV9jZW50ZXJbMF0sXG4gICAgICAgICAgICBcInRvX2JvdHRvbVwiOiBtZXRhLnJvdGF0ZV9jZW50ZXJbMV1cbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIFwidG9fcmlnaHRcIjogbWV0YS5pbWFnZV93aWR0aCAqIDAuNSxcbiAgICAgICAgICAgIFwidG9fYm90dG9tXCI6IG1ldGEuaW1hZ2VfaGVpZ2h0ICogMC41XG4gICAgICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VSYWRpdXMobWV0YSkge1xuICAgIGNvbnN0IHNoaWZ0ID0gZ2V0Um90YXRpb25DZW50ZXIobWV0YSk7XG4gICAgY29uc3QgaW1hZ2VfY2VudGVyID0ge1xuICAgICAgICBcInhcIjogbWV0YS5pbWFnZV93aWR0aCAqIDAuNSxcbiAgICAgICAgXCJ5XCI6IG1ldGEuaW1hZ2VfaGVpZ2h0ICogMC41XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgICAgaW1hZ2VfY2VudGVyLnggLSBNYXRoLmFicyhpbWFnZV9jZW50ZXIueCAtIHNoaWZ0LnRvX3JpZ2h0KSxcbiAgICAgICAgaW1hZ2VfY2VudGVyLnkgLSBNYXRoLmFicyhpbWFnZV9jZW50ZXIueSAtIHNoaWZ0LnRvX2JvdHRvbSlcbiAgICApXG59XG5cbmZ1bmN0aW9uIG1hcE1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCByb3RhdGVfZGVncmVlX3N0ZXAgPSBwYXJzZUludChtZXRhLnJvdGF0ZV9ieV9kZWdyZWUpXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0Nsb2Nrd2lzZTogbWV0YS5yb3RhdGVfY2xvY2t3aXNlLFxuICAgICAgICBsb2NhdGlvbjogbWV0YS5sb2NhdGlvbixcbiAgICAgICAgcm9ja1R5cGU6IG1ldGEucm9ja190eXBlLFxuICAgICAgICBvd25lcjogbWV0YS5vd25lcixcbiAgICAgICAgZGVzY3JpcHRpb246IG1ldGEuaGFzT3duUHJvcGVydHkoXCJkaXNjcmlwdGlvblwiKVxuICAgICAgICAgICAgPyBtZXRhLmRpc2NyaXB0aW9uXG4gICAgICAgICAgICA6IG1ldGEuaGFzT3duUHJvcGVydHkoXCJkZXNjcmlwdGlvblwiKVxuICAgICAgICAgICAgICAgID8gbWV0YS5kZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIHJvdGF0ZV9jZW50ZXI6IGdldFJvdGF0aW9uQ2VudGVyKG1ldGEpLFxuICAgICAgICBpbWFnZVdpZHRoOiBtZXRhLmltYWdlX3dpZHRoLFxuICAgICAgICBpbWFnZUhlaWdodDogbWV0YS5pbWFnZV9oZWlnaHQsXG4gICAgICAgIGltYWdlUmFkaXVzOiBnZXRJbWFnZVJhZGl1cyhtZXRhKSxcbiAgICAgICAgaW1hZ2VSYWRpdXNPcmlnaW5hbDogZ2V0SW1hZ2VSYWRpdXMobWV0YSksXG4gICAgICAgIHNjYWxlV2lkdGg6IG1ldGEuaGFzT3duUHJvcGVydHkoXCJzY2FsZS1waXhlbFwiKVxuICAgICAgICAgICAgPyBwYXJzZUludChtZXRhW1wic2NhbGUtcGl4ZWxcIl0pXG4gICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBzY2FsZVRleHQ6IG1ldGEuaGFzT3duUHJvcGVydHkoXCJzY2FsZS11bml0XCIpXG4gICAgICAgICAgICA/IG1ldGFbXCJzY2FsZS11bml0XCJdXG4gICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICByb3RhdGVfZGVncmVlX3N0ZXA6IHJvdGF0ZV9kZWdyZWVfc3RlcFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlU3RhdGVCeU1ldGEoc3RhdGUpIHtcbiAgICByZXR1cm4gKGNvbnRhaW5vcklELCBtZXRhKSA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblxuICAgICAgICBzdGF0ZS5jb250YWlub3JJRCA9IHNhbml0aXplSUQoY29udGFpbm9ySUQpO1xuXG4gICAgICAgIGNvbnN0IHJvdGF0ZV9kZWdyZWVfc3RlcCA9IHBhcnNlSW50KG1ldGEucm90YXRlX2J5X2RlZ3JlZSlcbiAgICAgICAgY29uc3QgY3ljbGVfZGVncmVlID0gbWV0YS5oYXNPd25Qcm9wZXJ0eShcImN5Y2xlX3JvdGF0ZV9kZWdyZWVcIilcbiAgICAgICAgICAgID8gcGFyc2VJbnQobWV0YS5jeWNsZV9yb3RhdGVfZGVncmVlKVxuICAgICAgICAgICAgOiA5MDtcbiAgICAgICAgY29uc3QgaW1hZ2VfbnVtYmVyID0gY3ljbGVfZGVncmVlIC8gcm90YXRlX2RlZ3JlZV9zdGVwICsgMVxuICAgICAgICBjb25zdCBtaXJyb3JfYXQgPSAoaW1hZ2VfbnVtYmVyIC0gMSlcbiAgICAgICAgY29uc3QgdG90YWxfc3RlcCA9IChpbWFnZV9udW1iZXIgLSAxKSAqIDJcblxuICAgICAgICBzdGF0ZS5pbWFnZV9udW1iZXIgPSBpbWFnZV9udW1iZXJcbiAgICAgICAgc3RhdGUuZ2V0SW1hZ2VOdW1iZXIgPSBjeWNsZV9kZWdyZWUgPiAwXG4gICAgICAgICAgICA/IGRlZ3JlZSA9PiBjeWNsZUJ5KGltYWdlX251bWJlciAtIDEpKFxuICAgICAgICAgICAgICAgIHN0ZXBCeShyb3RhdGVfZGVncmVlX3N0ZXApKHN0YXRlLmlzQ2xvY2t3aXNlID8gMzYwIC0gZGVncmVlIDogZGVncmVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBkZWdyZWUgPT4gbWlycm9yQnkobWlycm9yX2F0KShcbiAgICAgICAgICAgICAgICBjeWNsZUJ5KHRvdGFsX3N0ZXApKFxuICAgICAgICAgICAgICAgICAgICBzdGVwQnkocm90YXRlX2RlZ3JlZV9zdGVwKShkZWdyZWUpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgIHN0YXRlLmdldEFscGhhID0gZGVncmVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG50aCA9IGN5Y2xlQnkodG90YWxfc3RlcCAqIDIpKFxuICAgICAgICAgICAgICAgIHN0ZXBCeShyb3RhdGVfZGVncmVlX3N0ZXApKGRlZ3JlZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAxIC0gKGRlZ3JlZSAtIHJvdGF0ZV9kZWdyZWVfc3RlcCAqIG50aCkgLyByb3RhdGVfZGVncmVlX3N0ZXBcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm9wZW5faW1hZ2VzID0gW11cbiAgICAgICAgc3RhdGUuY3Jvc3NfaW1hZ2VzID0gW11cblxuICAgICAgICBzdGF0ZS5yb3RhdGUgPSAwO1xuXG4gICAgICAgIHN0YXRlID0gT2JqZWN0LmFzc2lnbihzdGF0ZSwgbWFwTWV0YWRhdGEobWV0YSkpXG5cbiAgICAgICAgcmVzKHN0YXRlKVxuICAgIH0pXG59XG4iLCIvKipcbiAqXG4gKiBAcGFyYW0ge1N0cmluZyxPYmplY3RbU3RyaW5nLFN0cmluZ119IG11bHRpTGFuZ3VhZ2VUZXh0T2JqXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNlbGVjdEZyb21NdWx0aUxhbmd1YWdlKG11bHRpTGFuZ3VhZ2VUZXh0T2JqLCBsYW5ndWFnZUNvZGUpIHtcbiAgICBpZiAodHlwZW9mIChtdWx0aUxhbmd1YWdlVGV4dE9iaikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIG11bHRpTGFuZ3VhZ2VUZXh0T2JqXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgKG11bHRpTGFuZ3VhZ2VUZXh0T2JqKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAobXVsdGlMYW5ndWFnZVRleHRPYmouaGFzT3duUHJvcGVydHkobGFuZ3VhZ2VDb2RlKSkge1xuICAgICAgICAgICAgcmV0dXJuIG11bHRpTGFuZ3VhZ2VUZXh0T2JqW2xhbmd1YWdlQ29kZV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhtdWx0aUxhbmd1YWdlVGV4dE9iailcbiAgICAgICAgICAgIHJldHVybiAoa2V5cy5sZW5ndGggPiAwKVxuICAgICAgICAgICAgICAgID8gbXVsdGlMYW5ndWFnZVRleHRPYmpba2V5c1swXV1cbiAgICAgICAgICAgICAgICA6IFwiXCJcbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBcIlwiXG4gICAgfVxufVxuIiwiaW1wb3J0IHNlbGVjdEZyb21NdWx0aUxhbmd1YWdlIGZyb20gXCIuL3NlbGVjdEZyb21NdWx0aUxhbmd1YWdlLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlVmlld0Rlc2NyaXB0aW9uKHN0YXRlKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb25Cb3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3ZpZXdfZGVzY3JpcHRpb25cIilcbiAgICBjb25zdCBsYW5nID0gc3RhdGUudWlTdGF0ZS5sYW5ndWFnZVxuXG4gICAgY29uc3Qgcm9ja0Zyb20gPSBgJHtzZWxlY3RGcm9tTXVsdGlMYW5ndWFnZShzdGF0ZS5yb2NrVHlwZSwgbGFuZyl9ICR7c3RhdGUubG9jYXRpb24gPyBcIihcIiArIHNlbGVjdEZyb21NdWx0aUxhbmd1YWdlKHN0YXRlLmxvY2F0aW9uLCBsYW5nKSArIFwiKVwiIDogXCJcIn1gXG4gICAgY29uc3Qgcm9ja0Rpc2MgPSBzZWxlY3RGcm9tTXVsdGlMYW5ndWFnZShzdGF0ZS5kZXNjcmlwdGlvbiwgbGFuZylcbiAgICBjb25zdCByb2NrT3duZXIgPSBzZWxlY3RGcm9tTXVsdGlMYW5ndWFnZShzdGF0ZS5vd25lciwgbGFuZylcblxuICAgIGNvbnN0IHRleHRUZW1wbGF0ZSA9IGA8dWwgc3R5bGU9XCJsaXN0LXN0eWxlLXR5cGU6bm9uZTtcIj5cbiAgICAgICAgICAgIDxsaT4ke3JvY2tGcm9tfTwvbGk+XG4gICAgICAgICAgICA8bGk+JHtyb2NrRGlzY308L2xpPlxuICAgICAgICAgICAgPGxpPiR7cm9ja093bmVyfTwvbGk+XG4gICAgICAgIDwvdWw+YFxuXG4gICAgZGVzY3JpcHRpb25Cb3guaW5uZXJIVE1MID0gdGV4dFRlbXBsYXRlO1xuICAgIHJldHVybiBzdGF0ZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0T3BlbkFuZENyb3NzSW1hZ2VzKHN0YXRlKSB7XG4gICAgcmV0dXJuIGltZ1NldHMgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHN0YXRlLm9wZW5faW1hZ2VzID0gaW1nU2V0cy5vcGVuXG4gICAgICAgIHN0YXRlLmNyb3NzX2ltYWdlcyA9IGltZ1NldHMuY3Jvc3NcbiAgICAgICAgcmVzKHN0YXRlKVxuICAgIH0pXG59XG4iLCJmdW5jdGlvbiBoYW5kbGVJbWdTcmMoc3JjKSB7XG4gICAgaWYgKHNyYyBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgY29uc3QgdXJsID0gd2luZG93LlVSTCB8fCB3aW5kb3cud2Via2l0VVJMO1xuICAgICAgICByZXR1cm4gdXJsLmNyZWF0ZU9iamVjdFVSTChzcmMpXG4gICAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBTdHJpbmcpIHtcbiAgICAgICAgcmV0dXJuIHNyY1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBzcmNcbiAgICB9XG59XG5cbi8qKlxuICogQHBhcmFtZXRlciBzcmMge2RhdGFVUkx9XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGxvYWRJbWFnZVNyYyhzcmMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKClcblxuICAgICAgICBpbWcub25sb2FkID0gXyA9PiB7XG4gICAgICAgICAgICBpbWcub25uZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgcmVzKGltZylcbiAgICAgICAgfVxuICAgICAgICBpbWcub25lcnJvciA9IGUgPT4ge1xuICAgICAgICAgICAgcmVzKGltZylcbiAgICAgICAgfVxuXG4gICAgICAgIGltZy5zcmMgPSBoYW5kbGVJbWdTcmMoc3JjKVxuICAgIH0pXG59XG4iLCJpbXBvcnQgc2V0T3BlbkFuZENyb3NzSW1hZ2VzIGZyb20gXCIuL3NldE9wZW5BbmRDcm9zc0ltYWdlcy5qc1wiXG5pbXBvcnQgbG9hZEltYWdlU3JjIGZyb20gXCIuL2xvYWRJbWFnZVNyYy5qc1wiXG5cbmZ1bmN0aW9uIHNlbGVjdEltYWdlSW5Db250YWlub3IoY29udGFpbm9yLCBwcmVmaXgpIHtcbiAgICBpZiAocHJlZml4IGluIGNvbnRhaW5vcikge1xuICAgICAgICByZXR1cm4gY29udGFpbm9yW3ByZWZpeF1cbiAgICB9XG4gICAgcmV0dXJuIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LGlWQk9SdzBLR2dvQUFBQU5TVWhFVWdBQUFBRUFBQUFCQ0FRQUFBQzFIQXdDQUFBQUMwbEVRVlFJMTJOZ1lBQUFBQU1BQVNEVmxNY0FBQUFBU1VWT1JLNUNZSUk9XCJcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlSW1hZ2VTcmMoaW1hZ2VzTWFwLCBleHQpIHtcbiAgICByZXR1cm4gKHN0YXRlKSA9PiBuZXcgUHJvbWlzZShhc3luYyAocmVzLCByZWopID0+IHtcblxuICAgICAgICBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICBQcm9taXNlLmFsbChBcnJheShzdGF0ZS5pbWFnZV9udW1iZXIgLSAxKS5maWxsKDApXG4gICAgICAgICAgICAgICAgLm1hcCgoXywgaSkgPT4gc2VsZWN0SW1hZ2VJbkNvbnRhaW5vcihpbWFnZXNNYXAsIGBvJHtpICsgMX0uJHtleHR9YCkpXG4gICAgICAgICAgICAgICAgLm1hcChsb2FkSW1hZ2VTcmMpXG4gICAgICAgICAgICApLFxuICAgICAgICAgICAgUHJvbWlzZS5hbGwoQXJyYXkoc3RhdGUuaW1hZ2VfbnVtYmVyIC0gMSkuZmlsbCgwKVxuICAgICAgICAgICAgICAgIC5tYXAoKF8sIGkpID0+IHNlbGVjdEltYWdlSW5Db250YWlub3IoaW1hZ2VzTWFwLCBgYyR7aSArIDF9LiR7ZXh0fWApKVxuICAgICAgICAgICAgICAgIC5tYXAobG9hZEltYWdlU3JjKVxuICAgICAgICAgICAgKVxuICAgICAgICBdKS50aGVuKGltZ0RPTXMgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3Blbl9pbWdzID0gaW1nRE9Nc1swXVxuXG4gICAgICAgICAgICBjb25zdCBjcm9zc19pbWdzID0gaW1nRE9Nc1sxXVxuXG4gICAgICAgICAgICByZXR1cm4geyBvcGVuOiBvcGVuX2ltZ3MsIGNyb3NzOiBjcm9zc19pbWdzIH1cbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKHNldE9wZW5BbmRDcm9zc0ltYWdlcyhzdGF0ZSkpXG4gICAgICAgICAgICAudGhlbihyZXMpXG4gICAgfSlcbn1cbiIsIi8qKlxuICpcbiAqIEBwYXJhbSB7Kn0gc3RhdGVcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcmV0dXJuIHtPYmplY3RbbWV0YSx6aXBdfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByZWdpc3RlclppcChzdGF0ZSkge1xuICAgIHJldHVybiBhc3luYyAoZW50cnkpID0+IHtcblxuICAgICAgICBjb25zdCBfbmV3T25lID0gYXdhaXQgc3RhdGUuemlwREJIYW5kbGVyLnB1dChzdGF0ZS56aXBEQiwgZW50cnkpXG5cbiAgICAgICAgc3RhdGUudWlTdGF0ZS5zdG9yZWRLZXlzLnB1c2goZW50cnkuaWQpXG5cbiAgICAgICAgaWYgKHN0YXRlLnVpU3RhdGUuc3RvcmVkS2V5cy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkZXN0ID0gc3RhdGUudWlTdGF0ZS5zdG9yZWRLZXlzLnNoaWZ0KClcbiAgICAgICAgICAgIGNvbnN0IF9kZWxldGVkID0gYXdhaXQgc3RhdGUuemlwREJIYW5kbGVyLmRlbGV0ZShzdGF0ZS56aXBEQiwgb2xkZXN0KVxuICAgICAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAjcm9ja19zZWxlY3Rvcj5vcHRpb25bdmFsdWU9JHtvbGRlc3R9XWApKS5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb24uaW5uZXJIVE1MLnJlcGxhY2UoXCLinJMgXCIsIFwiXCIpXG4gICAgICAgICAgICAgICAgb3B0aW9uLmlubmVySFRNTCA9IGxhYmVsXG4gICAgICAgICAgICAgICAgb3B0aW9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb3dubG9hZGVkXCIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxufVxuIiwiaW1wb3J0IHJlZ2lzdGVyWmlwIGZyb20gXCIuL3JlZ2lzdGVyWmlwLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVnaXN0ZXIoc3RhdGUsIGlzTmV3RGF0YSkge1xuICAgIGlmIChpc05ld0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgcmVnaXN0ZXJaaXAoc3RhdGUpKGVudHJ5KVxuICAgICAgICAgICAgICAgIC50aGVuKHJlcylcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXyA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIHJlcyhzdGF0ZSlcbiAgICAgICAgfSlcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAcGFyYW0geyp9IHBhY2thZ2VOYW1lXG4gKiBAcmV0dXJuIHtPYmplY3RbbWV0YSx6aXBdfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXJrRG93bmxvYWRlZE9wdGlvbihwYWNrYWdlTmFtZSkge1xuICAgIHJldHVybiBtYW5pZmVzdCA9PiBfID0+IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCNyb2NrX3NlbGVjdG9yPm9wdGlvblt2YWx1ZT0ke3BhY2thZ2VOYW1lfV1gKSkuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb24uaW5uZXJIVE1MLnJlcGxhY2UoXCLinJMgXCIsIFwiXCIpXG4gICAgICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gXCLinJMgXCIgKyBsYWJlbFxuICAgICAgICAgICAgb3B0aW9uLmNsYXNzTGlzdC5hZGQoXCJkb3dubG9hZGVkXCIpXG4gICAgICAgIH0pXG4gICAgICAgIHJlcyhfKVxuICAgIH0pXG59XG4iLCJpbXBvcnQgeyBoaWRlRXJyb3JNZXNzYWdlIH0gZnJvbSBcIi4vZXJyb3JfaW5kaWNhdG9yX2hhbmRsZXIuanNcIlxuaW1wb3J0IHsgc2hvd0xvYWRpbmdNZXNzYWdlIH0gZnJvbSBcIi4vbG9hZGluZ19pbmRpY2F0b3JfaGFuZGxlci5qc1wiXG5pbXBvcnQgeyBoaWRlV2VsY29tZUJvYXJkLCBzaG93Vmlld2VyLCBzaG93Tmljb2xCdXR0b24gfSBmcm9tIFwiLi92aWV3ZXJfaGFuZGxlcnMuanNcIlxuaW1wb3J0IHF1ZXJ5SW1hZ2VQYWNrYWdlIGZyb20gXCIuL3F1ZXJ5SW1hZ2VQYWNrYWdlLmpzXCJcbmltcG9ydCB1cGRhdGVTdGF0ZUJ5TWV0YSBmcm9tIFwiLi91cGRhdGVTdGF0ZUJ5TWV0YS5qc1wiXG5pbXBvcnQgdXBkYXRlVmlld0Rlc2NyaXB0aW9uIGZyb20gXCIuL3VwZGF0ZVZpZXdEZXNjcmlwdGlvbi5qc1wiXG5pbXBvcnQgdXBkYXRlSW1hZ2VTcmMgZnJvbSBcIi4vdXBkYXRlSW1hZ2VTcmMuanNcIlxuaW1wb3J0IHJlZ2lzdGVyIGZyb20gXCIuL3JlZ2lzdGVyLmpzXCJcbmltcG9ydCBtYXJrRG93bmxvYWRlZE9wdGlvbiBmcm9tIFwiLi9tYXJrRG93bmxvYWRlZE9wdGlvbi5qc1wiXG5pbXBvcnQgdXBkYXRlVmlldyBmcm9tIFwiLi91cGRhdGVWaWV3LmpzXCJcblxuLyoqXG4gKiBmZXRjaCBsYXN0bW9kaWZpZWRcbiAqIGZldGNoIG1hbmlmZXN0XG4gKiBmZXRjaCBzdW1ibmFpbFxuICpcbiAqIHNob3cgc3VtYm5haWxcbiAqIHNob3cgZGlzY3JpcHRpb25cbiAqXG4gKiBsb2FkIGltYWdlc1xuICogIGZyb20gZGJcbiAqICBmZXRjaFxuICpcbiAqIHN0b3JlIGRhdGFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm9ja05hbWVTZWxlY3RIYW5kbGVyKHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXMsIHJlaikgPT4ge1xuICAgICAgICBjb25zdCByb2NrX3NlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb2NrX3NlbGVjdG9yXCIpXG4gICAgICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcm9ja19zZWxlY3Rvci5vcHRpb25zW3JvY2tfc2VsZWN0b3Iuc2VsZWN0ZWRJbmRleF0udmFsdWVcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9IHBhY2thZ2VOYW1lXG5cbiAgICAgICAgc3RhdGUuY2FuUm90YXRlID0gZmFsc2U7XG4gICAgICAgIGhpZGVFcnJvck1lc3NhZ2UoKVxuICAgICAgICBzaG93TG9hZGluZ01lc3NhZ2UoKVxuICAgICAgICBoaWRlV2VsY29tZUJvYXJkKClcbiAgICAgICAgc2hvd1ZpZXdlcigpXG4gICAgICAgIHNob3dOaWNvbEJ1dHRvbigpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtyZXNwb25zZSwgaXNOZXdEYXRhXSA9IGF3YWl0IHF1ZXJ5SW1hZ2VQYWNrYWdlKHN0YXRlLCBwYWNrYWdlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IEpTT04ucGFyc2UocmVzcG9uc2UubWFuaWZlc3QpO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdfc3RhdGUgPSBhd2FpdCB1cGRhdGVTdGF0ZUJ5TWV0YShzdGF0ZSkocGFja2FnZU5hbWUsIG1hbmlmZXN0KVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXdEZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICAudGhlbih1cGRhdGVJbWFnZVNyYyhyZXNwb25zZS50aHVtYm5haWwsIFwianBnXCIpKVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG5cbiAgICAgICAgICAgIG5ld19zdGF0ZS5jYW5Sb3RhdGUgPSB0cnVlXG5cbiAgICAgICAgICAgIGlmIChpc05ld0RhdGEpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS56aXAgPSBhd2FpdCByZXNwb25zZS56aXAoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVJbWFnZVNyYyhyZXNwb25zZS56aXAsIHJlc3BvbnNlLmltYWdlX2Zvcm1hdCkobmV3X3N0YXRlKVxuICAgICAgICAgICAgICAgIC50aGVuKHN0YXRlID0+IHJlZ2lzdGVyKHN0YXRlLCBpc05ld0RhdGEpKHJlc3BvbnNlKSlcbiAgICAgICAgICAgICAgICAudGhlbihtYXJrRG93bmxvYWRlZE9wdGlvbihwYWNrYWdlTmFtZSkobWFuaWZlc3QpKVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWooZSlcbiAgICAgICAgfVxuICAgIH0pXG59XG4iLCJpbXBvcnQgcm9ja05hbWVTZWxlY3RIYW5kbGVyIGZyb20gXCIuL3JvY2tOYW1lU2VsZWN0SGFuZGxlci5qc1wiXG5pbXBvcnQgdXBkYXRlVmlldyBmcm9tIFwiLi91cGRhdGVWaWV3LmpzXCJcbmltcG9ydCB7IHNob3dFcnJvck1lc3NhZ2UsIGhpZGVFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi9lcnJvcl9pbmRpY2F0b3JfaGFuZGxlci5qc1wiXG5pbXBvcnQgeyBoaWRlTG9hZGluZ01lc3NhZ2UgfSBmcm9tIFwiLi9sb2FkaW5nX2luZGljYXRvcl9oYW5kbGVyLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0Um9ja1NlbGVjdEV2ZW50SGFuZGxlcnMoc3RhdGUpIHtcbiAgICBjb25zdCByb2NrX3NlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb2NrX3NlbGVjdG9yXCIpXG5cbiAgICByb2NrX3NlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgcm9ja05hbWVTZWxlY3RIYW5kbGVyKHN0YXRlKVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG4gICAgICAgICAgICAgICAgLnRoZW4oaGlkZUVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAudGhlbihoaWRlTG9hZGluZ01lc3NhZ2UpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNhbXBsZSBjYW5ub3QgYmUgbG9hZGVkIGJlY2F1c2Ugb2YgbmV0d29yayBlcnJvci5cIilcbiAgICAgICAgICAgICAgICAgICAgc2hvd0Vycm9yTWVzc2FnZShcIkludGVybmV0IGRpc2Nvbm5lY3RlZC5cIikoZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVPbkNhbnZhcyhjYW52YXMpIHtcbiAgICByZXR1cm4gKGUsIGZpbmd1ciA9IDApID0+IHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBXaGVlbEV2ZW50KVxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICBlLmRlbHRhWCxcbiAgICAgICAgICAgICAgICAgICAgZS5kZWx0YVlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgICAgIGUucGFnZVggLSBjYW52YXMub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgZS5wYWdlWSAtIGNhbnZhcy5vZmZzZXRUb3BcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQgJiYgZS50b3VjaGVzLmxlbmd0aCA+IGZpbmd1cikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBlLnRvdWNoZXNbZmluZ3VyXS5wYWdlWCAtIGNhbnZhcy5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIGUudG91Y2hlc1tmaW5ndXJdLnBhZ2VZIC0gY2FudmFzLm9mZnNldFRvcFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmFkaXVuQmV0d2VlbihjeCwgY3kpIHtcbiAgICByZXR1cm4gKF94MSwgX3kxLCBfeDIsIF95MikgPT4ge1xuICAgICAgICBjb25zdCB4MSA9IF94MSAtIGN4XG4gICAgICAgIGNvbnN0IHgyID0gX3gyIC0gY3hcbiAgICAgICAgY29uc3QgeTEgPSBfeTEgLSBjeVxuICAgICAgICBjb25zdCB5MiA9IF95MiAtIGN5XG5cbiAgICAgICAgY29uc3QgY29zID0gKHgxICogeDIgKyB5MSAqIHkyKSAvIE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSlcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbih4MSAqIHkyIC0geDIgKiB5MSkgKiBNYXRoLmFjb3MoY29zKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IHZpZXdlciB9IGZyb20gXCIuL3ZpZXdlcl9jYW52YXMuanNcIlxuaW1wb3J0IGdldENvb3JkaW5hdGVPbkNhbnZhcyBmcm9tIFwiLi9nZXRDb29yZGluYXRlT25DYW52YXMuanNcIlxuaW1wb3J0IHJhZGl1bkJldHdlZW4gZnJvbSBcIi4vcmFkaXVuQmV0d2Vlbi5qc1wiXG5cblxuZXhwb3J0IGNvbnN0IGNhbnZhc0Nvb3JkaW5hdGUgPSBnZXRDb29yZGluYXRlT25DYW52YXModmlld2VyKVxuXG4vKipcbiAqIFVwZGF0ZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uXG4gKiBAcGFyYW0geyp9IHN0YXRlXG4gKiBAcGFyYW0geyp9IGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNvb3JkaW5hdGUoc3RhdGUsIGUpIHtcbiAgICBzdGF0ZS5kcmFnX3N0YXJ0ID0gc3RhdGUuZHJhZ19lbmQgfHwgdW5kZWZpbmVkXG4gICAgc3RhdGUuZHJhZ19lbmQgPSBjYW52YXNDb29yZGluYXRlKGUpXG5cbiAgICBzdGF0ZS5waW5jaF9zdGFydCA9IHN0YXRlLnBpbmNoX2VuZCB8fCB1bmRlZmluZWRcbiAgICBzdGF0ZS5waW5jaF9lbmQgPSBjYW52YXNDb29yZGluYXRlKGUsIDEpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHNtYWxsIGRpZmZlcmVuY2Ugb2Ygcm90YXRpb24uXG4gKiBVcGRhdGUgdG90YWwgcm90YXRpb24uXG4gKlxuICogQHBhcmFtIHsqfSBzdGF0ZVxuICogQHBhcmFtIHsqfSBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVSb3RhdGUoc3RhdGUsIGUpIHtcbiAgICBpZiAoIXN0YXRlLmNhblJvdGF0ZSkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5kcmFnX3N0YXJ0ID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIC8vIGRlbHRhIHJvdGF0ZSByYWRpdXNcbiAgICBjb25zdCByb3RhdGVfZW5kID0gcmFkaXVuQmV0d2VlbihcbiAgICAgICAgc3RhdGUuY2FudmFzV2lkdGggKiAwLjUsXG4gICAgICAgIHN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNVxuICAgICkoLi4uc3RhdGUuZHJhZ19lbmQsIC4uLnN0YXRlLmRyYWdfc3RhcnQpXG5cbiAgICBzdGF0ZS5yb3RhdGUgKz0gcm90YXRlX2VuZCAvIE1hdGguUEkgKiAxODBcbiAgICBpZiAoc3RhdGUucm90YXRlID49IDM2MCkge1xuICAgICAgICBzdGF0ZS5yb3RhdGUgLT0gMzYwXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5yb3RhdGUgPCAwKSB7XG4gICAgICAgIHN0YXRlLnJvdGF0ZSArPSAzNjBcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJpbXBvcnQgeyB1cGRhdGVDb29yZGluYXRlLCB1cGRhdGVSb3RhdGUgfSBmcm9tIFwiLi9jb29yZGluYXRlX3VwZGF0b3JzLmpzXCJcbmltcG9ydCB7IGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lIH0gZnJvbSBcIi4vZHJhd19zdGF0ZV91cGRhdG9ycy5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJvdGF0ZUltYWdlKHN0YXRlLCBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShzdGF0ZSwgZSlcbiAgICAgICAgdXBkYXRlUm90YXRlKHN0YXRlLCBlKVxuICAgICAgICBibG9iVG9DYW52YXMoc3RhdGUpXG4gICAgICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjYW52YXNDb29yZGluYXRlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZV91cGRhdG9ycy5qc1wiXG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNYWduaWZ5QnlQaW5jaChzdGF0ZSwgZSkge1xuICAgIGlmIChzdGF0ZS5kcmFnX3N0YXJ0ID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIGlmIChzdGF0ZS5waW5jaF9zdGFydCA9PT0gdW5kZWZpbmVkKSByZXR1cm5cblxuICAgIGNvbnN0IHgxID0gWy4uLnN0YXRlLmRyYWdfc3RhcnRdXG4gICAgY29uc3QgeTEgPSBbLi4uc3RhdGUucGluY2hfc3RhcnRdXG4gICAgY29uc3QgeDIgPSBbLi4uc3RhdGUuZHJhZ19lbmRdXG4gICAgY29uc3QgeTIgPSBbLi4uc3RhdGUucGluY2hfZW5kXVxuXG4gICAgY29uc3QgZXhwYW5zaW9uID0gTWF0aC5zcXJ0KCh4MlswXSAtIHkyWzBdKSAqKiAyICsgKHgyWzFdIC0geTJbMV0pICoqIDIpIC8gTWF0aC5zcXJ0KCh4MVswXSAtIHkxWzBdKSAqKiAyICsgKHgxWzFdIC0geTFbMV0pICoqIDIpXG5cbiAgICBjb25zdCBuZXdSYWRpdXMgPSAoZXhwYW5zaW9uID4gMilcbiAgICAgICAgPyBzdGF0ZS5pbWFnZVJhZGl1c1xuICAgICAgICA6IHN0YXRlLmltYWdlUmFkaXVzIC8gZXhwYW5zaW9uXG4gICAgc3RhdGUuaW1hZ2VSYWRpdXMgPSAobmV3UmFkaXVzKSA+IHN0YXRlLmltYWdlUmFkaXVzT3JpZ2luYWxcbiAgICAgICAgPyBzdGF0ZS5pbWFnZVJhZGl1c09yaWdpbmFsXG4gICAgICAgIDogKG5ld1JhZGl1cyA8IDEwMClcbiAgICAgICAgICAgID8gMTAwXG4gICAgICAgICAgICA6IG5ld1JhZGl1c1xuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWFnbmlmeUJ5V2hlZWwoc3RhdGUsIGUpIHtcbiAgICBjb25zdCBzY3JvbGxlZCA9IGNhbnZhc0Nvb3JkaW5hdGUoZSlbMV1cblxuICAgIGNvbnN0IG5ld1JhZGl1cyA9IHN0YXRlLmltYWdlUmFkaXVzICsgc2Nyb2xsZWRcbiAgICBzdGF0ZS5pbWFnZVJhZGl1cyA9IChuZXdSYWRpdXMpID4gc3RhdGUuaW1hZ2VSYWRpdXNPcmlnaW5hbFxuICAgICAgICA/IHN0YXRlLmltYWdlUmFkaXVzT3JpZ2luYWxcbiAgICAgICAgOiAobmV3UmFkaXVzIDwgMTAwKVxuICAgICAgICAgICAgPyAxMDBcbiAgICAgICAgICAgIDogbmV3UmFkaXVzXG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJpbXBvcnQgeyB1cGRhdGVDb29yZGluYXRlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZV91cGRhdG9ycy5qc1wiXG5pbXBvcnQgeyB1cGRhdGVNYWduaWZ5QnlQaW5jaCB9IGZyb20gXCIuL3VwZGF0ZU1hZ25pZnkuanNcIlxuaW1wb3J0IHsgYmxvYlRvQ2FudmFzLCBkcmF3SGFpckxpbmUsIGRyYXdTY2FsZSB9IGZyb20gXCIuL2RyYXdfc3RhdGVfdXBkYXRvcnMuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaW5jaEltYWdlKHN0YXRlLCBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShzdGF0ZSwgZSlcbiAgICAgICAgdXBkYXRlTWFnbmlmeUJ5UGluY2goc3RhdGUsIGUpXG4gICAgICAgIGJsb2JUb0NhbnZhcyhzdGF0ZSlcbiAgICAgICAgZHJhd0hhaXJMaW5lKHN0YXRlKVxuICAgICAgICBkcmF3U2NhbGUoc3RhdGUpXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2FudmFzQ29vcmRpbmF0ZSB9IGZyb20gXCIuL2Nvb3JkaW5hdGVfdXBkYXRvcnMuanNcIlxuaW1wb3J0IHJvdGF0ZUltYWdlIGZyb20gXCIuL3JvdGF0ZUltYWdlLmpzXCJcbmltcG9ydCBwaW5jaEltYWdlIGZyb20gXCIuL3BpbmNoSW1hZ2UuanNcIlxuXG5leHBvcnQgY29uc3QgdG91Y2hTdGFydEhhbmRsZXIgPSBzdGF0ZSA9PiBlID0+IHtcbiAgICBzdGF0ZS5pc01vdXNlZG93biA9IHRydWVcbiAgICBzdGF0ZS5kcmFnX2VuZCA9IGNhbnZhc0Nvb3JkaW5hdGUoZSlcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBjb25zdCB0b3VjaE1vdmVIYW5kbGVyID0gc3RhdGUgPT4gZSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5pc01vdXNlZG93bikgcmV0dXJuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50IHx8IGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXG4gICAgICAgICAgICByb3RhdGVJbWFnZShzdGF0ZSwgZSlcbiAgICAgICAgKVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICAgICAgcGluY2hJbWFnZShzdGF0ZSwgZSlcbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvdWNoRW5kSGFuZGxlciA9IHN0YXRlID0+IGUgPT4ge1xuICAgIHN0YXRlLmlzTW91c2Vkb3duID0gZmFsc2VcbiAgICBzdGF0ZS5kcmFnX2VuZCA9IHVuZGVmaW5lZFxuICAgIHN0YXRlLnBpbmNoX2VuZCA9IHVuZGVmaW5lZFxuICAgIGUucHJldmVudERlZmF1bHQoKVxufVxuIiwiaW1wb3J0IHsgdXBkYXRlTWFnbmlmeUJ5V2hlZWwgfSBmcm9tIFwiLi91cGRhdGVNYWduaWZ5LmpzXCJcbmltcG9ydCB7IGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lLCBkcmF3U2NhbGUgfSBmcm9tIFwiLi9kcmF3X3N0YXRlX3VwZGF0b3JzLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2hlZWxJbWFnZShzdGF0ZSwgZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZU1hZ25pZnlCeVdoZWVsKHN0YXRlLCBlKVxuICAgICAgICBibG9iVG9DYW52YXMoc3RhdGUpXG4gICAgICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICAgICAgZHJhd1NjYWxlKHN0YXRlKVxuICAgIH1cbn1cbiIsImltcG9ydCB3aGVlbEltYWdlIGZyb20gXCIuL3doZWVsSW1hZ2UuanNcIlxuXG5leHBvcnQgY29uc3Qgd2hlZWxIYW5kbGVyID0gc3RhdGUgPT4gZSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgd2hlZWxJbWFnZShzdGF0ZSwgZSlcbiAgICApXG59XG4iLCJpbXBvcnQgeyB2aWV3ZXIgfSBmcm9tIFwiLi92aWV3ZXJfY2FudmFzLmpzXCJcbmltcG9ydCB7IHRvdWNoU3RhcnRIYW5kbGVyLCB0b3VjaE1vdmVIYW5kbGVyLCB0b3VjaEVuZEhhbmRsZXIgfSBmcm9tIFwiLi90b3VjaEV2ZW50SGFuZGxlcnMuanNcIlxuaW1wb3J0IHsgd2hlZWxIYW5kbGVyIH0gZnJvbSBcIi4vd2hlZWxFdmVudEhhbmRsZXIuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRDYW52YXNFdmVudEhhbmRsZXJzKHN0YXRlKSB7XG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2Vkb3duXCIsXG4gICAgICAgIHRvdWNoU3RhcnRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJkcmFnc3RhcnRcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImRyYWdcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImRyYWdlbmRcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAgIHRvdWNoU3RhcnRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZW1vdmVcIixcbiAgICAgICAgdG91Y2hNb3ZlSGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAgIHRvdWNoTW92ZUhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNldXBcIixcbiAgICAgICAgdG91Y2hFbmRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICB0b3VjaEVuZEhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIndoZWVsXCIsXG4gICAgICAgIHdoZWVsSGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxufVxuIiwiaW1wb3J0IHsgc3RhdGljU2V0dGluZ3MsIGNhY2hlU3RvcmFnZSB9IGZyb20gXCIuLi9jb25maWcvY29uZmlnLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZmV0Y2hTYW1wbGVMaXN0V2l0aENhY2hlKCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzLCByZWopID0+IHtcbiAgICAgICAgY29uc3QgbGlzdFVSTCA9IHN0YXRpY1NldHRpbmdzLmdldFNhbXBsZUxpc3RVUkwoKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IGF3YWl0IGZldGNoKGxpc3RVUkwsIHsgbW9kZTogJ2NvcnMnIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlKSA9PiB7IHRocm93IEVycm9yKGUpIH0pXG4gICAgICAgICAgICAgICAgLnRoZW4ociA9PiByLmpzb24oKSlcbiAgICAgICAgICAgIGNhY2hlU3RvcmFnZS5wdXQoXCJsaXN0X29mX3NhbXBsZVwiLCBKU09OLnN0cmluZ2lmeShyZXNwb25zZVtcImxpc3Rfb2Zfc2FtcGxlXCJdKSlcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdmFyIHN0b3JlZF9saXN0ID0gY2FjaGVTdG9yYWdlLmdldChcImxpc3Rfb2Zfc2FtcGxlXCIpXG4gICAgICAgICAgICB2YXIgcmVzcG9uc2UgPSB7IFwibGlzdF9vZl9zYW1wbGVcIjogSlNPTi5wYXJzZShzdG9yZWRfbGlzdCkgfVxuICAgICAgICAgICAgcmVqKGUpXG4gICAgICAgIH1cbiAgICAgICAgcmVzKHJlc3BvbnNlKVxuICAgIH0pXG59XG4iLCIvKipcbiAqIOOCteODs+ODl+ODq+ODquOCueODiOOCknNlbGVjdOOCv+OCsOWGheOBq+i/veWKoOOBmeOCi1xuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzaG93U2FtcGxlTGlzdChzYW1wbGVMaXN0LCBsYW5nLCBjYWNoZWRMaXN0ID0gW10pIHsgLy8gdGhpcyBmdW5jdGlvbiBzaG91bGQgdGFrZSBzdGF0ZSBhcyBhcmdcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIGNvbnN0IHNhbXBsZVNlbGVjdERPTSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcm9ja19zZWxlY3RvclwiKTtcbiAgICAgICAgc2FtcGxlU2VsZWN0RE9NLmlubmVySFRNTCA9IFwiPG9wdGlvbiB2YWx1ZT0nJyBkaXNhYmxlZCBzZWxlY3RlZCBzdHlsZT0nZGlzcGxheTpub25lOyc+U2VsZWN0IHNhbXBsZTwvb3B0aW9uPlwiO1xuICAgICAgICBjb25zdCBvcHRpb25zID0gc2FtcGxlTGlzdC5tYXAoKHYsIGkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIilcbiAgICAgICAgICAgIG9wdGlvbi52YWx1ZSA9IHZbXCJwYWNrYWdlLW5hbWVcIl07XG4gICAgICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gKGNhY2hlZExpc3QuaW5jbHVkZXModltcInBhY2thZ2UtbmFtZVwiXSkgPyBcIuKckyBcIiA6IFwiXCIpICsgYCR7aSArIDF9LiAke3ZbXCJsaXN0LW5hbWVcIl1bbGFuZ119YFxuICAgICAgICAgICAgaWYgKGNhY2hlZExpc3QuaW5jbHVkZXModltcInBhY2thZ2UtbmFtZVwiXSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uY2xhc3NMaXN0LmFkZChcImRvd25sb2FkZWRcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25cbiAgICAgICAgfSlcbiAgICAgICAgb3B0aW9ucy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgICAgc2FtcGxlU2VsZWN0RE9NLmFwcGVuZENoaWxkKHYpXG4gICAgICAgIH0pXG5cbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0b3AtbmF2aWdhdGlvblwiKS5jbGFzc0xpc3QuYWRkKFwiaXNyZWFkeVwiKTtcbiAgICAgICAgc2FtcGxlU2VsZWN0RE9NLmNsYXNzTGlzdC5hZGQoXCJpc3JlYWR5XCIpXG4gICAgICAgIHJlcygpO1xuICAgIH0pXG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTYW1wbGVGaWx0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHF1ZXJpZXMgPSBbXSkge1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBuZXcgU2V0KHF1ZXJpZXMubWFwKHRoaXMubGlzdFRvUXVlcnkpKVxuICAgIH1cblxuICAgIGFkZChxdWVyeSkge1xuICAgICAgICB0aGlzLnF1ZXJpZXMuYWRkKHRoaXMubGlzdFRvUXVlcnkocXVlcnkpKVxuICAgIH1cblxuICAgIGFkZE1hbnkocXVlcmllcykge1xuICAgICAgICBxdWVyaWVzLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJpZXMuYWRkKHRoaXMubGlzdFRvUXVlcnkodikpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmVtb3ZlKHZhbHVlKSB7XG4gICAgICAgIHRoaXMucXVlcmllcy5kZWxldGUodGhpcy5saXN0VG9RdWVyeSh2YWx1ZSkpXG4gICAgfVxuXG4gICAgcmVtb3ZlTWFueSh2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzLmZvckVhY2godiA9PiB7XG4gICAgICAgICAgICB0aGlzLnF1ZXJpZXMuZGVsZXRlKHRoaXMubGlzdFRvUXVlcnkodikpXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmVzZXQocXVlcmllcykge1xuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBuZXcgU2V0KHF1ZXJpZXMubWFwKHRoaXMubGlzdFRvUXVlcnkpKVxuICAgIH1cblxuICAgIGxpc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJpZXNcbiAgICB9XG5cbiAgICBsaXN0VG9RdWVyeShwYXRoKSB7XG4gICAgICAgIHJldHVybiBwYXRoLnJlZHVjZSgoYWNjLCBlKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWNjID09PSBcIlwiKSByZXR1cm4gZVxuICAgICAgICAgICAgcmV0dXJuIGFjYyArIFwiOjpcIiArIGVcbiAgICAgICAgfSwgXCJcIilcbiAgICB9XG5cbiAgICBmaWx0ZXIoc2FtcGxlTGlzdCkge1xuICAgICAgICBpZiAodGhpcy5xdWVyaWVzLnNpemUgPT09IDApIHJldHVybiBzYW1wbGVMaXN0XG5cbiAgICAgICAgY29uc3QgcXVlcmllcyA9IFsuLi50aGlzLnF1ZXJpZXNdLm1hcCh2ID0+IHYuc3BsaXQoXCI6OlwiKSlcbiAgICAgICAgcmV0dXJuIHNhbXBsZUxpc3QuZmlsdGVyKHNhbXBsZSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNhbXBsZS5oYXNPd25Qcm9wZXJ0eShcImNhdGVnb3J5XCIpKSByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIGNvbnN0IHN1cGVyc2V0ID0gbmV3IFNldChzYW1wbGUuY2F0ZWdvcnkpXG4gICAgICAgICAgICBmb3IgKGxldCBxdWVyeSBvZiBxdWVyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzU3Vic2V0KHF1ZXJ5LCBzdXBlcnNldCkpIHJldHVybiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxufVxuXG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7U2V0fSBzZXRcbiAqIEBwYXJhbSB7U2V0fSBzdXBlcnNldFxuICovXG5mdW5jdGlvbiBpc1N1YnNldChzZXQsIHN1cGVyc2V0KSB7XG4gICAgaWYgKHNldC5zaXplID09IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgZm9yIChsZXQgZWxlbSBvZiBzZXQpIHtcbiAgICAgICAgaWYgKCFzdXBlcnNldC5oYXMoZWxlbSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbiIsImltcG9ydCBmZXRjaE9yTG9va3VwU2FtcGxlTGlzdCBmcm9tIFwiLi4vc2FtcGxlX2xpc3QvZmV0Y2hfc2FtcGxlX2xpc3Rfd2l0aF9jYWNoZS5qc1wiXG5pbXBvcnQgc2hvd1NhbXBsZUxpc3QgZnJvbSBcIi4uL3NhbXBsZV9saXN0L3Nob3dfc2FtcGxlX2xpc3QuanNcIlxuaW1wb3J0IFNhbXBsZUZpbHRlciBmcm9tIFwiLi4vcmVtb3RlX3JlcG8vc3RhdGljL2ZpbHRlcl9ieV9jYXRlZ29yeS5qc1wiXG5cbi8qKlxuICogXG4gKiBMYW5ndWFnZSA9IFwiZW5cIiB8IFwiamFcIlxuICogU2FtcGxlS2V5czogQXJyYXk8U3RyaW5nPlxuICpcbiAqIEBwYXJhbSB7TGFuZ3VhZ2V9IHVpTGFuZ3VhZ2VcbiAqIEBwYXJhbSB7U2FtcGxlS2V5c30gY2FjaGVkU2FtcGxlS2V5c1xuICogQHBhcmFtIHtTYW1wbGVGaWx0ZXJ9IHNhbXBsZUZpbHRlclxuICogQHJldHVybiB7UHJvbWlzZX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gdXBkYXRlU2FtcGxlTGlzdCh1aUxhbmd1YWdlLCBjYWNoZWRTYW1wbGVLZXlzLCBzYW1wbGVGaWx0ZXIpIHtcbiAgICBjb25zdCByZXNwb25zZUpzb24gPSBhd2FpdCBmZXRjaE9yTG9va3VwU2FtcGxlTGlzdCgpIC8vIHNhbXBsZUZpbHRlciBzaG91bGQgYmUgcGFzc2VkIHRvIHRoaXMgZnVuY3Rpb25cbiAgICBjb25zdCBzYW1wbGVzVG9CZVNob3duID0gc2FtcGxlRmlsdGVyLmZpbHRlcihyZXNwb25zZUpzb25bXCJsaXN0X29mX3NhbXBsZVwiXSlcbiAgICBzaG93U2FtcGxlTGlzdChzYW1wbGVzVG9CZVNob3duLCB1aUxhbmd1YWdlLCBjYWNoZWRTYW1wbGVLZXlzKVxuICAgIHJldHVybiBzYW1wbGVzVG9CZVNob3duXG59XG4iLCJpbXBvcnQgeyBzdGF0aWNTZXR0aW5ncyB9IGZyb20gXCIuLi9jb25maWcvY29uZmlnLmpzXCJcblxuY2xhc3MgQ2F0ZWdvcnlTdGF0ZSB7XG4gICAgY29uc3RydWN0b3IocGF0aCwgc2VsZWN0ZWQpIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aFxuICAgICAgICB0aGlzLnNlbGVjdGVkID0gc2VsZWN0ZWRcbiAgICB9XG5cbiAgICBnZXRQYXRoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXRoXG4gICAgfVxuXG4gICAgaXNTZWxlY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VsZWN0ZWRcbiAgICB9XG59XG5cbi8qKlxuICogXG4gKiBAcGFyYW0ge0h0bWxFbGVtZW50fSB3cmFwcGVyXG4gKiBAcGFyYW0ge1wiamFcIiB8IFwiZW5cIn0gbGFuZ1xuICovXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBnZW5lcmF0ZUNhdGVnb3J5U2VsZWN0b3Iod3JhcHBlciwgc3RhdGUpIHtcbiAgICBjb25zdCBjYXRlZ29yeSA9IGF3YWl0IGZldGNoKHN0YXRpY1NldHRpbmdzLmdldFNhbXBsZUNhdGVnb3J5VVJMKCkpXG4gICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmpzb24oKSlcbiAgICBjb25zdCBhY3RpdmVDYXRlZ29yaWVzID0gY2F0ZWdvcnkuY2F0ZWdvcmllcy5tYXAoY2F0ID0+IHtcbiAgICAgICAgY29uc3QgW2NoaWxkLCBjYXRlZ29yaWVzXSA9IG1ha2VDYXRlZ29yeUltcGwoY2F0LCBzdGF0ZS51aVN0YXRlLmxhbmd1YWdlKVxuICAgICAgICBpZiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoY2hpbGQpXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNhdGVnb3JpZXNcbiAgICB9KS5mbGF0KClcbiAgICBzdGF0ZS51aVN0YXRlLnNhbXBsZUZpbHRlci5yZXNldChcbiAgICAgICAgYWN0aXZlQ2F0ZWdvcmllcy5maWx0ZXIoY2F0U3RhdGUgPT4gY2F0U3RhdGUuaXNTZWxlY3RlZCgpKVxuICAgICAgICAgICAgLm1hcChjYXRTdGF0ZSA9PiBjYXRTdGF0ZS5nZXRQYXRoKCkpXG4gICAgKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIFNhbXBsZUNhdGVnb3J5ID0ge1xuICogIGlkOiBTdHJpbmcsXG4gKiAgbGFiZWw6IHtcbiAqICAgIGphOiBTdHJpbmcsXG4gKiAgICBlbjogU3RyaW5nXG4gKiAgfSxcbiAqICBzdWJjYXRlZ29yaWVzOiBBcnJheTxDYXRlZ29yeT5cbiAqIH1cbiAqIEBwYXJhbSB7U2FtcGxlQ2F0ZWdvcnl9IGNhdGVnb3J5XG4gKi9cbmZ1bmN0aW9uIG1ha2VDYXRlZ29yeUltcGwoY2F0ZWdvcnksIGxhbmcsIGxldmVsID0gMCwgcGFyZW50Q2F0ZWdvcnkgPSBbXSkge1xuICAgIGNvbnN0IGNhdGVnb3J5UGF0aCA9IGFwcGVuZENhdGVnb3J5KHBhcmVudENhdGVnb3J5LCBjYXRlZ29yeS5pZClcbiAgICBjb25zdCBjaGVja2JveElkID0gYGNhdGVnb3J5LWdyb3VwX18ke2NvbmNhdENhdGVnb3J5KGNhdGVnb3J5UGF0aCwgXCJfX1wiKX1gXG4gICAgY29uc3QgY2hlY2tib3hFbGVtID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7Y2hlY2tib3hJZH1gKVxuICAgIGNvbnN0IGNhdFN0YXRlID0gbmV3IENhdGVnb3J5U3RhdGUoY2F0ZWdvcnlQYXRoLCBjaGVja2JveEVsZW0gPT09IG51bGwgPyBmYWxzZSA6IGNoZWNrYm94RWxlbS5jaGVja2VkKVxuICAgIC8vIEJlY2F1c2UgY2F0ZWdvcnkgaXMgc3RhdGljLCB1cGRhdGUgbGFiZWwgaWYgdGhlIGNhdGVnb3J5IHNlbGVjdG9yIGV4aXN0cy5cbiAgICBpZiAoY2hlY2tib3hFbGVtKSB7XG4gICAgICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgIyR7Y2hlY2tib3hJZH0rbGFiZWxgKVxuICAgICAgICBsYWJlbC5pbm5lclRleHQgPSBjYXRlZ29yeS5sYWJlbFtsYW5nXVxuICAgICAgICBsZXQgc3ViY2F0ZWdvcmllcyA9IGNhdGVnb3J5LnN1YmNhdGVnb3JpZXMubWFwKHN1YmNhdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBbX25leHRJbm5lciwgY2F0XSA9IG1ha2VDYXRlZ29yeUltcGwoc3ViY2F0LCBsYW5nLCBsZXZlbCArIDEsIGNhdGVnb3J5UGF0aClcbiAgICAgICAgICAgIHJldHVybiBjYXRcbiAgICAgICAgfSkuZmxhdCgpXG4gICAgICAgIHJldHVybiBbbnVsbCwgWy4uLnN1YmNhdGVnb3JpZXMsIGNhdFN0YXRlXV1cbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgbmV3IGVsZW1lbnRzXG4gICAgY29uc3QgW291dGVyLCBpbm5lcl0gPSBsZXZlbCA+PSAzXG4gICAgICAgID8gbWFrZUJvdHRvbUxldmVsKClcbiAgICAgICAgOiBsZXZlbCA+PSAyXG4gICAgICAgICAgICA/IG1ha2VNaWRkbGVMZXZlbCgpXG4gICAgICAgICAgICA6IG1ha2VUb3BMZXZlbCgpXG4gICAgY29uc3QgbGFiZWxDbGFzcyA9IGNhdGVnb3J5LnN1YmNhdGVnb3JpZXMubGVuZ3RoID4gMFxuICAgICAgICA/IFwic3VwZXJfY2F0ZWdvcnlcIlxuICAgICAgICA6IFwiY2F0ZWdvcnlcIlxuICAgIGNvbnN0IGNoZWNrYm94ID0gYFxuICAgIDxpbnB1dCB0eXBlPVwiY2hlY2tib3hcIiBjbGFzcz1cIiR7bGFiZWxDbGFzc30tY2hlY2tib3ggJHtjb25jYXRDYXRlZ29yeShjYXRlZ29yeVBhdGgsIFwiIFwiKX1cIiB2YWx1ZT1cIiR7Y29uY2F0Q2F0ZWdvcnkoY2F0ZWdvcnlQYXRoLCBcIl9fXCIpfVwiXG4gICAgICAgIGlkPVwiJHtjaGVja2JveElkfVwiPlxuICAgIDxsYWJlbCBmb3I9XCIke2NoZWNrYm94SWR9XCIgY2xhc3M9XCIke2xhYmVsQ2xhc3N9ICR7Y29uY2F0Q2F0ZWdvcnkoY2F0ZWdvcnlQYXRoLCBcIiBcIil9XCI+JHtjYXRlZ29yeS5sYWJlbFtsYW5nXX08L2xhYmVsPlxuICAgIGBcbiAgICBvdXRlci5pbm5lckhUTUwgPSBjaGVja2JveFxuXG4gICAgaWYgKGNhdGVnb3J5LnN1YmNhdGVnb3JpZXMubGVuZ3RoID4gMCkge1xuICAgICAgICBsZXQgc3ViY2F0ZWdvcmllcyA9IGNhdGVnb3J5LnN1YmNhdGVnb3JpZXMubWFwKHN1YmNhdCA9PiB7XG4gICAgICAgICAgICBjb25zdCBbbmV4dElubmVyLCBjYXRdID0gbWFrZUNhdGVnb3J5SW1wbChzdWJjYXQsIGxhbmcsIGxldmVsICsgMSwgY2F0ZWdvcnlQYXRoKVxuICAgICAgICAgICAgaW5uZXIuYXBwZW5kQ2hpbGQobmV4dElubmVyKVxuICAgICAgICAgICAgcmV0dXJuIGNhdFxuICAgICAgICB9KS5mbGF0KClcbiAgICAgICAgb3V0ZXIuYXBwZW5kQ2hpbGQoaW5uZXIpXG4gICAgICAgIHJldHVybiBbb3V0ZXIsIFsuLi5zdWJjYXRlZ29yaWVzLCBjYXRTdGF0ZV1dXG4gICAgfVxuICAgIHJldHVybiBbb3V0ZXIsIFtjYXRTdGF0ZV1dXG59XG5cbmZ1bmN0aW9uIGFwcGVuZENhdGVnb3J5KHBhcmVudCwgY2hpbGQpIHtcbiAgICBpZiAocGFyZW50Lmxlbmd0aCA9PSAwKSByZXR1cm4gW2NoaWxkXVxuICAgIHJldHVybiBbLi4ucGFyZW50LCBjaGlsZF1cbn1cblxuZnVuY3Rpb24gY29uY2F0Q2F0ZWdvcnkoY2F0ZWdvcnlMaXN0LCBzZXApIHtcbiAgICByZXR1cm4gY2F0ZWdvcnlMaXN0LnJlZHVjZSgoYWNjLCBlKSA9PiB7XG4gICAgICAgIGlmIChhY2MgPT09IFwiXCIpIHJldHVybiBlXG4gICAgICAgIHJldHVybiBhY2MgKyBzZXAgKyBlXG4gICAgfSwgXCJcIilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwbGl0Q2F0ZWdvcnkoY2F0ZWdvcnkpIHtcbiAgICByZXR1cm4gY2F0ZWdvcnkuc3BsaXQoXCJfX1wiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW51bUNhdGVnb3J5TGV2ZWxzKGNhdGVnb3J5UGF0aCkge1xuICAgIHJldHVybiBjYXRlZ29yeVBhdGguc3BsaXQoXCJfX1wiKS5yZWR1Y2UoKGFjYywgZSkgPT4ge1xuICAgICAgICBpZiAoYWNjLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtlXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFsuLi5hY2MsIGFjY1thY2MubGVuZ3RoIC0gMV0gKyBcIl9fXCIgKyBlXVxuICAgICAgICB9XG4gICAgfSwgW11cbiAgICApXG59XG5cbmZ1bmN0aW9uIG1ha2VUb3BMZXZlbCgpIHtcbiAgICAvLyBsZXZlbCA8PSAxXG4gICAgY29uc3QgdGhpc0NhdGVnb3J5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIHRoaXNDYXRlZ29yeS5jbGFzc0xpc3QuYWRkKFwiY2F0ZWdvcnlfZ3JvdXBcIilcbiAgICB0aGlzQ2F0ZWdvcnkuY2xhc3NMaXN0LmFkZChcInN0cmV0Y2hlZFwiKVxuICAgIGNvbnN0IGlubmVyQ2F0ZWdvcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgaW5uZXJDYXRlZ29yeS5jbGFzc0xpc3QuYWRkKFwic3ViX2NhdGVnb3J5XCIpXG4gICAgcmV0dXJuIFt0aGlzQ2F0ZWdvcnksIGlubmVyQ2F0ZWdvcnldXG59XG5cbmZ1bmN0aW9uIG1ha2VNaWRkbGVMZXZlbCgpIHtcbiAgICAvLyBsZXZlbCA+PSAyXG4gICAgLy8gZXguIHJvY2sgPiBpZ25lb3VzIHJvY2sgPiB2b2xjYW5pYyByb2NrXG4gICAgY29uc3QgdGhpc0NhdGVnb3J5ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKVxuICAgIHRoaXNDYXRlZ29yeS5jbGFzc0xpc3QuYWRkKFwic3ViX2NhdGVnb3J5X2dyb3VwXCIpXG4gICAgY29uc3QgaW5uZXJDYXRlZ29yeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICBpbm5lckNhdGVnb3J5LmNsYXNzTGlzdC5hZGQoXCJjb2x1bW4tZGlyZWN0aW9uXCIpXG4gICAgaW5uZXJDYXRlZ29yeS5jbGFzc0xpc3QuYWRkKFwic3ViX2NhdGVnb3J5XCIpXG4gICAgcmV0dXJuIFt0aGlzQ2F0ZWdvcnksIGlubmVyQ2F0ZWdvcnldXG59XG5cbmZ1bmN0aW9uIG1ha2VCb3R0b21MZXZlbCgpIHtcbiAgICAvLyBsZXZlbCA+PSAzXG4gICAgLy8gZXguIHJvY2sgPiBpZ25lb3VzIHJvY2sgPiB2b2xjYW5pYyByb2NrID4gcmh5b2xpdGVcbiAgICBjb25zdCB0aGlzQ2F0ZWdvcnkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpXG4gICAgY29uc3QgaW5uZXJDYXRlZ29yeSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIilcbiAgICByZXR1cm4gW3RoaXNDYXRlZ29yeSwgaW5uZXJDYXRlZ29yeV1cbn1cblxuZnVuY3Rpb24gZmxhdHRlbkNhdGVnb3J5KGNhdGVnb3J5KSB7XG5cbn0iLCJpbXBvcnQgdXBkYXRlU2FtcGxlTGlzdCBmcm9tIFwiLi91c2VjYXNlL3VwZGF0ZV9zYW1wbGVfbGlzdC5qc1wiXG5pbXBvcnQgdXBkYXRlVmlld0Rlc2NyaXB0aW9uIGZyb20gXCIuL3VwZGF0ZVZpZXdEZXNjcmlwdGlvbi5qc1wiXG5pbXBvcnQgeyBjYWNoZVN0b3JhZ2UgfSBmcm9tIFwiLi9jb25maWcvY29uZmlnLmpzXCJcbmltcG9ydCBnZW5lcmF0ZUNhdGVnb3J5U2VsZWN0b3IgZnJvbSBcIi4vY2F0ZWdvcnlfc2VsZWN0b3IvZ2VuZXJhdGVfY2F0ZWdvcnkuanNcIlxuXG5mdW5jdGlvbiBsYW5ndWFnZUNoYW5nZUhhbmRsZXIoc3RhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3QgbGFuZ3VhZ2VTZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbGFuZ3VhZ2Vfc2VsZWN0b3JcIilcbiAgICAgICAgY29uc3QgbGFuZyA9IGxhbmd1YWdlU2VsZWN0b3Iub3B0aW9uc1tsYW5ndWFnZVNlbGVjdG9yLnNlbGVjdGVkSW5kZXhdLnZhbHVlO1xuICAgICAgICBzdGF0ZS51aVN0YXRlLmxhbmd1YWdlID0gbGFuZ1xuICAgICAgICBjYWNoZVN0b3JhZ2UucHV0KFwibGFuZ3VhZ2VcIiwgbGFuZylcbiAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxufVxuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldExhbmd1YWdlU2VsZWN0RXZlbnRIYW5kbGVycyhzdGF0ZSkge1xuICAgIGNvbnN0IGxhbmd1YWdlU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2xhbmd1YWdlX3NlbGVjdG9yXCIpXG5cbiAgICBsYW5ndWFnZVNlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXCJjaGFuZ2VcIixcbiAgICAgICAgYXN5bmMgZSA9PiB7XG4gICAgICAgICAgICBsZXQgbmV3U3RhdGUgPSBsYW5ndWFnZUNoYW5nZUhhbmRsZXIoc3RhdGUpKGUpXG4gICAgICAgICAgICBuZXdTdGF0ZSA9IGF3YWl0IGdlbmVyYXRlQ2F0ZWdvcnlTZWxlY3RvcihcbiAgICAgICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3dyYXBwZXItY2F0ZWdvcnlfc2VsZWN0b3JcIiksXG4gICAgICAgICAgICAgICAgbmV3U3RhdGVcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGNvbnN0IHVpU3RhdGUgPSBuZXdTdGF0ZS51aVN0YXRlXG4gICAgICAgICAgICB1cGRhdGVTYW1wbGVMaXN0KHVpU3RhdGUubGFuZ3VhZ2UsIHVpU3RhdGUuc3RvcmVkS2V5cywgdWlTdGF0ZS5zYW1wbGVGaWx0ZXIpXG4gICAgICAgICAgICB1cGRhdGVWaWV3RGVzY3JpcHRpb24obmV3U3RhdGUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gc2VuZENvbnRhY3RNZXNzYWdlKGUsIG1lc3NhZ2VET00pIHtcblxuICAgIGNvbnN0IGJ1dHRvbiA9IGUudGFyZ2V0XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJwZW5kaW5nXCIpXG5cbiAgICBtZXNzYWdlRE9NLmNsYXNzTGlzdC5hZGQoXCJpbmFjdGl2ZVwiKVxuICAgIG1lc3NhZ2VET00uY2xhc3NMaXN0LnJlbW92ZShcInN1Y2Nlc3NcIilcbiAgICBtZXNzYWdlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJlcnJvclwiKVxuXG4gICAgY29uc3QgZm9ybSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9ybS1jb250YWN0XCIpXG4gICAgY29uc3Qgc2VsZWN0aW9uID0gZm9ybS5xdWVyeVNlbGVjdG9yKFwiI3NlbGVjdC1jb250YWN0X3RvcGljXCIpXG4gICAgY29uc3QgdG9waWMgPSBzZWxlY3Rpb25bc2VsZWN0aW9uLnNlbGVjdGVkSW5kZXhdLnZhbHVlXG4gICAgY29uc3QgbWVzc2FnZSA9IGZvcm0ucXVlcnlTZWxlY3RvcihcInRleHRhcmVhXCIpLnZhbHVlXG4gICAgY29uc3QgZnJvbSA9IGZvcm0ucXVlcnlTZWxlY3RvcihcImlucHV0W3R5cGU9ZW1haWxcIikudmFsdWVcblxuICAgIGlmICh0b3BpYyA9PT0gXCJcIikge1xuICAgICAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcInBlbmRpbmdcIilcbiAgICAgICAgbWVzc2FnZURPTS5pbm5lckhUTUwgPSBcIlNlbGVjdCB0b3BpYyAhXCJcbiAgICAgICAgbWVzc2FnZURPTS5jbGFzc0xpc3QuYWRkKFwiZXJyb3JcIilcbiAgICAgICAgbWVzc2FnZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiaW5hY3RpdmVcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKG1lc3NhZ2UgPT09IHVuZGVmaW5lZCB8fCBtZXNzYWdlID09IFwiXCIpIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJwZW5kaW5nXCIpXG4gICAgICAgIG1lc3NhZ2VET00uaW5uZXJIVE1MID0gXCJXcml0ZSBtZXNzYWdlICFcIlxuICAgICAgICBtZXNzYWdlRE9NLmNsYXNzTGlzdC5hZGQoXCJlcnJvclwiKVxuICAgICAgICBtZXNzYWdlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKVxuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICBjb25zdCBvYmogPSB7XG4gICAgICAgIFwiZnJvbVwiOiBmcm9tLFxuICAgICAgICBcInRpdGxlXCI6IHRvcGljLFxuICAgICAgICBcImJvZHlcIjogbWVzc2FnZVxuICAgIH1cblxuICAgIGNvbnN0IG1ldGhvZCA9IFwiUE9TVFwiO1xuICAgIGNvbnN0IGJvZHkgPSBKU09OLnN0cmluZ2lmeShvYmopO1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICdBY2NlcHQnOiAndGV4dC9wbGFpbixhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbic6ICcqJyxcbiAgICAgICAgJ0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMnOiAnQ29udGVudC1UeXBlLFgtQW16LURhdGUsQXV0aG9yaXphdGlvbixYLUFwaS1LZXksWC1BbXotU2VjdXJpdHktVG9rZW4nLFxuXG4gICAgfTtcblxuICAgIGNvbnNvbGUubG9nKHsgbWV0aG9kLCBoZWFkZXJzLCBib2R5IH0pXG5cbiAgICB0cnkge1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKFwiaHR0cHM6Ly9kZ285NnlodW5pLmV4ZWN1dGUtYXBpLnVzLWVhc3QtMS5hbWF6b25hd3MuY29tL2NvbnRhY3RhcGkvY29udGFjdFwiLCB7IG1ldGhvZCwgaGVhZGVycywgYm9keSwgJ21vZGUnOiAnbm8tY29ycycgfSlcbiAgICAgICAgbWVzc2FnZURPTS5pbm5lckhUTUwgPSBcIlN1Y2Nlc3MuIFRoYW5rIHlvdSBmb3IgY29udHJpYnV0aW5nICFcIlxuICAgICAgICBtZXNzYWdlRE9NLmNsYXNzTGlzdC5hZGQoXCJzdWNjZXNzXCIpXG4gICAgICAgIG1lc3NhZ2VET00uY2xhc3NMaXN0LnJlbW92ZShcImluYWN0aXZlXCIpXG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmxvZyhlKVxuICAgICAgICBtZXNzYWdlRE9NLmlubmVySFRNTCA9IFwiTmV0d29yayBlcnJvciAhXCJcbiAgICAgICAgbWVzc2FnZURPTS5jbGFzc0xpc3QuYWRkKFwiZXJyb3JcIilcbiAgICAgICAgbWVzc2FnZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiaW5hY3RpdmVcIilcbiAgICB9XG4gICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJwZW5kaW5nXCIpXG5cbiAgICByZXR1cm4gZmFsc2Vcbn1cbiIsImltcG9ydCBzZW5kQ29udGFjdE1lc3NhZ2UgZnJvbSBcIi4vc2VuZENvbnRhY3RNZXNzYWdlLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0Q29udGFjdEZvcm1FdmVudEhhbmRsZXJzKHN0YXRlKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb3JtLWNvbnRhY3QgZGl2LmJ1dHRvblwiKS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIGUgPT4gKEFycmF5LmZyb20oZS50YXJnZXQuY2xhc3NMaXN0KS5pbmNsdWRlcyhcInBlbmRpbmdcIikpXG4gICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgIDogc2VuZENvbnRhY3RNZXNzYWdlKFxuICAgICAgICAgICAgICAgIGUsXG4gICAgICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNmb3JtLWNvbnRhY3QgLmZvcm0tbWVzc2FnZVwiKVxuICAgICAgICAgICAgKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYXhWaWV3ZXJTaXplKCkge1xuICAgIGNvbnN0IHRvcEJhclNwYWNlSGVpZ2h0ID0gMjAwIC8vIHB4XG4gICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcEJhclNwYWNlSGVpZ2h0XG4gICAgcmV0dXJuIHdpZHRoIDwgaGVpZ2h0ID8gd2lkdGggOiBoZWlnaHRcbn1cbiIsImltcG9ydCBTYW1wbGVGaWx0ZXIgZnJvbSBcIi4uL3JlbW90ZV9yZXBvL3N0YXRpYy9maWx0ZXJfYnlfY2F0ZWdvcnkuanNcIlxuaW1wb3J0IHsgY2FjaGVTdG9yYWdlIH0gZnJvbSBcIi4uL2NvbmZpZy9jb25maWcuanNcIlxuXG5mdW5jdGlvbiBvdmVycmlkZUxhbmd1YWdlQnlMb2NhbFN0b3JhZ2Uoc3lzdGVtTGFuZ3VhZ2UpIHtcbiAgICBjb25zdCBsYW5nSW5Mb2NhbFN0b3JhZ2UgPSBjYWNoZVN0b3JhZ2UuZ2V0KFwibGFuZ3VhZ2VcIilcbiAgICBjb25zdCBsYW5nID0gKGxhbmdJbkxvY2FsU3RvcmFnZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGxhbmdJbkxvY2FsU3RvcmFnZVxuICAgICAgICA6IHN5c3RlbUxhbmd1YWdlO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25bdmFsdWU9XCIgKyBsYW5nICsgXCJdXCIpLnNlbGVjdGVkID0gdHJ1ZVxuICAgIHJldHVybiBsYW5nXG59XG5cbmZ1bmN0aW9uIGdldFN5c3RlbUxhbmd1YWdlKCkge1xuICAgIGNvbnN0IGNvZGUgPSAod2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXMgJiYgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXNbMF0pIHx8XG4gICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UgfHxcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHxcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5icm93c2VyTGFuZ3VhZ2U7XG5cbiAgICBjb25zdCBsYW5nID0gY29kZS5tYXRjaChcImphXCIpID8gXCJqYVwiIDogXCJlblwiO1xuXG4gICAgcmV0dXJuIGxhbmdcbn1cblxuZXhwb3J0IGNvbnN0IHVpU3RhdGUgPSB7XG4gICAgXCJzYW1wbGVGaWx0ZXJcIjogbmV3IFNhbXBsZUZpbHRlcigpLFxuICAgIFwic3RvcmVkS2V5c1wiOiBbXSxcbiAgICBcImxhbmd1YWdlXCI6IG92ZXJyaWRlTGFuZ3VhZ2VCeUxvY2FsU3RvcmFnZShnZXRTeXN0ZW1MYW5ndWFnZSgpKSxcbn0iLCJpbXBvcnQgZ2V0TWF4Vmlld2VyU2l6ZSBmcm9tIFwiLi4vZ2V0TWF4Vmlld2VyU2l6ZS5qc1wiXG5cbmV4cG9ydCBjb25zdCB2aWV3ZXJTdGF0ZSA9IHtcbiAgICBcImNvbnRhaW5vcklEXCI6IFwiXCIsXG4gICAgXCJpbWFnZU51bWJlclwiOiAxLFxuICAgIFwiY2FudmFzV2lkdGhcIjogZ2V0TWF4Vmlld2VyU2l6ZSgpIDw9IDUwMFxuICAgICAgICA/IGdldE1heFZpZXdlclNpemUoKVxuICAgICAgICA6IDUwMCxcbiAgICBcImNhbnZhc0hlaWdodFwiOiBnZXRNYXhWaWV3ZXJTaXplKCkgPD0gNTAwXG4gICAgICAgID8gZ2V0TWF4Vmlld2VyU2l6ZSgpXG4gICAgICAgIDogNTAwLFxuICAgIFwiaW1hZ2VSYWRpdXNcIjogMCxcbiAgICBcIm9wZW5faW1hZ2Vfc3Jjc1wiOiBbXSxcbiAgICBcIm9wZW5faW1hZ2VzXCI6IFtdLFxuICAgIFwiY3Jvc3NfaW1hZ2Vfc3Jjc1wiOiBbXSxcbiAgICBcImNyb3NzX2ltYWdlc1wiOiBbXSxcbiAgICBcInJvdGF0ZVwiOiAwLFxuICAgIFwicm90YXRlX2F4aXNfdHJhbnNsYXRlXCI6IFtdLFxuICAgIFwiaXNDbG9ja3dpc2VcIjogdHJ1ZSxcbiAgICBcImlzQ3Jvc3NOaWNvbFwiOiBmYWxzZSxcbiAgICBcImRyYXdIYWlyTGluZVwiOiB0cnVlLFxuICAgIFwiY2FuUm90YXRlXCI6IHRydWUsXG59IiwiaW1wb3J0IGdldE1heFZpZXdlclNpemUgZnJvbSBcIi4uL2dldE1heFZpZXdlclNpemUuanNcIlxuaW1wb3J0IHsgdWlTdGF0ZSB9IGZyb20gXCIuL3VpX3N0YXRlLmpzXCJcbmltcG9ydCB7IHZpZXdlclN0YXRlIH0gZnJvbSBcIi4vdmlld2VyX3N0YXRlLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiaXNNb3VzZWRvd25cIjogZmFsc2UsXG4gICAgICAgIFwiZHJhZ19zdGFydFwiOiBbMCwgMF0sXG4gICAgICAgIFwiZHJhZ19lbmRcIjogWzAsIDBdLFxuICAgICAgICBcInVpU3RhdGVcIjogdWlTdGF0ZSxcbiAgICAgICAgLi4udmlld2VyU3RhdGUgLy8gVE9ETyB2aWV3ZXJTdGF0ZSBzaG91bGQgYmUgaW5kZXBlbmRlbnRcbiAgICB9XG59XG4iLCJpbXBvcnQgeyB2aWV3ZXIsIHZpZXdlcl9jdHggfSBmcm9tIFwiLi92aWV3ZXJfY2FudmFzLmpzXCJcbmltcG9ydCBnZXRNYXhWaWV3ZXJTaXplIGZyb20gXCIuL2dldE1heFZpZXdlclNpemUuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGVWaWV3ZXJHZW9tZXRyeShzdGF0ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IDIwIC8vIHB4XG4gICAgICAgIHN0YXRlLmNhbnZhc1dpZHRoID0gZ2V0TWF4Vmlld2VyU2l6ZSgpIC0gcGFkZGluZ1xuICAgICAgICBzdGF0ZS5jYW52YXNIZWlnaHQgPSBnZXRNYXhWaWV3ZXJTaXplKCkgLSBwYWRkaW5nXG5cbiAgICAgICAgdmlld2VyLndpZHRoID0gc3RhdGUuY2FudmFzV2lkdGhcbiAgICAgICAgdmlld2VyLmhlaWdodCA9IHN0YXRlLmNhbnZhc0hlaWdodFxuICAgICAgICB2aWV3ZXJfY3R4LnRyYW5zbGF0ZShzdGF0ZS5jYW52YXNXaWR0aCAqIDAuNSwgc3RhdGUuY2FudmFzSGVpZ2h0ICogMC41KVxuICAgICAgICByZXMoc3RhdGUpXG4gICAgfSlcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGVzNkF2YWlsYWJsZSgpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2YgU3ltYm9sKCkgPT09IFwic3ltYm9sXCIpXG59XG4iLCJleHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV0ZWN0V2VicFN1cHBvcnQoKSB7XG5cbiAgICBjb25zdCB0ZXN0SW1hZ2VTb3VyY2VzID0gW1xuICAgICAgICBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JqSUFBQUJYUlVKUVZsQTRJQ1lBQUFDeUFnQ2RBU29DQUFFQUxtazBtazBpSWlJaUlnQm9TeWdBQmM2emJBQUEvdjU2UUFBQUFBPT1cIixcbiAgICAgICAgXCJkYXRhOmltYWdlL3dlYnA7YmFzZTY0LFVrbEdSaDRBQUFCWFJVSlFWbEE0VEJFQUFBQXZBUUFBQUFmUS8vNzN2LytCaU9oL0FBQT1cIlxuICAgIF1cblxuICAgIGNvbnN0IHRlc3RJbWFnZSA9IChzcmMpID0+IHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHZhciBpbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW1nXCIpXG4gICAgICAgICAgICBpbWcub25lcnJvciA9IGVycm9yID0+IHJlc29sdmUoZmFsc2UpXG4gICAgICAgICAgICBpbWcub25sb2FkID0gKCkgPT4gcmVzb2x2ZSh0cnVlKVxuICAgICAgICAgICAgaW1nLnNyYyA9IHNyY1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIGNvbnN0IHJlc3VsdHMgPSBhd2FpdCBQcm9taXNlLmFsbCh0ZXN0SW1hZ2VTb3VyY2VzLm1hcCh0ZXN0SW1hZ2UpKVxuXG4gICAgcmV0dXJuIHJlc3VsdHMuZXZlcnkocmVzdWx0ID0+ICEhcmVzdWx0KVxufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV0ZWN0SjJrU3VwcG9ydCgpIHtcbiAgICBjb25zdCB0ZXN0SW1hZ2VTb3VyY2VzID0gW1xuICAgICAgICAnZGF0YTppbWFnZS9qcDI7YmFzZTY0LEFBQUFER3BRSUNBTkNvY0tBQUFBRkdaMGVYQnFjRElnQUFBQUFHcHdNaUFBQUFBdGFuQXlhQUFBQUJacGFHUnlBQUFBQkFBQUFBUUFBdzhIQUFBQUFBQVBZMjlzY2dFQUFBQUFBQkFBQUFCcGFuQXlZLzlQLzFFQUx3QUFBQUFBQkFBQUFBUUFBQUFBQUFBQUFBQUFBQVFBQUFBRUFBQUFBQUFBQUFBQUF3OEJBUThCQVE4QkFmOVNBQXdBQUFBQkFRQUVCQUFCLzF3QUJFQ0EvNUFBQ2dBQUFBQUFHQUFCLzVQUC9CQVFGQUJjcjRDQS85az0nXG4gICAgXVxuXG4gICAgY29uc3QgdGVzdEltYWdlID0gKHNyYykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIilcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZXJyb3IgPT4gcmVzb2x2ZShmYWxzZSlcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHRydWUpXG4gICAgICAgICAgICBpbWcuc3JjID0gc3JjXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHRlc3RJbWFnZVNvdXJjZXMubWFwKHRlc3RJbWFnZSkpXG5cbiAgICByZXR1cm4gcmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gISFyZXN1bHQpXG59XG4iLCJpbXBvcnQgeyBkZXRlY3RXZWJwU3VwcG9ydCwgZGV0ZWN0SjJrU3VwcG9ydCB9IGZyb20gXCIuL2RldGVjdF9zdXBwb3J0ZWRfaW1hZ2UuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBnZXRTdXBwb3J0ZWRJbWFnZVR5cGUoKSB7XG4gICAgaWYgKGF3YWl0IGRldGVjdFdlYnBTdXBwb3J0KCkpIHtcbiAgICAgICAgcmV0dXJuIFwid2VicFwiXG4gICAgfVxuICAgIGlmIChhd2FpdCBkZXRlY3RKMmtTdXBwb3J0KCkpIHtcbiAgICAgICAgcmV0dXJuIFwianAyXCJcbiAgICB9XG4gICAgcmV0dXJuIFwianBnXCJcbn1cbiIsImltcG9ydCB7IGRldGVjdFdlYnBTdXBwb3J0LCBkZXRlY3RKMmtTdXBwb3J0IH0gZnJvbSBcIi4vZGV0ZWN0X3N1cHBvcnRlZF9pbWFnZS5qc1wiXG5pbXBvcnQgZ2V0U3VwcG9ydGVkSW1hZ2VUeXBlIGZyb20gXCIuL2dldFN1cHBvcnRlZEltYWdlVHlwZS5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNoZWNrU3VwcG9ydGVkSW1hZ2VGb3JtYXQoc3RhdGUpIHtcbiAgICBzdGF0ZS5zdXBwb3J0V2VicCA9IGF3YWl0IGRldGVjdFdlYnBTdXBwb3J0KCk7XG4gICAgc3RhdGUuc3VwcG9ydEoyayA9IGF3YWl0IGRldGVjdEoya1N1cHBvcnQoKTtcbiAgICBzdGF0ZS5zdXBwb3J0ZWRJbWFnZVR5cGUgPSBhd2FpdCBnZXRTdXBwb3J0ZWRJbWFnZVR5cGUoKTtcbiAgICByZXR1cm4gc3RhdGVcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIERhdGFiYXNlSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoZGJfbmFtZSwgdmVyc2lvbiwgc3RvcmVOYW1lLCBwcmltYXJ5S2V5TmFtZSkge1xuICAgICAgICB0aGlzLmRiID0gd2luZG93LmluZGV4ZWREQjtcbiAgICAgICAgdGhpcy5kYl9uYW1lID0gZGJfbmFtZTtcbiAgICAgICAgdGhpcy5kYl92ZXJzaW9uID0gdmVyc2lvbjtcbiAgICAgICAgdGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XG4gICAgICAgIHRoaXMucHJpbWFyeUtleSA9IHByaW1hcnlLZXlOYW1lO1xuICAgIH1cblxuICAgIHNjaGVtZURlZihkYikge1xuICAgICAgICBkYi5jcmVhdGVPYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSwgeyBrZXlQYXRoOiB0aGlzLnByaW1hcnlLZXksIGF1dG9JbmNyZW1lbnQ6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgY29uc3QgZGJwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVxID0gdGhpcy5kYi5vcGVuKHRoaXMuZGJfbmFtZSwgdGhpcy5kYl92ZXJzaW9uKTtcbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBldiA9PiByZXNvbHZlKGV2LnRhcmdldC5yZXN1bHQpO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSBldiA9PiByZWplY3QoJ2ZhaWxzIHRvIG9wZW4gZGInKTtcbiAgICAgICAgICAgIHJlcS5vbnVwZ3JhZGVuZWVkZWQgPSBldiA9PiB0aGlzLnNjaGVtZURlZihldi50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGRicC50aGVuKGQgPT4gZC5vbmVycm9yID0gZXYgPT4gYWxlcnQoXCJlcnJvcjogXCIgKyBldi50YXJnZXQuZXJyb3JDb2RlKSk7XG4gICAgICAgIHJldHVybiBkYnA7XG4gICAgfVxuXG4gICAgYXN5bmMgcHV0KGRiLCBvYmopIHsgLy8gcmV0dXJucyBvYmogaW4gSURCXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2NzID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSwgJ3JlYWR3cml0ZScpLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGRvY3MucHV0KG9iaik7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShPYmplY3QuYXNzaWduKHsgW3RoaXMucHJpbWFyeUtleV06IHJlcS5yZXN1bHQgfSwgb2JqKSk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0KGRiLCBpZCkgeyAvLyBOT1RFOiBpZiBub3QgZm91bmQsIHJlc29sdmVzIHdpdGggdW5kZWZpbmVkLlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jcyA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZSxdKS5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBkb2NzLmdldChpZCk7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShyZXEucmVzdWx0KTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBkZWxldGUoZGIsIGlkKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkb2NzID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lLF0sICdyZWFkd3JpdGUnKVxuICAgICAgICAgICAgICAgIC5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBkb2NzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gKCkgPT4gcmVzb2x2ZShpZCk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBhc3luYyBsb2FkQWxsS2V5KGRiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBzYXZlcyA9IFtdO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gSURCS2V5UmFuZ2UubG93ZXJCb3VuZCgwKTtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0pLm9iamVjdFN0b3JlKHRoaXMuc3RvcmVOYW1lKS5vcGVuQ3Vyc29yKHJhbmdlKTtcbiAgICAgICAgICAgIHJlcS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXN1bHQgPSBlLnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgLy8g5rOo77yJ6LWw5p+744GZ44G544GNT2JqZWN044GM44GT44KM5Lul5LiK54Sh44GE5aC05ZCIXG4gICAgICAgICAgICAgICAgLy8gICAgIHJlc3VsdCA9PSBudWxsIOOBqOOBquOCiuOBvuOBme+8gVxuICAgICAgICAgICAgICAgIGlmICghIXJlc3VsdCA9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHNhdmVzKVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIOOBk+OBk+OBq3ZhbHVl44GM44GP44KL77yBXG4gICAgICAgICAgICAgICAgICAgIHNhdmVzLnB1c2gocmVzdWx0LmtleSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIOOCq+ODvOOCveODq+OCkuS4gOWAi+OBmuOCieOBmVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuY29udGludWUoKTtcbiAgICAgICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBnZXRBbGxLZXlzKGRiKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciByZXEgPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdKS5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSlcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShbXSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHJlcS5nZXRBbGxLZXlzKSB7XG4gICAgICAgICAgICAgICAgcmVxLmdldEFsbEtleXMoKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgcm93cyA9IGV2ZW50LnRhcmdldC5yZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocm93cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyaWVzID0gYXdhaXQgdGhpcy5sb2FkQWxsS2V5KGRiKVxuICAgICAgICAgICAgICAgIHJlc29sdmUoZW50cmllcylcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gcmVqZWN0XG4gICAgICAgIH0pXG4gICAgfVxufVxuIiwiaW1wb3J0IERhdGFiYXNlSGFuZGxlciBmcm9tIFwiLi9EYXRhYmFzZUhhbmRsZXIuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEdW1teURhdGFiYXNlSGFuZGxlciBleHRlbmRzIERhdGFiYXNlSGFuZGxlciB7XG4gICAgY29uc3RydWN0b3IoZGJfbmFtZSwgdmVyc2lvbiwgc3RvcmVOYW1lLCBwcmltYXJ5S2V5TmFtZSkge1xuICAgICAgICBjb25zb2xlLndhcm4oXCJJbmRleGVkREIgaXMgbm90IGF2YWlsYWJsZSAhXCIpXG4gICAgICAgIHN1cGVyKGRiX25hbWUsIHZlcnNpb24sIHN0b3JlTmFtZSwgcHJpbWFyeUtleU5hbWUpXG4gICAgICAgIHRoaXMuc3RvcmFnZSA9IHt9XG4gICAgfVxuXG4gICAgY29ubmVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHt9XG4gICAgfVxuXG4gICAgcHV0KGRiLCBvYmopIHtcbiAgICAgICAgaWYgKGRiLmhhc093blByb3BlcnR5KG9ialt0aGlzLnByaW1hcnlLZXldKSkge1xuICAgICAgICAgICAgdmFyIG9sZCA9IGRiW29ialt0aGlzLnByaW1hcnlLZXldXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIG9sZCA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV3X2VudHJ5ID0gT2JqZWN0LmFzc2lnbihvbGQsIG9iailcbiAgICAgICAgZGJbb2JqW3RoaXMucHJpbWFyeUtleV1dID0gbmV3X2VudHJ5O1xuICAgICAgICByZXR1cm4geyBbb2JqW3RoaXMucHJpbWFyeUtleV1dOiBuZXdfZW50cnkgfVxuICAgIH1cblxuICAgIGdldChkYiwgaWQpIHtcbiAgICAgICAgaWYgKGRiLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgcmV0dXJuIGRiW2lkXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVsZXRlKGRiLCBpZCkge1xuICAgICAgICBpZiAoZGIuaGFzT3duUHJvcGVydHkoaWQpKSB7XG4gICAgICAgICAgICBkYltpZF0gPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuIGlkXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkQWxsKGRiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QuZW50cmllcyhkYilcbiAgICB9XG5cbiAgICBnZXRBbGxLZXlzKGRiKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyhkYilcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBzdGF0aWNTZXR0aW5ncyB9IGZyb20gXCIuL2NvbmZpZy9jb25maWcuanNcIlxuaW1wb3J0IERhdGFiYXNlSGFuZGxlciBmcm9tIFwiLi9EYXRhYmFzZUhhbmRsZXIuanNcIlxuaW1wb3J0IER1bW15RGF0YWJhc2VIYW5kbGVyIGZyb20gXCIuL0R1bW15RGF0YWJhc2VIYW5kbGVyLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY29ubmVjdERhdGFiYXNlKHN0YXRlKSB7XG4gICAgc3RhdGUuemlwREJIYW5kbGVyID0gKHdpbmRvdy5pbmRleGVkREIpXG4gICAgICAgID8gKCFuYXZpZ2F0b3IudXNlckFnZW50Lm1hdGNoKFwiRWRnZVwiKSlcbiAgICAgICAgICAgID8gbmV3IERhdGFiYXNlSGFuZGxlcihzdGF0aWNTZXR0aW5ncy5nZXREQk5hbWUoKSwgMiwgc3RhdGljU2V0dGluZ3MuZ2V0U3RvcmFnZU5hbWUoKSwgXCJpZFwiKVxuICAgICAgICAgICAgOiBuZXcgRGF0YWJhc2VIYW5kbGVyKHN0YXRpY1NldHRpbmdzLmdldERCTmFtZSgpLCAxLCBzdGF0aWNTZXR0aW5ncy5nZXRTdG9yYWdlTmFtZSgpLCBcImlkXCIpXG4gICAgICAgIDogbmV3IER1bW15RGF0YWJhc2VIYW5kbGVyKHN0YXRpY1NldHRpbmdzLmdldERCTmFtZSgpLCAyLCBzdGF0aWNTZXR0aW5ncy5nZXRTdG9yYWdlTmFtZSgpLCBcImlkXCIpXG4gICAgc3RhdGUuemlwREIgPSBhd2FpdCBzdGF0ZS56aXBEQkhhbmRsZXIuY29ubmVjdCgpXG4gICAgcmV0dXJuIHN0YXRlXG59O1xuIiwiZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZ2V0U3RvcmVkREJFbnRyeUtleXMoc3RhdGUpIHtcbiAgICBzdGF0ZS51aVN0YXRlLnN0b3JlZEtleXMgPSBhd2FpdCBzdGF0ZS56aXBEQkhhbmRsZXIuZ2V0QWxsS2V5cyhzdGF0ZS56aXBEQilcbiAgICByZXR1cm4gc3RhdGVcbn1cbiIsImltcG9ydCB7IGhpZGVFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi9lcnJvcl9pbmRpY2F0b3JfaGFuZGxlci5qc1wiXG5pbXBvcnQgeyBzaG93TG9hZGluZ01lc3NhZ2UgfSBmcm9tIFwiLi9sb2FkaW5nX2luZGljYXRvcl9oYW5kbGVyLmpzXCJcbmltcG9ydCB7IGhpZGVXZWxjb21lQm9hcmQsIHNob3dWaWV3ZXIsIHNob3dOaWNvbEJ1dHRvbiB9IGZyb20gXCIuL3ZpZXdlcl9oYW5kbGVycy5qc1wiXG5pbXBvcnQgcXVlcnlJbWFnZVBhY2thZ2UgZnJvbSBcIi4vcXVlcnlJbWFnZVBhY2thZ2UuanNcIlxuaW1wb3J0IHVwZGF0ZVN0YXRlQnlNZXRhIGZyb20gXCIuL3VwZGF0ZVN0YXRlQnlNZXRhLmpzXCJcbmltcG9ydCB1cGRhdGVWaWV3RGVzY3JpcHRpb24gZnJvbSBcIi4vdXBkYXRlVmlld0Rlc2NyaXB0aW9uLmpzXCJcbmltcG9ydCB1cGRhdGVJbWFnZVNyYyBmcm9tIFwiLi91cGRhdGVJbWFnZVNyYy5qc1wiXG5pbXBvcnQgcmVnaXN0ZXIgZnJvbSBcIi4vcmVnaXN0ZXIuanNcIlxuaW1wb3J0IG1hcmtEb3dubG9hZGVkT3B0aW9uIGZyb20gXCIuL21hcmtEb3dubG9hZGVkT3B0aW9uLmpzXCJcbmltcG9ydCB1cGRhdGVWaWV3IGZyb20gXCIuL3VwZGF0ZVZpZXcuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBmZXRjaFBhY2thZ2VCeUlkKHN0YXRlLCBwYWNrYWdlSUQpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlcywgcmVqKSA9PiB7XG5cbiAgICAgICAgc3RhdGUuY2FuUm90YXRlID0gZmFsc2U7XG4gICAgICAgIGhpZGVFcnJvck1lc3NhZ2UoKVxuICAgICAgICBzaG93TG9hZGluZ01lc3NhZ2UoKVxuICAgICAgICBoaWRlV2VsY29tZUJvYXJkKClcbiAgICAgICAgc2hvd1ZpZXdlcigpXG4gICAgICAgIHNob3dOaWNvbEJ1dHRvbigpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtyZXNwb25zZSwgaXNOZXdEYXRhXSA9IGF3YWl0IHF1ZXJ5SW1hZ2VQYWNrYWdlKHN0YXRlLCBwYWNrYWdlSUQpO1xuICAgICAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKHJlc3BvbnNlLm1hbmlmZXN0KTtcblxuICAgICAgICAgICAgY29uc3QgbmV3X3N0YXRlID0gYXdhaXQgdXBkYXRlU3RhdGVCeU1ldGEoc3RhdGUpKHBhY2thZ2VJRCwgbWFuaWZlc3QpXG4gICAgICAgICAgICAgICAgLnRoZW4odXBkYXRlVmlld0Rlc2NyaXB0aW9uKVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZUltYWdlU3JjKHJlc3BvbnNlLnRodW1ibmFpbCwgXCJqcGdcIikpXG4gICAgICAgICAgICAgICAgLnRoZW4odXBkYXRlVmlldylcblxuICAgICAgICAgICAgbmV3X3N0YXRlLmNhblJvdGF0ZSA9IHRydWVcblxuICAgICAgICAgICAgaWYgKGlzTmV3RGF0YSkge1xuICAgICAgICAgICAgICAgIHJlc3BvbnNlLnppcCA9IGF3YWl0IHJlc3BvbnNlLnppcCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHVwZGF0ZUltYWdlU3JjKHJlc3BvbnNlLnppcCwgcmVzcG9uc2UuaW1hZ2VfZm9ybWF0KShuZXdfc3RhdGUpXG4gICAgICAgICAgICAgICAgLnRoZW4oc3RhdGUgPT4gcmVnaXN0ZXIoc3RhdGUsIGlzTmV3RGF0YSkocmVzcG9uc2UpKVxuICAgICAgICAgICAgICAgIC50aGVuKG1hcmtEb3dubG9hZGVkT3B0aW9uKHBhY2thZ2VJRCkobWFuaWZlc3QpKVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWooZSlcbiAgICAgICAgfVxuICAgIH0pXG59IiwiXG5pbXBvcnQgdXBkYXRlU2FtcGxlTGlzdCBmcm9tIFwiLi4vdXNlY2FzZS91cGRhdGVfc2FtcGxlX2xpc3QuanNcIlxuaW1wb3J0IHsgc3BsaXRDYXRlZ29yeSB9IGZyb20gXCIuL2dlbmVyYXRlX2NhdGVnb3J5LmpzXCJcblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG11c3QgYmUgY2FsbGVkIGFmdGVyIGVsZW1lbnQgaW4gdGhlXG4gKiAgIG1vZGFsIHdpbmRvdyBhcmUgcmVnaXN0ZXJlZC5cbiAqXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBtb2RhbFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2F0ZWdvcnlTZWxlY3RvclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gdG9nZ2xlX21vZGFsX2J1dHRvblxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2xvc2VfbW9kYWxfYnV0dG9uXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldEV2ZW50SGFuZGxlcnMoXG4gICAgbW9kYWwsXG4gICAgdG9nZ2xlTW9kYWxCdXR0b24sXG4gICAgY2xvc2VNb2RhbEJ1dHRvbixcbiAgICBzdGF0ZVxuKSB7XG4gICAgW1xuICAgICAgICAuLi5tb2RhbC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXQuc3VwZXJfY2F0ZWdvcnktY2hlY2tib3hcIilcbiAgICBdLmZvckVhY2goKGNhdCwgXywpID0+IHtcbiAgICAgICAgY2F0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZiA9IGUudGFyZ2V0XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBbLi4uc2VsZi5jbGFzc0xpc3RdLnNsaWNlKDEpXG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlDbGFzcyA9IGNvbmNhdENhdGVnb3J5KHF1ZXJ5LCBcIi5cIilcbiAgICAgICAgICAgICAgICBjb25zdCB1aVN0YXRlID0gc3RhdGUudWlTdGF0ZVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB1aVN0YXRlLnNhbXBsZUZpbHRlci5hZGQocXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxhYmVsLlwiICsgcXVlcnlDbGFzcyldLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5hZGQoXCJhY3RpdmVcIilcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB1aVN0YXRlLnNhbXBsZUZpbHRlci5yZW1vdmUocXVlcnkpO1xuICAgICAgICAgICAgICAgICAgICBbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcImxhYmVsLlwiICsgcXVlcnlDbGFzcyldLmZvckVhY2goZWxlbSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbGVtLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIilcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2codWlTdGF0ZS5zYW1wbGVGaWx0ZXIubGlzdCgpKVxuICAgICAgICAgICAgICAgIHVwZGF0ZVNhbXBsZUxpc3QodWlTdGF0ZS5sYW5ndWFnZSwgdWlTdGF0ZS5zdG9yZWRLZXlzLCB1aVN0YXRlLnNhbXBsZUZpbHRlcilcbiAgICAgICAgICAgIH1cbiAgICAgICAgKVxuICAgIH0pO1xuXG4gICAgW1xuICAgICAgICAuLi5tb2RhbC5xdWVyeVNlbGVjdG9yQWxsKFwiaW5wdXQuY2F0ZWdvcnktY2hlY2tib3hcIilcbiAgICBdLmZvckVhY2goKGNhdCwgXywpID0+IHtcbiAgICAgICAgY2F0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VsZiA9IGUudGFyZ2V0XG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnkgPSBbLi4uc2VsZi5jbGFzc0xpc3RdLnNsaWNlKDEpXG4gICAgICAgICAgICAgICAgY29uc3QgcXVlcnlDbGFzcyA9IGNvbmNhdENhdGVnb3J5KHF1ZXJ5LCBcIi5cIilcbiAgICAgICAgICAgICAgICBjb25zdCB1aVN0YXRlID0gc3RhdGUudWlTdGF0ZVxuXG4gICAgICAgICAgICAgICAgaWYgKHNlbGYuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB1aVN0YXRlLnNhbXBsZUZpbHRlci5hZGQocXVlcnkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHVpU3RhdGUuc2FtcGxlRmlsdGVyLnJlbW92ZShxdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHVpU3RhdGUuc2FtcGxlRmlsdGVyLmxpc3QoKSlcbiAgICAgICAgICAgICAgICB1cGRhdGVTYW1wbGVMaXN0KHVpU3RhdGUubGFuZ3VhZ2UsIHVpU3RhdGUuc3RvcmVkS2V5cywgdWlTdGF0ZS5zYW1wbGVGaWx0ZXIpXG4gICAgICAgICAgICB9XG4gICAgICAgIClcbiAgICB9KTtcblxuXG4gICAgdG9nZ2xlTW9kYWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBpZiAoZS50YXJnZXQuY2hlY2tlZCkge1xuICAgICAgICAgICAgICAgIHNob3cobW9kYWwpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGhpZGUobW9kYWwpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgY2xvc2VNb2RhbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgaGlkZShtb2RhbClcbiAgICAgICAgICAgIHRvZ2dsZU1vZGFsQnV0dG9uLmNoZWNrZWQgPSBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcbn1cblxuZnVuY3Rpb24gaXNTdWJzZXQoc2V0LCBzdXBlcnNldCkge1xuICAgIGlmIChzZXQuc2l6ZSA9PSAwKSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIGZvciAobGV0IGVsZW0gb2Ygc2V0KSB7XG4gICAgICAgIGlmICghc3VwZXJzZXQuaGFzKGVsZW0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGNvbmNhdENhdGVnb3J5KGNhdGVnb3J5TGlzdCwgc2VwKSB7XG4gICAgcmV0dXJuIGNhdGVnb3J5TGlzdC5yZWR1Y2UoKGFjYywgZSkgPT4ge1xuICAgICAgICBpZiAoYWNjID09PSBcIlwiKSByZXR1cm4gZVxuICAgICAgICByZXR1cm4gYWNjICsgc2VwICsgZVxuICAgIH0sIFwiXCIpXG59XG5cbmZ1bmN0aW9uIHNob3coZWxlbSkge1xuICAgIGVsZW0uY2xhc3NMaXN0LnJlbW92ZShcImluYWN0aXZlXCIpXG59XG5cbmZ1bmN0aW9uIGhpZGUoZWxlbSkge1xuICAgIGVsZW0uY2xhc3NMaXN0LmFkZChcImluYWN0aXZlXCIpXG59XG4iLCIvKipcbiAqICBMYW5ndWFnZSBjb2RlIG9mIHNhbXBsZSBsaXN0IGlzIHN1Y2ggYXMgXCJqYVwiIG9yIFwiZW5cIi5cbiAqL1xuaW1wb3J0IGRlbGV0ZU9sZFZlcnNpb25EYXRhYmFzZSBmcm9tIFwiLi9kZWxldGVPbGRWZXJzaW9uRGF0YWJhc2UuanNcIlxuaW1wb3J0IHNldFRvZ2dsZU5pY29sRXZlbnRzIGZyb20gXCIuL3NldFRvZ2dsZU5pY29sRXZlbnRzLmpzXCJcbmltcG9ydCBzZXRSb2NrU2VsZWN0RXZlbnRIYW5kbGVycyBmcm9tIFwiLi9zZXRSb2NrU2VsZWN0RXZlbnRIYW5kbGVycy5qc1wiXG5pbXBvcnQgc2V0Q2FudmFzRXZlbnRIYW5kbGVycyBmcm9tIFwiLi9zZXRDYW52YXNFdmVudEhhbmRsZXJzLmpzXCJcbmltcG9ydCBzZXRMYW5ndWFnZVNlbGVjdEV2ZW50SGFuZGxlcnMgZnJvbSBcIi4vc2V0TGFuZ3VhZ2VTZWxlY3RFdmVudEhhbmRsZXJzLmpzXCJcbmltcG9ydCBzZXRDb250YWN0Rm9ybUV2ZW50SGFuZGxlcnMgZnJvbSBcIi4vc2V0Q29udGFjdEZvcm1FdmVudEhhbmRsZXJzLmpzXCJcbmltcG9ydCBpbml0U3RhdGUgZnJvbSBcIi4vc3RhdGUvaW5pdFN0YXRlLmpzXCJcbmltcG9ydCB1cGRhdGVWaWV3ZXJHZW9tZXRyeSBmcm9tIFwiLi91cGRhdGVWaWV3ZXJHZW9tZXRyeS5qc1wiXG5pbXBvcnQgdXBkYXRlVmlldyBmcm9tIFwiLi91cGRhdGVWaWV3LmpzXCJcbmltcG9ydCBlczZBdmFpbGFibGUgZnJvbSBcIi4vZXM2QXZhaWxhYmxlLmpzXCJcbmltcG9ydCBjaGVja1N1cHBvcnRlZEltYWdlRm9ybWF0IGZyb20gXCIuL2NoZWNrU3VwcG9ydGVkSW1hZ2VGb3JtYXQuanNcIlxuaW1wb3J0IGNvbm5lY3REYXRhYmFzZSBmcm9tIFwiLi9jb25uZWN0RGF0YWJhc2UuanNcIlxuaW1wb3J0IGdldFN0b3JlZERCRW50cnlLZXlzIGZyb20gXCIuL2dldFN0b3JlZERCRW50cnlLZXlzLmpzXCJcbmltcG9ydCB7IGhpZGVMb2FkaW5nTWVzc2FnZSB9IGZyb20gXCIuL2xvYWRpbmdfaW5kaWNhdG9yX2hhbmRsZXIuanNcIlxuaW1wb3J0IGZldGNoUGFja2FnZUJ5SWQgZnJvbSBcIi4vZmV0Y2hfcGFja2FnZV9ieV9xdWVyeS5qc1wiXG5pbXBvcnQgeyBzaG93RXJyb3JNZXNzYWdlIH0gZnJvbSBcIi4vZXJyb3JfaW5kaWNhdG9yX2hhbmRsZXIuanNcIlxuaW1wb3J0IHVwZGF0ZVNhbXBsZUxpc3QgZnJvbSBcIi4vdXNlY2FzZS91cGRhdGVfc2FtcGxlX2xpc3QuanNcIlxuaW1wb3J0IHNldENhdGVnb3J5U2VsZWN0b3JFdmVudEhhbmRsZXJzIGZyb20gXCIuL2NhdGVnb3J5X3NlbGVjdG9yL3VpX2V2ZW50X2hhbmRsZXIuanNcIlxuaW1wb3J0IGdlbmVyYXRlQ2F0ZWdvcnlTZWxlY3RvciBmcm9tIFwiLi9jYXRlZ29yeV9zZWxlY3Rvci9nZW5lcmF0ZV9jYXRlZ29yeS5qc1wiXG5cbmRlbGV0ZU9sZFZlcnNpb25EYXRhYmFzZSgpXG5cblxuXG5cbmZ1bmN0aW9uIGhhbmRsZUVycm9ycyhyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5vaykge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuXG4gICAgc3dpdGNoIChyZXNwb25zZS5zdGF0dXMpIHtcbiAgICAgICAgY2FzZSA0MDA6IHRocm93IG5ldyBFcnJvcignSU5WQUxJRF9UT0tFTicpO1xuICAgICAgICBjYXNlIDQwMTogdGhyb3cgbmV3IEVycm9yKCdVTkFVVEhPUklaRUQnKTtcbiAgICAgICAgY2FzZSA1MDA6IHRocm93IG5ldyBFcnJvcignSU5URVJOQUxfU0VSVkVSX0VSUk9SJyk7XG4gICAgICAgIGNhc2UgNTAyOiB0aHJvdyBuZXcgRXJyb3IoJ0JBRF9HQVRFV0FZJyk7XG4gICAgICAgIGNhc2UgNDA0OiB0aHJvdyBuZXcgRXJyb3IoJ05PVF9GT1VORCcpO1xuICAgICAgICBkZWZhdWx0OiB0aHJvdyBuZXcgRXJyb3IoJ1VOSEFORExFRF9FUlJPUicpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaXNNb2JpbGVFbnYodXNlckFnZW50KSB7XG4gICAgcmV0dXJuICh1c2VyQWdlbnQuaW5kZXhPZihcImlQaG9uZVwiKSA+PSAwIHx8IHVzZXJBZ2VudC5pbmRleE9mKFwiaVBhZFwiKSA+PSAwIHx8IHVzZXJBZ2VudC5pbmRleE9mKFwiQW5kcm9pZFwiKSA+PSAwKVxufVxuXG5mdW5jdGlvbiBub3RpZnlJbmNvbXBhdGlibGVFbnYoKSB7XG4gICAgdmFyIHdhcm5uaW5nQ2FyZCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicGxlYXNlX3VzZV9tb2Rlcm5fYnJvd3NlclwiKVxuICAgIHdhcm5uaW5nQ2FyZC5jbGFzc0xpc3QucmVtb3ZlKFwiaW5hY3RpdmVcIilcbn1cblxuY29uc3QgZ2V0X3BhY2thZ2VfaWQgPSAoKSA9PiB7XG4gICAgY29uc3QgaGFzaCA9IGxvY2F0aW9uLmhhc2guc2xpY2UoMSlcbiAgICByZXR1cm4gaGFzaCA9PT0gXCJcIiA/IHVuZGVmaW5lZCA6IGhhc2hcbn1cblxuLyoqXG4gICAgKlxuICAgICogRW50cnkgcG9pbnQgZnVuY3Rpb24gIVxuICAgICovXG5mdW5jdGlvbiBpbml0KHN0YXRlKSB7XG4gICAgLy8gQ2hlY2sgRVM2IGF2YWlsYWJpbGl0eVxuICAgIC8vIFNldCB3aW5kb3cgZXZlbnQgbGlzdGVuZXJcbiAgICAvL1xuICAgIGlmICghZXM2QXZhaWxhYmxlKSB7XG4gICAgICAgIG5vdGlmeUluY29tcGF0aWJsZUVudigpXG4gICAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIOOCueODnuODvOODiOODleOCqeODs+OBruWgtOWQiOOBr29yaWVudGF0aW9uY2hhbmdl44Kk44OZ44Oz44OI44KS55uj6KaW44GZ44KLXG4gICAgaWYgKGlzTW9iaWxlRW52KG5hdmlnYXRvci51c2VyQWdlbnQpKVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwib3JpZW50YXRpb25jaGFuZ2VcIixcbiAgICAgICAgICAgIGUgPT4gdXBkYXRlVmlld2VyR2VvbWV0cnkoc3RhdGUpLnRoZW4odXBkYXRlVmlldyksXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuXG5cbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJyZXNpemVcIixcbiAgICAgICAgZSA9PiB1cGRhdGVWaWV3ZXJHZW9tZXRyeShzdGF0ZSkudGhlbih1cGRhdGVWaWV3KSxcbiAgICAgICAgZmFsc2VcbiAgICApO1xuXG4gICAgZnVuY3Rpb24gdGVlKGYpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgZih2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyogU2V0IGV2ZW50IGxpc3RlbmVyIGZvciBjYXRlZ29yeSBzZWxlY3RvciAqL1xuICAgIGdlbmVyYXRlQ2F0ZWdvcnlTZWxlY3RvcihcbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN3cmFwcGVyLWNhdGVnb3J5X3NlbGVjdG9yXCIpLFxuICAgICAgICBzdGF0ZVxuICAgICkudGhlbihfID0+IHtcbiAgICAgICAgc2V0Q2F0ZWdvcnlTZWxlY3RvckV2ZW50SGFuZGxlcnMoXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21vZGFsLWNhdGVnb3J5X3NlbGVjdG9yXCIpLFxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0b2dnbGVfY2F0ZWdvcnlcIiksXG4gICAgICAgICAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2J1dHRvbi1jbG9zZS1jYXRlZ29yeV9zZWxlY3RvclwiKSxcbiAgICAgICAgICAgIHN0YXRlXG4gICAgICAgIClcbiAgICB9KVxuXG4gICAgdXBkYXRlVmlld2VyR2VvbWV0cnkoc3RhdGUpXG4gICAgICAgIC50aGVuKGNoZWNrU3VwcG9ydGVkSW1hZ2VGb3JtYXQpXG4gICAgICAgIC50aGVuKGNvbm5lY3REYXRhYmFzZSlcbiAgICAgICAgLnRoZW4oZ2V0U3RvcmVkREJFbnRyeUtleXMpXG4gICAgICAgIC50aGVuKHRlZShfID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVpU3RhdGUgPSBzdGF0ZS51aVN0YXRlXG4gICAgICAgICAgICB1cGRhdGVTYW1wbGVMaXN0KHVpU3RhdGUubGFuZ3VhZ2UsIHVpU3RhdGUuc3RvcmVkS2V5cywgdWlTdGF0ZS5zYW1wbGVGaWx0ZXIpXG4gICAgICAgIH0pKVxuICAgICAgICAudGhlbihzdGF0ZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwYWNrYWdlSUQgPSBnZXRfcGFja2FnZV9pZCgpXG4gICAgICAgICAgICBpZiAocGFja2FnZUlEKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2cocGFja2FnZUlEKVxuICAgICAgICAgICAgICAgIHJldHVybiBmZXRjaFBhY2thZ2VCeUlkKHN0YXRlLCBwYWNrYWdlSUQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBzdGF0ZVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgICAudGhlbihoaWRlTG9hZGluZ01lc3NhZ2UpXG4gICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZSlcbiAgICAgICAgICAgIHNob3dFcnJvck1lc3NhZ2UoXCI8cD5JbnRlcm5ldCBkaXNjb25uZWN0ZWQuPC9wPlwiKSgpXG4gICAgICAgICAgICBoaWRlTG9hZGluZ01lc3NhZ2UoZSk7XG4gICAgICAgIH0pXG5cblxuICAgIHNldFRvZ2dsZU5pY29sRXZlbnRzKHN0YXRlKVxuICAgIHNldFJvY2tTZWxlY3RFdmVudEhhbmRsZXJzKHN0YXRlKVxuICAgIHNldENhbnZhc0V2ZW50SGFuZGxlcnMoc3RhdGUpXG4gICAgc2V0TGFuZ3VhZ2VTZWxlY3RFdmVudEhhbmRsZXJzKHN0YXRlKVxuICAgIHNldENvbnRhY3RGb3JtRXZlbnRIYW5kbGVycyhzdGF0ZSlcblxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBcIkRPTWNvbnRlbnRsb2FkZWRcIixcbiAgICBpbml0KGluaXRTdGF0ZSgpKSxcbiAgICBmYWxzZVxuKVxuIl0sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3REQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3ZCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEJBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOURBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTs7O0FDSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTsiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///0\n')}]);