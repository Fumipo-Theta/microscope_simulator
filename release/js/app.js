!function(g){var I={};function n(t){if(I[t])return I[t].exports;var e=I[t]={i:t,l:!1,exports:{}};return g[t].call(e.exports,e,e.exports,n),e.l=!0,e.exports}n.m=g,n.c=I,n.d=function(g,I,t){n.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:t})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,I){if(1&I&&(g=n(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var e in g)n.d(t,e,function(I){return g[I]}.bind(null,e));return t},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/deleteOldVersionDatabase.js\n// This should be method of DB handler class\nfunction deleteOldVersionDatabase() {\n    indexedDB.deleteDatabase("db_v2");\n    indexedDB.deleteDatabase("zipfiles");\n}\n\n// CONCATENATED MODULE: ./src/js/clipGeometryFromImageCenter.js\nfunction clipGeometoryFromImageCenter(state) {\n\n    return [\n        state.rotate_center.to_right - state.imageRadius,\n        state.rotate_center.to_bottom - state.imageRadius,\n        state.imageRadius * 2,\n        state.imageRadius * 2\n    ]\n}\n\n// CONCATENATED MODULE: ./src/js/viewer_canvas.js\nconst viewer = document.querySelector("#main-viewer")\nconst viewer_ctx = viewer.getContext("2d")\n\n// CONCATENATED MODULE: ./src/js/StaticManager.js\nclass StaticManager {\n    constructor(\n        sampleListURL,\n        imageDataPathPrefix,\n        dbName,\n        storageName\n    ) {\n        this.sampleListURL = sampleListURL\n        this.imageDataRoot = imageDataPathPrefix\n        this.indexedDBName = dbName\n        this.storageName = storageName\n    }\n\n    getSampleListURL() {\n        return this.sampleListURL\n    }\n\n    getImageDataPath(packageName) {\n        return this.imageDataRoot + packageName + "/"\n    }\n\n    getDBName() {\n        return this.indexedDBName;\n    }\n\n    getStorageName() {\n        return this.storageName\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/config/config.js\n\n\n/**\n * TODO split these config as different objects\n *\n * - Package list endpoint\n * - Package CDN endpoint\n * - Cache DB version name\n * - Cache DB table name\n */\n\nconst compileEnv = "production"\n\nconsole.info("config.js: compileEnv: ", compileEnv)\n\nconst packageListEndpoint = compileEnv == "production"\n    ? "https://d3uqzv7l1ih05d.cloudfront.net/rock_list.json"\n    : "../../image_package_root/rock_list.json"\nconst packageCdnEndpoint = compileEnv == "production"\n    ? "https://d3uqzv7l1ih05d.cloudfront.net/packages/"\n    : "../../image_package_root/packages/"\n\nconst staticSettings = new StaticManager(\n    packageListEndpoint,\n    packageCdnEndpoint,\n    "db_v3",\n    "files"\n)\n\nconst VIEW_PADDING = 0 // px\n\n// CONCATENATED MODULE: ./src/js/rotation_degree_handlers.js\nconst stepBy = unit => val => Math.floor(val / unit)\n\nconst cycleBy = unit => val => {\n    const cycle_count = Math.floor(val / unit)\n    return val < 0\n        ? val + unit\n        : (unit <= val)\n            ? val - unit * cycle_count\n            : val\n}\n\nconst rotation_degree_handlers_mirrorBy = (center) => val => val > center ? 2 * center - val : val\n\nconst isInverse = degree => (180 <= degree)\n\nconst rotateSign = (clockwise = true) => clockwise ? -1 : 1\n\n// CONCATENATED MODULE: ./src/js/draw_state_updators.js\n\n\n\n\n\nfunction clearView(state) {\n    viewer_ctx.clearRect(-state.canvasWidth * 0.5, -state.canvasHeight * 0.5, state.canvasWidth, state.canvasHeight)\n    return state\n}\n\nfunction blobToCanvas(state) {\n\n    const image_srcs = state.isCrossNicol\n        ? state.cross_images\n        : state.open_images\n\n    // view window circle\n\n    viewer_ctx.save()\n    viewer_ctx.beginPath()\n    viewer_ctx.arc(0, 0, state.canvasWidth / 2 - VIEW_PADDING, 0, Math.PI * 2, false)\n    viewer_ctx.clip()\n\n    // Draw a image\n    const alpha = state.getAlpha(state.rotate)\n\n    viewer_ctx.rotate(\n        rotateSign(state.isClockwise) * (state.rotate + state.getImageNumber(state.rotate) * state.rotate_degree_step) / 180 * Math.PI\n    )\n\n    viewer_ctx.globalAlpha = 1\n    const image1 = image_srcs[state.getImageNumber(state.rotate)]\n\n    try {\n        viewer_ctx.drawImage(\n            image1,\n            ...clipGeometoryFromImageCenter(state),\n            -state.canvasWidth / 2,\n            -state.canvasHeight / 2,\n            state.canvasWidth,\n            state.canvasHeight\n        );\n    } catch (e) {\n\n    }\n\n    viewer_ctx.restore()\n\n    // Draw next image\n    viewer_ctx.save()\n    viewer_ctx.beginPath()\n    viewer_ctx.arc(0, 0, state.canvasWidth / 2 - VIEW_PADDING, 0, Math.PI * 2, false)\n    viewer_ctx.clip()\n\n    viewer_ctx.rotate(\n        rotateSign(state.isClockwise) * (state.rotate + state.getImageNumber(state.rotate + state.rotate_degree_step) * state.rotate_degree_step) / 180 * Math.PI\n    )\n\n    viewer_ctx.globalAlpha = 1 - alpha\n    const image2 = image_srcs[state.getImageNumber(state.rotate + state.rotate_degree_step)]\n    try {\n        viewer_ctx.drawImage(\n            image2,\n            ...clipGeometoryFromImageCenter(state),\n            -state.canvasWidth / 2,\n            -state.canvasHeight / 2,\n            state.canvasWidth,\n            state.canvasHeight)\n    } catch (e) {\n\n    }\n    viewer_ctx.restore()\n    return state\n}\n\nfunction drawHairLine(state) {\n    if (!state.drawHairLine) return\n    viewer_ctx.strokeStyle = state.isCrossNicol\n        ? "white"\n        : "black";\n    viewer_ctx.globalAlpha = 1\n    viewer_ctx.beginPath()\n    viewer_ctx.moveTo(0, -state.canvasHeight * 0.5 + VIEW_PADDING)\n    viewer_ctx.lineTo(0, state.canvasHeight * 0.5 - VIEW_PADDING)\n    viewer_ctx.moveTo(-state.canvasWidth * 0.5 + VIEW_PADDING, 0)\n    viewer_ctx.lineTo(state.canvasWidth * 0.5 - VIEW_PADDING, 0)\n    viewer_ctx.closePath()\n    viewer_ctx.stroke()\n    return state\n}\n\nconst scaleLength = (canvasWidth, imageWidth, scaleWidth) => canvasWidth * scaleWidth / imageWidth\n\nfunction drawScale(state) {\n    if (!state["scaleWidth"]) return;\n    let scalePixel = scaleLength(state.canvasWidth, state.imageRadius * 2, state.scaleWidth)\n    const canvasWidth = state.canvasWidth;\n    const scaleBar = document.querySelector("#scalebar")\n\n\n    let scaleNumber = state.scaleText.match(/(\\d+\\.?\\d*)/)[0] * 1\n    const scaleUnit = state.scaleText.match(/\\D*$/)[0]\n\n    while (scalePixel >= canvasWidth) {\n        scalePixel *= 0.5\n        scaleNumber *= 0.5\n    }\n    scaleBar.style.width = scalePixel + "px";\n    scaleBar.querySelector("div:first-child").innerHTML = `${scaleNumber} ${scaleUnit}`;\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/updateView.js\n\n\nfunction updateView(state) {\n    clearView(state)\n    blobToCanvas(state)\n    drawHairLine(state)\n    drawScale(state)\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/setToggleNicolEvents.js\n\n\nfunction setToggleNicolEvents(state) {\n\n    const toggleNicolButton = document.querySelector("#change_nicol")\n    const toggleNicolLabel = document.querySelector("#change_nicol + label")\n\n    const toggleNicolHandler = state => new Promise((res, rej) => {\n\n        toggleNicolButton.checked = state.isCrossNicol\n        state.isCrossNicol = !state.isCrossNicol;\n\n\n        res(state)\n    })\n\n    toggleNicolButton.addEventListener(\n        "click",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n    toggleNicolLabel.addEventListener(\n        "touch",\n        e => { e.preventDefault() },\n        false\n    )\n\n    toggleNicolButton.addEventListener(\n        "touch",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n    toggleNicolLabel.addEventListener(\n        "mouseup",\n        e => toggleNicolHandler(state)\n            .then(updateView),\n        false\n    )\n\n    toggleNicolLabel.addEventListener(\n        "touchend",\n        e => toggleNicolHandler(state)\n            .then(updateView)\n            .then(_ => {\n                if (e.cancelable) {\n                    e.preventDefault();\n                }\n            }),\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/MessageBarActivitySwitcher.js\nclass MessageBarActivitySwitcher {\n    constructor(messageBarSelector) {\n        this.root = document.querySelector(messageBarSelector)\n        this.hook = {}\n        return this\n    }\n\n    activate() {\n        this.hook["activate"](this.root)\n        this.root.classList.remove("inactive")\n    }\n\n    inactivate() {\n        this.hook["inactivate"](this.root)\n        this.root.classList.add("inactive")\n    }\n\n    setHookOnActivate(hook = rootNode => { }) {\n        this.hook["activate"] = hook\n        return this\n    }\n\n    setHookOnInactivate(hook = rootNode => { }) {\n        this.hook["inactivate"] = hook\n        return this\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/error_indicator_handler.js\n\n\nconst switchErrorMessage = new MessageBarActivitySwitcher(\n    "#error_message_bar"\n).setHookOnInactivate(\n    rootNode => {\n        rootNode.classList.remove("message-error")\n    }\n)\n\nfunction hideErrorMessage(state) {\n    switchErrorMessage.inactivate()\n    return state\n}\n\nfunction showErrorMessage(message) {\n    return (_) => {\n        switchErrorMessage.setHookOnActivate(\n            rootDOM => {\n                rootDOM.querySelector(".message_space").innerHTML = message\n                rootDOM.classList.add("message-error")\n            }\n        )\n        switchErrorMessage.activate()\n        return _\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/loading_indicator_handler.js\n\n\nconst switchLoadingMessage = new MessageBarActivitySwitcher(\n    "#loading_message_bar"\n).setHookOnActivate(\n    rootNode => {\n        rootNode.querySelector(".message_space").innerHTML = "Loading images..."\n        rootNode.classList.add("message-loading")\n    }\n).setHookOnInactivate(\n    rootNode => {\n        rootNode.classList.remove("message-loading")\n    }\n)\n\nconst showLoadingMessage = state => {\n    switchLoadingMessage.activate()\n    return state\n}\n\nconst hideLoadingMessage = state => {\n    switchLoadingMessage.inactivate()\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/viewer_handlers.js\n\n\nconst hideWelcomeBoard = state => {\n    const board = document.querySelector("#welcome-card")\n    board.classList.add("inactive");\n    return state\n}\n\nconst showViewer = state => {\n    const card = document.querySelector("#viewer_wrapper")\n    card.classList.remove("inactive")\n    return state\n}\n\nconst showNicolButton = state => {\n    const button = document.querySelector("#low-navigation")\n    button.classList.remove("inactive");\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/sanitizeID.js\nfunction sanitizeID(id) {\n    return id.replace(/\\//g, "_").replace(/\\./g, "")\n}\n\n// CONCATENATED MODULE: ./src/js/data_translaters.js\nif (!HTMLCanvasElement.prototype.toBlob) {\n    Object.defineProperty(HTMLCanvasElement.prototype, \'toBlob\', {\n        value: function (callback, type, quality) {\n\n            var binStr = atob(this.toDataURL(type, quality).split(\',\')[1]),\n                len = binStr.length,\n                arr = new Uint8Array(len);\n\n            for (var i = 0; i < len; i++) {\n                arr[i] = binStr.charCodeAt(i);\n            }\n\n            callback(new Blob([arr], { type: type || \'image/png\' }));\n        }\n    });\n}\n\nfunction bufferToBase64(buffer, ext) {\n    return new Promise((res, rej) => {\n\n        var bytes = new Uint8Array(buffer);\n        var binary = \'\';\n        var len = bytes.byteLength;\n        for (var i = 0; i < len; i++) {\n            binary += String.fromCharCode(bytes[i]);\n        }\n        res(`data:image/${ext};base64,` + window.btoa(binary));\n    })\n}\n\n\nfunction blobToBase64(blob) {\n    return new Promise((resolve, reject) => {\n        const reader = new FileReader;\n        reader.onerror = reject;\n        reader.onload = () => {\n            resolve(reader.result);\n        };\n        reader.readAsDataURL(blob);\n    });\n}\n\n// CONCATENATED MODULE: ./src/js/progress_bar_handlers.js\nfunction progressLoading(selector) {\n    const progress = document.querySelector(selector)\n    const bar = progress.querySelector(".bar")\n    bar.style.width = "0%"\n    const total = progress.clientWidth\n    return e => {\n        bar.style.width = `${(e.loaded / e.total) * 100}%`\n    }\n}\n\nfunction completeLoading(selector) {\n    const progress = document.querySelector(selector)\n    const bar = progress.querySelector(".bar")\n    return e => {\n        bar.style.width = "0%"\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/unzipper.js\n\n\nfunction unzipper(url) {\n    return new Promise((res, rej) => {\n\n        Zip.inflate_file(url, res, rej, progressLoading("#progress_bar"), completeLoading("#progress_bar"))\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/extractFile.js\n\n\n/**\n *\n * @param {*} zip\n * @return {Object[meta,zip]}\n */\nasync function extractFile(zipByte) {\n    const zip = Zip.inflate(zipByte)\n    const inflated_zip = {}\n    await Promise.all(Object.entries(zip.files).map(async kv => {\n        if (kv[0].includes(".json")) {\n            inflated_zip[kv[0]] = kv[1].inflate()\n        } else {\n            const type = kv[0].match(/.*\\.(\\w+)$/)[1]\n            const base64 = await bufferToBase64(kv[1].inflate(), type)\n            const mime = base64.match(/^data:(image\\/\\w+);/)[1]\n            const mime_type = mime.split("/")[1]\n\n            const new_file_name = kv[0].split(".")[0] + "." + mime_type\n\n            inflated_zip[new_file_name] = base64\n\n        }\n\n        return true\n    }))\n\n    return inflated_zip\n}\n\n// CONCATENATED MODULE: ./src/js/queryImagePackage.js\n\n\n\n\n\n\n/**\n *\n * @param {String} url\n * @return {Array[String, Boolean]} [lastModified, networkDisconnected]\n */\nasync function queryLastModified(url) {\n    try {\n        const header = await fetch(url, { method: \'HEAD\', mode: \'cors\' }).catch(e => {\n            console.log("Package metadata cannot be fetched.")\n            throw Error(e)\n        })\n        var lastModified = header.headers.get("last-modified")\n        var networkDisconnected = false\n        return [lastModified, networkDisconnected]\n    } catch (e) {\n        var lastModified = "none"\n        var networkDisconnected = true\n        return [lastModified, networkDisconnected]\n    }\n}\n\nclass queryImagePackage_AdhocPackageRepo {\n    constructor(state) {\n        this.state = state\n    }\n\n    resolveImagePackage(packageId, desiredFormat, manifest) {\n        function selectFormatWithFallbackToJpg(list, format) {\n            if (list.includes(format)) {\n                return format\n            } else {\n                return "jpg"\n            }\n        }\n        const format = manifest.hasOwnProperty(\'image_formats\') && manifest["image_formats"] != null\n            ? selectFormatWithFallbackToJpg(manifest.image_formats, desiredFormat)\n            : desiredFormat\n        console.log(format)\n        return [staticSettings.getImageDataPath(packageId) + format + ".zip", format]\n    }\n\n    /**\n     * \n     * @param {String} packageId\n     * @returns {Promise}\n     *     zip: Object<String, Image Blob>\n     */\n    async retrieve(packageId, desiredFormat) {\n        const manifestUrl = staticSettings.getImageDataPath(packageId) + "manifest.json";\n        const open_thumbnailUrl = staticSettings.getImageDataPath(packageId) + "o1.jpg";\n        const cross_thumbnailUrl = staticSettings.getImageDataPath(packageId) + "c1.jpg";\n        const manifestText = await fetch(manifestUrl, { mode: \'cors\' }).then(response => response.text())\n        const manifest = JSON.parse(manifestText);\n\n        const [zipUrl, format] = this.resolveImagePackage(packageId, desiredFormat, manifest)\n        const [lastModified, _] = await queryLastModified(zipUrl)\n        const unzipped = async () => unzipper(zipUrl).then(extractFile)\n\n        const response = {\n            manifest: manifestText,\n            thumbnail: {\n                "o1.jpg": await fetch(open_thumbnailUrl, { mode: \'cors\' })\n                    .then(response => response.blob())\n                    .then(blobToBase64),\n                "c1.jpg": await fetch(cross_thumbnailUrl, { mode: \'cors\' })\n                    .then(response => response.blob())\n                    .then(blobToBase64)\n            },\n            lastModified: lastModified,\n            id: packageId,\n            zip: unzipped,\n            image_format: format\n        }\n        return response\n    }\n\n    async getImagesLastModified(packageId, desiredFormat) {\n        const manifestUrl = staticSettings.getImageDataPath(packageId) + "manifest.json";\n        const manifest = await fetch(manifestUrl, { mode: \'cors\' }).then(response => response.json())\n        const [zipUrl, _] = this.resolveImagePackage(packageId, desiredFormat, manifest)\n        const [lastModified, networkDisconnected] = await queryLastModified(zipUrl)\n        return [lastModified, networkDisconnected]\n    }\n}\n\n/**\n * 指定したkeyのデータがDBの中にある場合, DBからデータを取得する.\n * サーバとDBでデータの最終更新時刻が一致すれば,\n *  DBのデータを返す.\n * ネットワークエラーの場合, DBのデータか無を返す\n *\n * そうでなければサーバからmanifestとthumbnailを取得して返す.\n * また, 画像本体のzipファイルをfetchするアクションを起こす関数を返す.\n *\n * @param {Object} state\n * @param {String} packageName\n * @return {Array[Object,Boolean]} [response, toBeStored]\n */\nasync function queryImagePackage(\n    state,\n    packageName\n) {\n    const id = sanitizeID(packageName)\n    const storedData = await state.zipDBHandler.get(state.zipDB, id)\n    const repo = new queryImagePackage_AdhocPackageRepo(state)\n    const [lastModified, networkDisconnected] = await repo.getImagesLastModified(id, state.supportedImageType)\n\n    if (storedData !== undefined && storedData.lastModified === lastModified) {\n        var toBeStored = false\n        return [storedData, toBeStored]\n    }\n    if (networkDisconnected) {\n        if (storedData !== undefined) {\n            var toBeStored = false\n            return [storedData, toBeStored]\n        } else {\n            return [null, false]\n        }\n    } else {\n        const response = await repo.retrieve(id, state.supportedImageType)\n        var toBeStored = true\n        return [response, toBeStored]\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateStateByMeta.js\n\n\n\nfunction getRotationCenter(meta) {\n    return (meta.hasOwnProperty("rotate_center"))\n        ? {\n            "to_right": meta.rotate_center[0],\n            "to_bottom": meta.rotate_center[1]\n        }\n        : {\n            "to_right": meta.image_width * 0.5,\n            "to_bottom": meta.image_height * 0.5\n        }\n}\n\nfunction getImageRadius(meta) {\n    const shift = getRotationCenter(meta);\n    const image_center = {\n        "x": meta.image_width * 0.5,\n        "y": meta.image_height * 0.5\n    }\n    return Math.min(\n        image_center.x - Math.abs(image_center.x - shift.to_right),\n        image_center.y - Math.abs(image_center.y - shift.to_bottom)\n    )\n}\n\nfunction mapMetadata(meta) {\n    const rotate_degree_step = parseInt(meta.rotate_by_degree)\n\n    return {\n        isClockwise: meta.rotate_clockwise,\n        location: meta.location,\n        rockType: meta.rock_type,\n        owner: meta.owner,\n        description: meta.hasOwnProperty("discription")\n            ? meta.discription\n            : meta.hasOwnProperty("description")\n                ? meta.description\n                : {},\n        rotate_center: getRotationCenter(meta),\n        imageWidth: meta.image_width,\n        imageHeight: meta.image_height,\n        imageRadius: getImageRadius(meta),\n        imageRadiusOriginal: getImageRadius(meta),\n        scaleWidth: meta.hasOwnProperty("scale-pixel")\n            ? parseInt(meta["scale-pixel"])\n            : false,\n        scaleText: meta.hasOwnProperty("scale-unit")\n            ? meta["scale-unit"]\n            : false,\n        rotate_degree_step: rotate_degree_step\n    }\n}\n\nfunction updateStateByMeta(state) {\n    return (containorID, meta) => new Promise((res, rej) => {\n\n        state.containorID = sanitizeID(containorID);\n\n        const rotate_degree_step = parseInt(meta.rotate_by_degree)\n        const cycle_degree = meta.hasOwnProperty("cycle_rotate_degree")\n            ? parseInt(meta.cycle_rotate_degree)\n            : 90;\n        const image_number = cycle_degree / rotate_degree_step + 1\n        const mirror_at = (image_number - 1)\n        const total_step = (image_number - 1) * 2\n\n        state.image_number = image_number\n        state.getImageNumber = cycle_degree > 0\n            ? degree => cycleBy(image_number - 1)(\n                stepBy(rotate_degree_step)(state.isClockwise ? 360 - degree : degree)\n            )\n            : degree => mirrorBy(mirror_at)(\n                cycleBy(total_step)(\n                    stepBy(rotate_degree_step)(degree)\n                )\n            )\n\n        state.getAlpha = degree => {\n            const nth = cycleBy(total_step * 2)(\n                stepBy(rotate_degree_step)(degree)\n            )\n            return 1 - (degree - rotate_degree_step * nth) / rotate_degree_step\n        }\n\n        state.open_images = []\n        state.cross_images = []\n\n        state.rotate = 0;\n\n        state = Object.assign(state, mapMetadata(meta))\n\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/selectFromMultiLanguage.js\n/**\n *\n * @param {String,Object[String,String]} multiLanguageTextObj\n * @return {String}\n */\nfunction selectFromMultiLanguage(multiLanguageTextObj, languageCode) {\n    if (typeof (multiLanguageTextObj) === "string") {\n        return multiLanguageTextObj\n    } else if (typeof (multiLanguageTextObj) === "object") {\n        if (multiLanguageTextObj.hasOwnProperty(languageCode)) {\n            return multiLanguageTextObj[languageCode]\n        } else {\n            const keys = Object.keys(multiLanguageTextObj)\n            return (keys.length > 0)\n                ? multiLanguageTextObj[keys[0]]\n                : ""\n        }\n    } else {\n        return ""\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateViewDescription.js\n\n\nfunction updateViewDescription(state) {\n    const descriptionBox = document.querySelector("#view_description")\n    const lang = state.language\n\n    const rockFrom = `${selectFromMultiLanguage(state.rockType, lang)} ${state.location ? "(" + selectFromMultiLanguage(state.location, lang) + ")" : ""}`\n    const rockDisc = selectFromMultiLanguage(state.description, lang)\n    const rockOwner = selectFromMultiLanguage(state.owner, lang)\n\n    const textTemplate = `<ul style="list-style-type:none;">\n            <li>${rockFrom}</li>\n            <li>${rockDisc}</li>\n            <li>${rockOwner}</li>\n        </ul>`\n\n    descriptionBox.innerHTML = textTemplate;\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/setOpenAndCrossImages.js\nfunction setOpenAndCrossImages(state) {\n    return imgSets => new Promise((res, rej) => {\n        state.open_images = imgSets.open\n        state.cross_images = imgSets.cross\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/loadImageSrc.js\nfunction handleImgSrc(src) {\n    if (src instanceof Blob) {\n        const url = window.URL || window.webkitURL;\n        return url.createObjectURL(src)\n    } else if (src instanceof String) {\n        return src\n    } else {\n        return src\n    }\n}\n\n/**\n * @parameter src {dataURL}\n */\nfunction loadImageSrc(src) {\n    return new Promise((res, rej) => {\n\n        const img = new Image()\n\n        img.onload = _ => {\n            img.onnerror = null;\n            res(img)\n        }\n        img.onerror = e => {\n            res(img)\n        }\n\n        img.src = handleImgSrc(src)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/updateImageSrc.js\n\n\n\nfunction selectImageInContainor(containor, prefix) {\n    if (prefix in containor) {\n        return containor[prefix]\n    }\n    return "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQI12NgYAAAAAMAASDVlMcAAAAASUVORK5CYII="\n}\n\nfunction updateImageSrc(imagesMap, ext) {\n    return (state) => new Promise(async (res, rej) => {\n\n        Promise.all([\n            Promise.all(Array(state.image_number - 1).fill(0)\n                .map((_, i) => selectImageInContainor(imagesMap, `o${i + 1}.${ext}`))\n                .map(loadImageSrc)\n            ),\n            Promise.all(Array(state.image_number - 1).fill(0)\n                .map((_, i) => selectImageInContainor(imagesMap, `c${i + 1}.${ext}`))\n                .map(loadImageSrc)\n            )\n        ]).then(imgDOMs => {\n            const open_imgs = imgDOMs[0]\n\n            const cross_imgs = imgDOMs[1]\n\n            return { open: open_imgs, cross: cross_imgs }\n        })\n            .then(setOpenAndCrossImages(state))\n            .then(res)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/registerZip.js\n/**\n *\n * @param {*} state\n * @param {*} key\n * @return {Object[meta,zip]}\n */\nfunction registerZip(state) {\n    return async (entry) => {\n\n        const newOne = await state.zipDBHandler.put(state.zipDB, entry)\n\n        state.storedKeys.push(entry.id)\n\n        if (state.storedKeys.length > 20) {\n            const oldest = state.storedKeys.shift()\n            const deleted = await state.zipDBHandler.delete(state.zipDB, oldest)\n            Array.from(document.querySelectorAll(`#rock_selector>option[value=${oldest}]`)).forEach(option => {\n                const label = option.innerHTML.replace("✓ ", "")\n                option.innerHTML = label\n                option.classList.remove("downloaded")\n            })\n        }\n\n        return state\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/register.js\n\n\nfunction register(state, isNewData) {\n    if (isNewData) {\n        return entry => new Promise((res, rej) => {\n            registerZip(state)(entry)\n                .then(res)\n        })\n    } else {\n        return _ => new Promise((res, rej) => {\n            res(state)\n        })\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/markDownloadedOption.js\n/**\n *\n * @param {*} packageName\n * @return {Object[meta,zip]}\n */\nfunction markDownloadedOption(packageName) {\n    return manifest => _ => new Promise((res, rej) => {\n        Array.from(document.querySelectorAll(`#rock_selector>option[value=${packageName}]`)).forEach(option => {\n            const label = option.innerHTML.replace("✓ ", "")\n            option.innerHTML = "✓ " + label\n            option.classList.add("downloaded")\n        })\n        res(_)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/rockNameSelectHandler.js\n\n\n\n\n\n\n\n\n\n\n\n/**\n * fetch lastmodified\n * fetch manifest\n * fetch sumbnail\n *\n * show sumbnail\n * show discription\n *\n * load images\n *  from db\n *  fetch\n *\n * store data\n */\nfunction rockNameSelectHandler(state) {\n    return new Promise(async (res, rej) => {\n        const rock_selector = document.querySelector("#rock_selector")\n        const packageName = rock_selector.options[rock_selector.selectedIndex].value\n        location.hash = packageName\n\n        state.canRotate = false;\n        hideErrorMessage()\n        showLoadingMessage()\n        hideWelcomeBoard()\n        showViewer()\n        showNicolButton()\n\n        try {\n            const [response, isNewData] = await queryImagePackage(state, packageName);\n            const manifest = JSON.parse(response.manifest);\n\n            const new_state = await updateStateByMeta(state)(packageName, manifest)\n                .then(updateViewDescription)\n                .then(updateImageSrc(response.thumbnail, "jpg"))\n                .then(updateView)\n\n            new_state.canRotate = true\n\n            if (isNewData) {\n                response.zip = await response.zip()\n            }\n\n            updateImageSrc(response.zip, response.image_format)(new_state)\n                .then(state => register(state, isNewData)(response))\n                .then(markDownloadedOption(packageName)(manifest))\n                .then(updateView)\n                .then(res)\n        } catch (e) {\n            rej(e)\n        }\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/setRockSelectEventHandlers.js\n\n\n\n\n\nfunction setRockSelectEventHandlers(state) {\n    const rock_selector = document.querySelector("#rock_selector")\n\n    rock_selector.addEventListener(\n        "change",\n        e => {\n            rockNameSelectHandler(state)\n                .then(updateView)\n                .then(hideErrorMessage)\n                .then(hideLoadingMessage)\n                .catch(e => {\n                    console.log("Sample cannot be loaded because of network error.")\n                    showErrorMessage("Internet disconnected.")(e)\n                })\n        },\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/getCoordinateOnCanvas.js\nfunction getCoordinateOnCanvas(canvas) {\n    return (e, fingur = 0) => {\n        if (e instanceof MouseEvent) {\n            return (e instanceof WheelEvent)\n                ? [\n                    e.deltaX,\n                    e.deltaY\n                ]\n                : [\n                    e.pageX - canvas.offsetLeft,\n                    e.pageY - canvas.offsetTop\n                ]\n        } else if (e instanceof TouchEvent && e.touches.length > fingur) {\n            return [\n                e.touches[fingur].pageX - canvas.offsetLeft,\n                e.touches[fingur].pageY - canvas.offsetTop\n            ]\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/radiunBetween.js\nfunction radiunBetween(cx, cy) {\n    return (_x1, _y1, _x2, _y2) => {\n        const x1 = _x1 - cx\n        const x2 = _x2 - cx\n        const y1 = _y1 - cy\n        const y2 = _y2 - cy\n\n        const cos = (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n        return Math.sign(x1 * y2 - x2 * y1) * Math.acos(cos)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/coordinate_updators.js\n\n\n\n\n\nconst canvasCoordinate = getCoordinateOnCanvas(viewer)\n\n/**\n * Update start and end position\n * @param {*} state\n * @param {*} e\n */\nfunction updateCoordinate(state, e) {\n    state.drag_start = state.drag_end || undefined\n    state.drag_end = canvasCoordinate(e)\n\n    state.pinch_start = state.pinch_end || undefined\n    state.pinch_end = canvasCoordinate(e, 1)\n    return state\n}\n\n/**\n * Calculate small difference of rotation.\n * Update total rotation.\n *\n * @param {*} state\n * @param {*} e\n */\nfunction updateRotate(state, e) {\n    if (!state.canRotate) return;\n    if (state.drag_start === undefined) return\n    // delta rotate radius\n    const rotate_end = radiunBetween(\n        state.canvasWidth * 0.5,\n        state.canvasHeight * 0.5\n    )(...state.drag_end, ...state.drag_start)\n\n    state.rotate += rotate_end / Math.PI * 180\n    if (state.rotate >= 360) {\n        state.rotate -= 360\n    } else if (state.rotate < 0) {\n        state.rotate += 360\n    }\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/rotateImage.js\n\n\n\nfunction rotateImage(state, e) {\n    return () => {\n        updateCoordinate(state, e)\n        updateRotate(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateMagnify.js\n\n\nfunction updateMagnifyByPinch(state, e) {\n    if (state.drag_start === undefined) return\n    if (state.pinch_start === undefined) return\n\n    const x1 = [...state.drag_start]\n    const y1 = [...state.pinch_start]\n    const x2 = [...state.drag_end]\n    const y2 = [...state.pinch_end]\n\n    const expansion = Math.sqrt((x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2) / Math.sqrt((x1[0] - y1[0]) ** 2 + (x1[1] - y1[1]) ** 2)\n\n    const newRadius = (expansion > 2)\n        ? state.imageRadius\n        : state.imageRadius / expansion\n    state.imageRadius = (newRadius) > state.imageRadiusOriginal\n        ? state.imageRadiusOriginal\n        : (newRadius < 100)\n            ? 100\n            : newRadius\n    return state\n}\n\nfunction updateMagnifyByWheel(state, e) {\n    const scrolled = canvasCoordinate(e)[1]\n\n    const newRadius = state.imageRadius + scrolled\n    state.imageRadius = (newRadius) > state.imageRadiusOriginal\n        ? state.imageRadiusOriginal\n        : (newRadius < 100)\n            ? 100\n            : newRadius\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/pinchImage.js\n\n\n\n\nfunction pinchImage(state, e) {\n    return () => {\n        updateCoordinate(state, e)\n        updateMagnifyByPinch(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n        drawScale(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/touchEventHandlers.js\n\n\n\n\nconst touchStartHandler = state => e => {\n    state.isMousedown = true\n    state.drag_end = canvasCoordinate(e)\n    e.preventDefault();\n}\n\nconst touchMoveHandler = state => e => {\n    if (!state.isMousedown) return\n    if (e instanceof MouseEvent || e.touches.length === 1) {\n        e.preventDefault();\n        requestAnimationFrame(\n            rotateImage(state, e)\n        )\n    } else if (e.touches.length === 2) {\n        e.preventDefault()\n        requestAnimationFrame(\n            pinchImage(state, e)\n        )\n    }\n}\n\nconst touchEndHandler = state => e => {\n    state.isMousedown = false\n    state.drag_end = undefined\n    state.pinch_end = undefined\n    e.preventDefault()\n}\n\n// CONCATENATED MODULE: ./src/js/wheelImage.js\n\n\n\nfunction wheelImage(state, e) {\n    return () => {\n        updateMagnifyByWheel(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n        drawScale(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/wheelEventHandler.js\n\n\nconst wheelHandler = state => e => {\n    e.preventDefault();\n    requestAnimationFrame(\n        wheelImage(state, e)\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/setCanvasEventHandlers.js\n\n\n\n\nfunction setCanvasEventHandlers(state) {\n    viewer.addEventListener(\n        "mousedown",\n        touchStartHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "dragstart",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "drag",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "dragend",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n\n    viewer.addEventListener(\n        "touchstart",\n        touchStartHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "mousemove",\n        touchMoveHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "touchmove",\n        touchMoveHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "mouseup",\n        touchEndHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "touchend",\n        touchEndHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "wheel",\n        wheelHandler(state),\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/languageChangeHandler.js\nfunction languageChangeHandler(state) {\n    return function (e) {\n        return new Promise((res, rej) => {\n            const languageSelector = document.querySelector("#language_selector")\n            const lang = languageSelector.options[languageSelector.selectedIndex].value;\n            state.language = lang\n            state.localStorage.put("language", lang)\n            res(state)\n        })\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/showSampleList.js\n/**\n * サンプルリストをselectタグ内に追加する\n * @param {*} state\n */\nfunction showSampleList(state, response) {\n    return new Promise(async (res, rej) => {\n\n        const savedSampleNames = state.storedKeys;\n\n        const sampleList = response["list_of_sample"];\n        const sampleSelectDOM = document.querySelector("#rock_selector");\n        sampleSelectDOM.innerHTML = "<option value=\'\' disabled selected style=\'display:none;\'>Select sample</option>";\n        const options = sampleList.map((v, i) => {\n            const option = document.createElement("option")\n            option.value = v["package-name"];\n            option.innerHTML = (savedSampleNames.includes(v["package-name"]) ? "✓ " : "") + `${i + 1}. ${v["list-name"][state.language]}`\n            if (savedSampleNames.includes(v["package-name"])) {\n                option.classList.add("downloaded")\n            }\n            return option\n        })\n        options.forEach(v => {\n            sampleSelectDOM.appendChild(v)\n        })\n\n        document.querySelector("#top-navigation").classList.add("isready");\n        sampleSelectDOM.classList.add("isready")\n        res(state);\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/loadSampleListFromRemote.js\n\n\n\n\nfunction loadSampleListFromRemote(state) {\n    return new Promise(async (res, rej) => {\n        const listURL = staticSettings.getSampleListURL();\n        try {\n            var response = await fetch(listURL, { mode: \'cors\' })\n                .catch((e) => { throw Error(e) })\n                .then(r => r.json())\n            state.localStorage.put("list_of_sample", JSON.stringify(response["list_of_sample"]))\n        } catch (e) {\n            var stored_list = state.localStorage.get("list_of_sample")\n            var response = { "list_of_sample": JSON.parse(stored_list) }\n            console.warn(e)\n            showErrorMessage("<p>Internet disconnected.</p>")()\n        }\n        showSampleList(state, response).then(res)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/setLanguageSelectEventHandlers.js\n\n\n\n\nfunction setLanguageSelectEventHandlers(state) {\n    const languageSelector = document.querySelector("#language_selector")\n\n    languageSelector.addEventListener("change",\n        e => languageChangeHandler(state)(e)\n            .then(loadSampleListFromRemote)\n            .then(updateViewDescription),\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/sendContactMessage.js\nasync function sendContactMessage(e, messageDOM) {\n\n    const button = e.target\n    button.classList.add("pending")\n\n    messageDOM.classList.add("inactive")\n    messageDOM.classList.remove("success")\n    messageDOM.classList.remove("error")\n\n    const form = document.querySelector("#form-contact")\n    const selection = form.querySelector("#select-contact_topic")\n    const topic = selection[selection.selectedIndex].value\n    const message = form.querySelector("textarea").value\n    const from = form.querySelector("input[type=email").value\n\n    if (topic === "") {\n        button.classList.remove("pending")\n        messageDOM.innerHTML = "Select topic !"\n        messageDOM.classList.add("error")\n        messageDOM.classList.remove("inactive")\n        return false\n    }\n\n    if (message === undefined || message == "") {\n        button.classList.remove("pending")\n        messageDOM.innerHTML = "Write message !"\n        messageDOM.classList.add("error")\n        messageDOM.classList.remove("inactive")\n        return false\n    }\n\n    const obj = {\n        "from": from,\n        "title": topic,\n        "body": message\n    }\n\n    const method = "POST";\n    const body = JSON.stringify(obj);\n    const headers = {\n        \'Accept\': \'text/plain,application/json\',\n        \'Access-Control-Allow-Origin\': \'*\',\n        \'Access-Control-Allow-Headers\': \'Content-Type,X-Amz-Date,Authorization,X-Api-Key,X-Amz-Security-Token\',\n\n    };\n\n    console.log({ method, headers, body })\n\n    try {\n        const response = await fetch("https://dgo96yhuni.execute-api.us-east-1.amazonaws.com/contactapi/contact", { method, headers, body, \'mode\': \'no-cors\' })\n        messageDOM.innerHTML = "Success. Thank you for contributing !"\n        messageDOM.classList.add("success")\n        messageDOM.classList.remove("inactive")\n    } catch (e) {\n        console.log(e)\n        messageDOM.innerHTML = "Network error !"\n        messageDOM.classList.add("error")\n        messageDOM.classList.remove("inactive")\n    }\n    button.classList.remove("pending")\n\n    return false\n}\n\n// CONCATENATED MODULE: ./src/js/setContactFormEventHandlers.js\n\n\nfunction setContactFormEventHandlers(state) {\n    document.querySelector("#form-contact div.button").addEventListener(\n        "click",\n        e => (Array.from(e.target.classList).includes("pending"))\n            ? null\n            : sendContactMessage(\n                e,\n                document.querySelector("#form-contact .form-message")\n            ),\n        false\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/getMaxViewerSize.js\nfunction getMaxViewerSize() {\n    const topBarSpaceHeight = 200 // px\n    const width = window.innerWidth\n    const height = window.innerHeight - topBarSpaceHeight\n    return width < height ? width : height\n}\n\n// CONCATENATED MODULE: ./src/js/selectLanguageCode.js\nfunction selectLanguageCode() {\n    const code = (window.navigator.languages && window.navigator.languages[0]) ||\n        window.navigator.language ||\n        window.navigator.userLanguage ||\n        window.navigator.browserLanguage;\n\n    const lang = code.match("ja") ? "ja" : "en";\n\n    return lang\n}\n\n// CONCATENATED MODULE: ./src/js/initState.js\n\n\n\n\nfunction initState() {\n\n    return {\n        "containorID": "",\n        "imageNumber": 1,\n        "canvasWidth": getMaxViewerSize() <= 500\n            ? getMaxViewerSize()\n            : 500,\n        "canvasHeight": getMaxViewerSize() <= 500\n            ? getMaxViewerSize()\n            : 500,\n        "imageRadius": 0,\n        "open_image_srcs": [],\n        "open_images": [],\n        "cross_image_srcs": [],\n        "cross_images": [],\n        "isMousedown": false,\n        "drag_start": [0, 0],\n        "drag_end": [0, 0],\n        "rotate": 0,\n        "rotate_axis_translate": [],\n        "isClockwise": true,\n        "isCrossNicol": false,\n        "language": selectLanguageCode(),\n        "storedKeys": [],\n        "drawHairLine": true,\n        "canRotate": true,\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateViewerGeometry.js\n\n\n\nfunction updateViewerGeometry(state) {\n    return new Promise((res, rej) => {\n        const padding = 20 // px\n        state.canvasWidth = getMaxViewerSize() - padding\n        state.canvasHeight = getMaxViewerSize() - padding\n\n        viewer.width = state.canvasWidth\n        viewer.height = state.canvasHeight\n        viewer_ctx.translate(state.canvasWidth * 0.5, state.canvasHeight * 0.5)\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/es6Available.js\nfunction es6Available() {\n    return (typeof Symbol === "function" && typeof Symbol() === "symbol")\n}\n\n// CONCATENATED MODULE: ./src/js/NativeLocalStorage.js\nclass NativeLocalStorage {\n    constructor() {\n        this.db = window.localStorage\n    }\n\n    put(key, value) {\n        this.db.setItem(key, value);\n    }\n\n    get(key) {\n        const value = this.db.getItem(key)\n        return (value == null)\n            ? undefined\n            : value\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/DummyLocalStorage.js\nclass DummyLocalStorage {\n    constructor() {\n        this.db = {}\n    }\n\n    put(key, value) {\n        this.db[key] = value;\n    }\n\n    get(key) {\n        return (this.db.hasOwnProperty("key"))\n            ? this.db[key]\n            : undefined\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/ISmallStorageFactory.js\n\n\n\n\nfunction ISmallStorageFactory() {\n    return (window.localStorage)\n        ? new NativeLocalStorage()\n        : new DummyLocalStorage()\n}\n\n// CONCATENATED MODULE: ./src/js/connectLocalStorage.js\n\n\n// connectLocalStorage = ISmallStorage -> state -> state にする?\nfunction connectLocalStorage(state) {\n    state.localStorage = ISmallStorageFactory();\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/detect_supported_image.js\nasync function detectWebpSupport() {\n\n    const testImageSources = [\n        "data:image/webp;base64,UklGRjIAAABXRUJQVlA4ICYAAACyAgCdASoCAAEALmk0mk0iIiIiIgBoSygABc6zbAAA/v56QAAAAA==",\n        "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="\n    ]\n\n    const testImage = (src) => {\n        return new Promise((resolve, reject) => {\n            var img = document.createElement("img")\n            img.onerror = error => resolve(false)\n            img.onload = () => resolve(true)\n            img.src = src\n        })\n    }\n\n    const results = await Promise.all(testImageSources.map(testImage))\n\n    return results.every(result => !!result)\n}\n\nasync function detectJ2kSupport() {\n    const testImageSources = [\n        \'data:image/jp2;base64,AAAADGpQICANCocKAAAAFGZ0eXBqcDIgAAAAAGpwMiAAAAAtanAyaAAAABZpaGRyAAAABAAAAAQAAw8HAAAAAAAPY29scgEAAAAAABAAAABpanAyY/9P/1EALwAAAAAABAAAAAQAAAAAAAAAAAAAAAQAAAAEAAAAAAAAAAAAAw8BAQ8BAQ8BAf9SAAwAAAABAQAEBAAB/1wABECA/5AACgAAAAAAGAAB/5PP/BAQFABcr4CA/9k=\'\n    ]\n\n    const testImage = (src) => {\n        return new Promise((resolve, reject) => {\n            var img = document.createElement("img")\n            img.onerror = error => resolve(false)\n            img.onload = () => resolve(true)\n            img.src = src\n        })\n    }\n\n    const results = await Promise.all(testImageSources.map(testImage))\n\n    return results.every(result => !!result)\n}\n\n// CONCATENATED MODULE: ./src/js/getSupportedImageType.js\n\n\nasync function getSupportedImageType() {\n    if (await detectWebpSupport()) {\n        return "webp"\n    }\n    if (await detectJ2kSupport()) {\n        return "jp2"\n    }\n    return "jpg"\n}\n\n// CONCATENATED MODULE: ./src/js/checkSupportedImageFormat.js\n\n\n\nasync function checkSupportedImageFormat(state) {\n    state.supportWebp = await detectWebpSupport();\n    state.supportJ2k = await detectJ2kSupport();\n    state.supportedImageType = await getSupportedImageType();\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/overrideLanguageByLocalStorage.js\nfunction overwrideLanguageByLocalStorage(state) {\n    const langInLocalStorage = state.localStorage.get("language")\n    const lang = (langInLocalStorage !== undefined)\n        ? langInLocalStorage\n        : state.language;\n    state.language = lang\n    document.querySelector("option[value=" + lang + "]").selected = true\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/DatabaseHandler.js\nclass DatabaseHandler {\n    constructor(db_name, version, storeName, primaryKeyName) {\n        this.db = window.indexedDB;\n        this.db_name = db_name;\n        this.db_version = version;\n        this.storeName = storeName;\n        this.primaryKey = primaryKeyName;\n    }\n\n    schemeDef(db) {\n        db.createObjectStore(this.storeName, { keyPath: this.primaryKey, autoIncrement: true });\n    }\n\n    connect() {\n        const dbp = new Promise((resolve, reject) => {\n            const req = this.db.open(this.db_name, this.db_version);\n            req.onsuccess = ev => resolve(ev.target.result);\n            req.onerror = ev => reject(\'fails to open db\');\n            req.onupgradeneeded = ev => this.schemeDef(ev.target.result);\n        });\n        dbp.then(d => d.onerror = ev => alert("error: " + ev.target.errorCode));\n        return dbp;\n    }\n\n    async put(db, obj) { // returns obj in IDB\n        return new Promise((resolve, reject) => {\n            const docs = db.transaction([this.storeName], \'readwrite\').objectStore(this.storeName);\n            const req = docs.put(obj);\n            req.onsuccess = () => resolve(Object.assign({ [this.primaryKey]: req.result }, obj));\n            req.onerror = reject;\n        });\n    }\n\n    async get(db, id) { // NOTE: if not found, resolves with undefined.\n        return new Promise((resolve, reject) => {\n            const docs = db.transaction([this.storeName,]).objectStore(this.storeName);\n            const req = docs.get(id);\n            req.onsuccess = () => resolve(req.result);\n            req.onerror = reject;\n        });\n    }\n\n    async delete(db, id) {\n        return new Promise((resolve, reject) => {\n            const docs = db.transaction([this.storeName,], \'readwrite\')\n                .objectStore(this.storeName);\n            const req = docs.delete(id);\n            req.onsuccess = () => resolve(id);\n            req.onerror = reject;\n        })\n    }\n\n    async loadAllKey(db) {\n        return new Promise(async (resolve, reject) => {\n            const saves = [];\n            var range = IDBKeyRange.lowerBound(0);\n            const req = db.transaction([this.storeName]).objectStore(this.storeName).openCursor(range);\n            req.onsuccess = function (e) {\n                var result = e.target.result;\n                // 注）走査すべきObjectがこれ以上無い場合\n                //     result == null となります！\n                if (!!result == false) {\n                    resolve(saves)\n                } else {\n                    // ここにvalueがくる！\n                    saves.push(result.key);\n                    // カーソルを一個ずらす\n                    result.continue();\n                }\n\n\n            }\n        });\n    }\n\n    async getAllKeys(db) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                var req = db.transaction([this.storeName]).objectStore(this.storeName)\n            } catch (e) {\n                return resolve([])\n            }\n\n            if (req.getAllKeys) {\n                req.getAllKeys().onsuccess = function (event) {\n                    const rows = event.target.result;\n                    resolve(rows);\n                }\n            } else {\n                const entries = await this.loadAllKey(db)\n                resolve(entries)\n            }\n            req.onerror = reject\n        })\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/DummyDatabaseHandler.js\n\n\nclass DummyDatabaseHandler_DummyDatabaseHandler extends DatabaseHandler {\n    constructor(db_name, version, storeName, primaryKeyName) {\n        console.warn("IndexedDB is not available !")\n        super(db_name, version, storeName, primaryKeyName)\n        this.storage = {}\n    }\n\n    connect() {\n        return {}\n    }\n\n    put(db, obj) {\n        if (db.hasOwnProperty(obj[this.primaryKey])) {\n            var old = db[obj[this.primaryKey]]\n        } else {\n            var old = {}\n        }\n        const new_entry = Object.assign(old, obj)\n        db[obj[this.primaryKey]] = new_entry;\n        return { [obj[this.primaryKey]]: new_entry }\n    }\n\n    get(db, id) {\n        if (db.hasOwnProperty(id)) {\n            return db[id]\n        } else {\n            return undefined\n        }\n    }\n\n    delete(db, id) {\n        if (db.hasOwnProperty(id)) {\n            db[id] = null;\n            return id\n        } else {\n            return undefined\n        }\n    }\n\n    loadAll(db) {\n        return Object.entries(db)\n    }\n\n    getAllKeys(db) {\n        return Object.keys(db)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/connectDatabase.js\n\n\n\n\nasync function connectDatabase(state) {\n    state.zipDBHandler = (window.indexedDB)\n        ? (!navigator.userAgent.match("Edge"))\n            ? new DatabaseHandler(staticSettings.getDBName(), 2, staticSettings.getStorageName(), "id")\n            : new DatabaseHandler(staticSettings.getDBName(), 1, staticSettings.getStorageName(), "id")\n        : new DummyDatabaseHandler_DummyDatabaseHandler(staticSettings.getDBName(), 2, staticSettings.getStorageName(), "id")\n    state.zipDB = await state.zipDBHandler.connect()\n    return state\n};\n\n// CONCATENATED MODULE: ./src/js/getStoredDBEntryKeys.js\nasync function getStoredDBEntryKeys(state) {\n    state.storedKeys = await state.zipDBHandler.getAllKeys(state.zipDB)\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/fetch_package_by_query.js\n\n\n\n\n\n\n\n\n\n\n\nfunction fetchPackageById(state, packageID) {\n    return new Promise(async (res, rej) => {\n\n        state.canRotate = false;\n        hideErrorMessage()\n        showLoadingMessage()\n        hideWelcomeBoard()\n        showViewer()\n        showNicolButton()\n\n        try {\n            const [response, isNewData] = await queryImagePackage(state, packageID);\n            const manifest = JSON.parse(response.manifest);\n\n            const new_state = await updateStateByMeta(state)(packageID, manifest)\n                .then(updateViewDescription)\n                .then(updateImageSrc(response.thumbnail, "jpg"))\n                .then(updateView)\n\n            new_state.canRotate = true\n\n            if (isNewData) {\n                response.zip = await response.zip()\n            }\n\n            updateImageSrc(response.zip, response.image_format)(new_state)\n                .then(state => register(state, isNewData)(response))\n                .then(markDownloadedOption(packageID)(manifest))\n                .then(updateView)\n                .then(res)\n        } catch (e) {\n            rej(e)\n        }\n    })\n}\n// CONCATENATED MODULE: ./src/js/index.js\n/**\n *  Language code of sample list is such as "ja" or "en".\n */\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ndeleteOldVersionDatabase()\n\n\n\n\nfunction handleErrors(response) {\n    if (response.ok) {\n        return response;\n    }\n\n    switch (response.status) {\n        case 400: throw new Error(\'INVALID_TOKEN\');\n        case 401: throw new Error(\'UNAUTHORIZED\');\n        case 500: throw new Error(\'INTERNAL_SERVER_ERROR\');\n        case 502: throw new Error(\'BAD_GATEWAY\');\n        case 404: throw new Error(\'NOT_FOUND\');\n        default: throw new Error(\'UNHANDLED_ERROR\');\n    }\n}\n\nfunction isMobileEnv(userAgent) {\n    return (userAgent.indexOf("iPhone") >= 0 || userAgent.indexOf("iPad") >= 0 || userAgent.indexOf("Android") >= 0)\n}\n\nfunction notifyIncompatibleEnv() {\n    var warnningCard = document.getElementById("please_use_modern_browser")\n    warnningCard.classList.remove("inactive")\n}\n\nconst get_package_id = () => {\n    const hash = location.hash.slice(1)\n    return hash === "" ? undefined : hash\n}\n\n/**\n    *\n    * Entry point function !\n    */\nfunction init(state) {\n    // Check ES6 availability\n    // Set window event listener\n    //\n    if (!es6Available) {\n        notifyIncompatibleEnv()\n        return\n    }\n\n    // スマートフォンの場合はorientationchangeイベントを監視する\n    if (isMobileEnv(navigator.userAgent))\n        window.addEventListener(\n            "orientationchange",\n            e => updateViewerGeometry(state).then(updateView),\n            false\n        );\n\n\n    window.addEventListener(\n        "resize",\n        e => updateViewerGeometry(state).then(updateView),\n        false\n    );\n\n\n    updateViewerGeometry(state)\n        .then(connectLocalStorage)\n        .then(checkSupportedImageFormat)\n        .then(overwrideLanguageByLocalStorage)\n        .then(connectDatabase)\n        .then(getStoredDBEntryKeys)\n        .then(loadSampleListFromRemote)\n        .then(state => {\n            const packageID = get_package_id()\n            if (packageID) {\n                console.log(packageID)\n                return fetchPackageById(state, packageID)\n            } else {\n                return state\n            }\n        })\n        .then(hideLoadingMessage)\n        .catch(e => {\n            console.error(e)\n            hideLoadingMessage(e);\n        })\n\n\n    setToggleNicolEvents(state)\n    setRockSelectEventHandlers(state)\n    setCanvasEventHandlers(state)\n    setLanguageSelectEventHandlers(state)\n    setContactFormEventHandlers(state)\n\n}\n\nwindow.addEventListener(\n    "DOMcontentloaded",\n    init(initState()),\n    false\n)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9kZWxldGVPbGRWZXJzaW9uRGF0YWJhc2UuanM/Y2U2MCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2xpcEdlb21ldHJ5RnJvbUltYWdlQ2VudGVyLmpzP2QyY2QiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3ZpZXdlcl9jYW52YXMuanM/Y2Y3NSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvU3RhdGljTWFuYWdlci5qcz9jNDgyIiwid2VicGFjazovLy8uL3NyYy9qcy9jb25maWcvY29uZmlnLmpzP2RmYWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JvdGF0aW9uX2RlZ3JlZV9oYW5kbGVycy5qcz9lNWFlIiwid2VicGFjazovLy8uL3NyYy9qcy9kcmF3X3N0YXRlX3VwZGF0b3JzLmpzP2U5MjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3VwZGF0ZVZpZXcuanM/ZDUwZiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0VG9nZ2xlTmljb2xFdmVudHMuanM/NjBhYyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvTWVzc2FnZUJhckFjdGl2aXR5U3dpdGNoZXIuanM/YTBjYiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZXJyb3JfaW5kaWNhdG9yX2hhbmRsZXIuanM/OTVmZSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9hZGluZ19pbmRpY2F0b3JfaGFuZGxlci5qcz9hOGNmIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3ZXJfaGFuZGxlcnMuanM/YTgwNSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2FuaXRpemVJRC5qcz8wNjRjIiwid2VicGFjazovLy8uL3NyYy9qcy9kYXRhX3RyYW5zbGF0ZXJzLmpzPzYwMjUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3Byb2dyZXNzX2Jhcl9oYW5kbGVycy5qcz9lZDY2Iiwid2VicGFjazovLy8uL3NyYy9qcy91bnppcHBlci5qcz9hNWQ0Iiwid2VicGFjazovLy8uL3NyYy9qcy9leHRyYWN0RmlsZS5qcz85MmE5Iiwid2VicGFjazovLy8uL3NyYy9qcy9xdWVyeUltYWdlUGFja2FnZS5qcz8yMTQwIiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVTdGF0ZUJ5TWV0YS5qcz85NjEyIiwid2VicGFjazovLy8uL3NyYy9qcy9zZWxlY3RGcm9tTXVsdGlMYW5ndWFnZS5qcz8wNDI3Iiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVWaWV3RGVzY3JpcHRpb24uanM/MTFkMSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0T3BlbkFuZENyb3NzSW1hZ2VzLmpzPzUyNTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2xvYWRJbWFnZVNyYy5qcz8yNjI2Iiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVJbWFnZVNyYy5qcz8wZTgxIiwid2VicGFjazovLy8uL3NyYy9qcy9yZWdpc3RlclppcC5qcz84MmRhIiwid2VicGFjazovLy8uL3NyYy9qcy9yZWdpc3Rlci5qcz82ZmE0Iiwid2VicGFjazovLy8uL3NyYy9qcy9tYXJrRG93bmxvYWRlZE9wdGlvbi5qcz85NTQ1Iiwid2VicGFjazovLy8uL3NyYy9qcy9yb2NrTmFtZVNlbGVjdEhhbmRsZXIuanM/MDgyMCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0Um9ja1NlbGVjdEV2ZW50SGFuZGxlcnMuanM/NTkwOCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZ2V0Q29vcmRpbmF0ZU9uQ2FudmFzLmpzPzBlN2YiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JhZGl1bkJldHdlZW4uanM/NGYyMyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY29vcmRpbmF0ZV91cGRhdG9ycy5qcz8wYmU5Iiwid2VicGFjazovLy8uL3NyYy9qcy9yb3RhdGVJbWFnZS5qcz8xZTgyIiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVNYWduaWZ5LmpzPzdjYWEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3BpbmNoSW1hZ2UuanM/ODIxNSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvdG91Y2hFdmVudEhhbmRsZXJzLmpzP2UzMWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3doZWVsSW1hZ2UuanM/MzI2ZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvd2hlZWxFdmVudEhhbmRsZXIuanM/YjIxMCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0Q2FudmFzRXZlbnRIYW5kbGVycy5qcz9kYTE0Iiwid2VicGFjazovLy8uL3NyYy9qcy9sYW5ndWFnZUNoYW5nZUhhbmRsZXIuanM/MzM0NyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2hvd1NhbXBsZUxpc3QuanM/MDJmOSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9hZFNhbXBsZUxpc3RGcm9tUmVtb3RlLmpzPzU4YmYiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3NldExhbmd1YWdlU2VsZWN0RXZlbnRIYW5kbGVycy5qcz9hNDY5Iiwid2VicGFjazovLy8uL3NyYy9qcy9zZW5kQ29udGFjdE1lc3NhZ2UuanM/ZWU2YSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2V0Q29udGFjdEZvcm1FdmVudEhhbmRsZXJzLmpzP2VmODgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2dldE1heFZpZXdlclNpemUuanM/ODVhNSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvc2VsZWN0TGFuZ3VhZ2VDb2RlLmpzPzkxMDgiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2luaXRTdGF0ZS5qcz9lODNiIiwid2VicGFjazovLy8uL3NyYy9qcy91cGRhdGVWaWV3ZXJHZW9tZXRyeS5qcz9iNjYzIiwid2VicGFjazovLy8uL3NyYy9qcy9lczZBdmFpbGFibGUuanM/YTdkNiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvTmF0aXZlTG9jYWxTdG9yYWdlLmpzPzRlZWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0R1bW15TG9jYWxTdG9yYWdlLmpzPzQ5MTAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0lTbWFsbFN0b3JhZ2VGYWN0b3J5LmpzP2ZkNTMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Nvbm5lY3RMb2NhbFN0b3JhZ2UuanM/MDkzNSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZGV0ZWN0X3N1cHBvcnRlZF9pbWFnZS5qcz9hZjc4Iiwid2VicGFjazovLy8uL3NyYy9qcy9nZXRTdXBwb3J0ZWRJbWFnZVR5cGUuanM/Zjg4MiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvY2hlY2tTdXBwb3J0ZWRJbWFnZUZvcm1hdC5qcz9lZmJhIiwid2VicGFjazovLy8uL3NyYy9qcy9vdmVycmlkZUxhbmd1YWdlQnlMb2NhbFN0b3JhZ2UuanM/MGE5MyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvRGF0YWJhc2VIYW5kbGVyLmpzP2EzOTciLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL0R1bW15RGF0YWJhc2VIYW5kbGVyLmpzP2U3YjQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2Nvbm5lY3REYXRhYmFzZS5qcz9hZDA5Iiwid2VicGFjazovLy8uL3NyYy9qcy9nZXRTdG9yZWREQkVudHJ5S2V5cy5qcz8zNDlkIiwid2VicGFjazovLy8uL3NyYy9qcy9mZXRjaF9wYWNrYWdlX2J5X3F1ZXJ5LmpzPzM3OTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL2luZGV4LmpzPzdiYTUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gVGhpcyBzaG91bGQgYmUgbWV0aG9kIG9mIERCIGhhbmRsZXIgY2xhc3NcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGRlbGV0ZU9sZFZlcnNpb25EYXRhYmFzZSgpIHtcbiAgICBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoXCJkYl92MlwiKTtcbiAgICBpbmRleGVkREIuZGVsZXRlRGF0YWJhc2UoXCJ6aXBmaWxlc1wiKTtcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsaXBHZW9tZXRvcnlGcm9tSW1hZ2VDZW50ZXIoc3RhdGUpIHtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHN0YXRlLnJvdGF0ZV9jZW50ZXIudG9fcmlnaHQgLSBzdGF0ZS5pbWFnZVJhZGl1cyxcbiAgICAgICAgc3RhdGUucm90YXRlX2NlbnRlci50b19ib3R0b20gLSBzdGF0ZS5pbWFnZVJhZGl1cyxcbiAgICAgICAgc3RhdGUuaW1hZ2VSYWRpdXMgKiAyLFxuICAgICAgICBzdGF0ZS5pbWFnZVJhZGl1cyAqIDJcbiAgICBdXG59XG4iLCJleHBvcnQgY29uc3Qgdmlld2VyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNtYWluLXZpZXdlclwiKVxuZXhwb3J0IGNvbnN0IHZpZXdlcl9jdHggPSB2aWV3ZXIuZ2V0Q29udGV4dChcIjJkXCIpXG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBTdGF0aWNNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgc2FtcGxlTGlzdFVSTCxcbiAgICAgICAgaW1hZ2VEYXRhUGF0aFByZWZpeCxcbiAgICAgICAgZGJOYW1lLFxuICAgICAgICBzdG9yYWdlTmFtZVxuICAgICkge1xuICAgICAgICB0aGlzLnNhbXBsZUxpc3RVUkwgPSBzYW1wbGVMaXN0VVJMXG4gICAgICAgIHRoaXMuaW1hZ2VEYXRhUm9vdCA9IGltYWdlRGF0YVBhdGhQcmVmaXhcbiAgICAgICAgdGhpcy5pbmRleGVkREJOYW1lID0gZGJOYW1lXG4gICAgICAgIHRoaXMuc3RvcmFnZU5hbWUgPSBzdG9yYWdlTmFtZVxuICAgIH1cblxuICAgIGdldFNhbXBsZUxpc3RVUkwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNhbXBsZUxpc3RVUkxcbiAgICB9XG5cbiAgICBnZXRJbWFnZURhdGFQYXRoKHBhY2thZ2VOYW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlRGF0YVJvb3QgKyBwYWNrYWdlTmFtZSArIFwiL1wiXG4gICAgfVxuXG4gICAgZ2V0REJOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbmRleGVkREJOYW1lO1xuICAgIH1cblxuICAgIGdldFN0b3JhZ2VOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlTmFtZVxuICAgIH1cbn1cbiIsImltcG9ydCBTdGF0aWNNYW5hZ2VyIGZyb20gXCIuLi9TdGF0aWNNYW5hZ2VyLmpzXCI7XG5cbi8qKlxuICogVE9ETyBzcGxpdCB0aGVzZSBjb25maWcgYXMgZGlmZmVyZW50IG9iamVjdHNcbiAqXG4gKiAtIFBhY2thZ2UgbGlzdCBlbmRwb2ludFxuICogLSBQYWNrYWdlIENETiBlbmRwb2ludFxuICogLSBDYWNoZSBEQiB2ZXJzaW9uIG5hbWVcbiAqIC0gQ2FjaGUgREIgdGFibGUgbmFtZVxuICovXG5cbmNvbnN0IGNvbXBpbGVFbnYgPSBwcm9jZXNzLmVudi5OT0RFX0VOVlxuXG5jb25zb2xlLmluZm8oXCJjb25maWcuanM6IGNvbXBpbGVFbnY6IFwiLCBjb21waWxlRW52KVxuXG5jb25zdCBwYWNrYWdlTGlzdEVuZHBvaW50ID0gY29tcGlsZUVudiA9PSBcInByb2R1Y3Rpb25cIlxuICAgID8gXCJodHRwczovL2QzdXF6djdsMWloMDVkLmNsb3VkZnJvbnQubmV0L3JvY2tfbGlzdC5qc29uXCJcbiAgICA6IFwiLi4vLi4vaW1hZ2VfcGFja2FnZV9yb290L3JvY2tfbGlzdC5qc29uXCJcbmNvbnN0IHBhY2thZ2VDZG5FbmRwb2ludCA9IGNvbXBpbGVFbnYgPT0gXCJwcm9kdWN0aW9uXCJcbiAgICA/IFwiaHR0cHM6Ly9kM3VxenY3bDFpaDA1ZC5jbG91ZGZyb250Lm5ldC9wYWNrYWdlcy9cIlxuICAgIDogXCIuLi8uLi9pbWFnZV9wYWNrYWdlX3Jvb3QvcGFja2FnZXMvXCJcblxuZXhwb3J0IGNvbnN0IHN0YXRpY1NldHRpbmdzID0gbmV3IFN0YXRpY01hbmFnZXIoXG4gICAgcGFja2FnZUxpc3RFbmRwb2ludCxcbiAgICBwYWNrYWdlQ2RuRW5kcG9pbnQsXG4gICAgXCJkYl92M1wiLFxuICAgIFwiZmlsZXNcIlxuKVxuXG5leHBvcnQgY29uc3QgVklFV19QQURESU5HID0gMCAvLyBweFxuIiwiZXhwb3J0IGNvbnN0IHN0ZXBCeSA9IHVuaXQgPT4gdmFsID0+IE1hdGguZmxvb3IodmFsIC8gdW5pdClcblxuZXhwb3J0IGNvbnN0IGN5Y2xlQnkgPSB1bml0ID0+IHZhbCA9PiB7XG4gICAgY29uc3QgY3ljbGVfY291bnQgPSBNYXRoLmZsb29yKHZhbCAvIHVuaXQpXG4gICAgcmV0dXJuIHZhbCA8IDBcbiAgICAgICAgPyB2YWwgKyB1bml0XG4gICAgICAgIDogKHVuaXQgPD0gdmFsKVxuICAgICAgICAgICAgPyB2YWwgLSB1bml0ICogY3ljbGVfY291bnRcbiAgICAgICAgICAgIDogdmFsXG59XG5cbmV4cG9ydCBjb25zdCBtaXJyb3JCeSA9IChjZW50ZXIpID0+IHZhbCA9PiB2YWwgPiBjZW50ZXIgPyAyICogY2VudGVyIC0gdmFsIDogdmFsXG5cbmV4cG9ydCBjb25zdCBpc0ludmVyc2UgPSBkZWdyZWUgPT4gKDE4MCA8PSBkZWdyZWUpXG5cbmV4cG9ydCBjb25zdCByb3RhdGVTaWduID0gKGNsb2Nrd2lzZSA9IHRydWUpID0+IGNsb2Nrd2lzZSA/IC0xIDogMVxuIiwiaW1wb3J0IGNsaXBHZW9tZXRvcnlGcm9tSW1hZ2VDZW50ZXIgZnJvbSBcIi4vY2xpcEdlb21ldHJ5RnJvbUltYWdlQ2VudGVyLmpzXCJcbmltcG9ydCB7IHZpZXdlcl9jdHggfSBmcm9tIFwiLi92aWV3ZXJfY2FudmFzLmpzXCJcbmltcG9ydCB7IFZJRVdfUEFERElORyB9IGZyb20gXCIuL2NvbmZpZy9jb25maWcuanNcIlxuaW1wb3J0IHsgcm90YXRlU2lnbiB9IGZyb20gXCIuL3JvdGF0aW9uX2RlZ3JlZV9oYW5kbGVycy5qc1wiXG5cbmV4cG9ydCBmdW5jdGlvbiBjbGVhclZpZXcoc3RhdGUpIHtcbiAgICB2aWV3ZXJfY3R4LmNsZWFyUmVjdCgtc3RhdGUuY2FudmFzV2lkdGggKiAwLjUsIC1zdGF0ZS5jYW52YXNIZWlnaHQgKiAwLjUsIHN0YXRlLmNhbnZhc1dpZHRoLCBzdGF0ZS5jYW52YXNIZWlnaHQpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBibG9iVG9DYW52YXMoc3RhdGUpIHtcblxuICAgIGNvbnN0IGltYWdlX3NyY3MgPSBzdGF0ZS5pc0Nyb3NzTmljb2xcbiAgICAgICAgPyBzdGF0ZS5jcm9zc19pbWFnZXNcbiAgICAgICAgOiBzdGF0ZS5vcGVuX2ltYWdlc1xuXG4gICAgLy8gdmlldyB3aW5kb3cgY2lyY2xlXG5cbiAgICB2aWV3ZXJfY3R4LnNhdmUoKVxuICAgIHZpZXdlcl9jdHguYmVnaW5QYXRoKClcbiAgICB2aWV3ZXJfY3R4LmFyYygwLCAwLCBzdGF0ZS5jYW52YXNXaWR0aCAvIDIgLSBWSUVXX1BBRERJTkcsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSlcbiAgICB2aWV3ZXJfY3R4LmNsaXAoKVxuXG4gICAgLy8gRHJhdyBhIGltYWdlXG4gICAgY29uc3QgYWxwaGEgPSBzdGF0ZS5nZXRBbHBoYShzdGF0ZS5yb3RhdGUpXG5cbiAgICB2aWV3ZXJfY3R4LnJvdGF0ZShcbiAgICAgICAgcm90YXRlU2lnbihzdGF0ZS5pc0Nsb2Nrd2lzZSkgKiAoc3RhdGUucm90YXRlICsgc3RhdGUuZ2V0SW1hZ2VOdW1iZXIoc3RhdGUucm90YXRlKSAqIHN0YXRlLnJvdGF0ZV9kZWdyZWVfc3RlcCkgLyAxODAgKiBNYXRoLlBJXG4gICAgKVxuXG4gICAgdmlld2VyX2N0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICBjb25zdCBpbWFnZTEgPSBpbWFnZV9zcmNzW3N0YXRlLmdldEltYWdlTnVtYmVyKHN0YXRlLnJvdGF0ZSldXG5cbiAgICB0cnkge1xuICAgICAgICB2aWV3ZXJfY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgIGltYWdlMSxcbiAgICAgICAgICAgIC4uLmNsaXBHZW9tZXRvcnlGcm9tSW1hZ2VDZW50ZXIoc3RhdGUpLFxuICAgICAgICAgICAgLXN0YXRlLmNhbnZhc1dpZHRoIC8gMixcbiAgICAgICAgICAgIC1zdGF0ZS5jYW52YXNIZWlnaHQgLyAyLFxuICAgICAgICAgICAgc3RhdGUuY2FudmFzV2lkdGgsXG4gICAgICAgICAgICBzdGF0ZS5jYW52YXNIZWlnaHRcbiAgICAgICAgKTtcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICB9XG5cbiAgICB2aWV3ZXJfY3R4LnJlc3RvcmUoKVxuXG4gICAgLy8gRHJhdyBuZXh0IGltYWdlXG4gICAgdmlld2VyX2N0eC5zYXZlKClcbiAgICB2aWV3ZXJfY3R4LmJlZ2luUGF0aCgpXG4gICAgdmlld2VyX2N0eC5hcmMoMCwgMCwgc3RhdGUuY2FudmFzV2lkdGggLyAyIC0gVklFV19QQURESU5HLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpXG4gICAgdmlld2VyX2N0eC5jbGlwKClcblxuICAgIHZpZXdlcl9jdHgucm90YXRlKFxuICAgICAgICByb3RhdGVTaWduKHN0YXRlLmlzQ2xvY2t3aXNlKSAqIChzdGF0ZS5yb3RhdGUgKyBzdGF0ZS5nZXRJbWFnZU51bWJlcihzdGF0ZS5yb3RhdGUgKyBzdGF0ZS5yb3RhdGVfZGVncmVlX3N0ZXApICogc3RhdGUucm90YXRlX2RlZ3JlZV9zdGVwKSAvIDE4MCAqIE1hdGguUElcbiAgICApXG5cbiAgICB2aWV3ZXJfY3R4Lmdsb2JhbEFscGhhID0gMSAtIGFscGhhXG4gICAgY29uc3QgaW1hZ2UyID0gaW1hZ2Vfc3Jjc1tzdGF0ZS5nZXRJbWFnZU51bWJlcihzdGF0ZS5yb3RhdGUgKyBzdGF0ZS5yb3RhdGVfZGVncmVlX3N0ZXApXVxuICAgIHRyeSB7XG4gICAgICAgIHZpZXdlcl9jdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgaW1hZ2UyLFxuICAgICAgICAgICAgLi4uY2xpcEdlb21ldG9yeUZyb21JbWFnZUNlbnRlcihzdGF0ZSksXG4gICAgICAgICAgICAtc3RhdGUuY2FudmFzV2lkdGggLyAyLFxuICAgICAgICAgICAgLXN0YXRlLmNhbnZhc0hlaWdodCAvIDIsXG4gICAgICAgICAgICBzdGF0ZS5jYW52YXNXaWR0aCxcbiAgICAgICAgICAgIHN0YXRlLmNhbnZhc0hlaWdodClcbiAgICB9IGNhdGNoIChlKSB7XG5cbiAgICB9XG4gICAgdmlld2VyX2N0eC5yZXN0b3JlKClcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdIYWlyTGluZShzdGF0ZSkge1xuICAgIGlmICghc3RhdGUuZHJhd0hhaXJMaW5lKSByZXR1cm5cbiAgICB2aWV3ZXJfY3R4LnN0cm9rZVN0eWxlID0gc3RhdGUuaXNDcm9zc05pY29sXG4gICAgICAgID8gXCJ3aGl0ZVwiXG4gICAgICAgIDogXCJibGFja1wiO1xuICAgIHZpZXdlcl9jdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgdmlld2VyX2N0eC5iZWdpblBhdGgoKVxuICAgIHZpZXdlcl9jdHgubW92ZVRvKDAsIC1zdGF0ZS5jYW52YXNIZWlnaHQgKiAwLjUgKyBWSUVXX1BBRERJTkcpXG4gICAgdmlld2VyX2N0eC5saW5lVG8oMCwgc3RhdGUuY2FudmFzSGVpZ2h0ICogMC41IC0gVklFV19QQURESU5HKVxuICAgIHZpZXdlcl9jdHgubW92ZVRvKC1zdGF0ZS5jYW52YXNXaWR0aCAqIDAuNSArIFZJRVdfUEFERElORywgMClcbiAgICB2aWV3ZXJfY3R4LmxpbmVUbyhzdGF0ZS5jYW52YXNXaWR0aCAqIDAuNSAtIFZJRVdfUEFERElORywgMClcbiAgICB2aWV3ZXJfY3R4LmNsb3NlUGF0aCgpXG4gICAgdmlld2VyX2N0eC5zdHJva2UoKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5jb25zdCBzY2FsZUxlbmd0aCA9IChjYW52YXNXaWR0aCwgaW1hZ2VXaWR0aCwgc2NhbGVXaWR0aCkgPT4gY2FudmFzV2lkdGggKiBzY2FsZVdpZHRoIC8gaW1hZ2VXaWR0aFxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd1NjYWxlKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZVtcInNjYWxlV2lkdGhcIl0pIHJldHVybjtcbiAgICBsZXQgc2NhbGVQaXhlbCA9IHNjYWxlTGVuZ3RoKHN0YXRlLmNhbnZhc1dpZHRoLCBzdGF0ZS5pbWFnZVJhZGl1cyAqIDIsIHN0YXRlLnNjYWxlV2lkdGgpXG4gICAgY29uc3QgY2FudmFzV2lkdGggPSBzdGF0ZS5jYW52YXNXaWR0aDtcbiAgICBjb25zdCBzY2FsZUJhciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc2NhbGViYXJcIilcblxuXG4gICAgbGV0IHNjYWxlTnVtYmVyID0gc3RhdGUuc2NhbGVUZXh0Lm1hdGNoKC8oXFxkK1xcLj9cXGQqKS8pWzBdICogMVxuICAgIGNvbnN0IHNjYWxlVW5pdCA9IHN0YXRlLnNjYWxlVGV4dC5tYXRjaCgvXFxEKiQvKVswXVxuXG4gICAgd2hpbGUgKHNjYWxlUGl4ZWwgPj0gY2FudmFzV2lkdGgpIHtcbiAgICAgICAgc2NhbGVQaXhlbCAqPSAwLjVcbiAgICAgICAgc2NhbGVOdW1iZXIgKj0gMC41XG4gICAgfVxuICAgIHNjYWxlQmFyLnN0eWxlLndpZHRoID0gc2NhbGVQaXhlbCArIFwicHhcIjtcbiAgICBzY2FsZUJhci5xdWVyeVNlbGVjdG9yKFwiZGl2OmZpcnN0LWNoaWxkXCIpLmlubmVySFRNTCA9IGAke3NjYWxlTnVtYmVyfSAke3NjYWxlVW5pdH1gO1xuICAgIHJldHVybiBzdGF0ZVxufVxuIiwiaW1wb3J0IHsgY2xlYXJWaWV3LCBibG9iVG9DYW52YXMsIGRyYXdIYWlyTGluZSwgZHJhd1NjYWxlIH0gZnJvbSBcIi4vZHJhd19zdGF0ZV91cGRhdG9ycy5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVwZGF0ZVZpZXcoc3RhdGUpIHtcbiAgICBjbGVhclZpZXcoc3RhdGUpXG4gICAgYmxvYlRvQ2FudmFzKHN0YXRlKVxuICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICBkcmF3U2NhbGUoc3RhdGUpXG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJpbXBvcnQgdXBkYXRlVmlldyBmcm9tIFwiLi91cGRhdGVWaWV3LmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0VG9nZ2xlTmljb2xFdmVudHMoc3RhdGUpIHtcblxuICAgIGNvbnN0IHRvZ2dsZU5pY29sQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjaGFuZ2Vfbmljb2xcIilcbiAgICBjb25zdCB0b2dnbGVOaWNvbExhYmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjaGFuZ2Vfbmljb2wgKyBsYWJlbFwiKVxuXG4gICAgY29uc3QgdG9nZ2xlTmljb2xIYW5kbGVyID0gc3RhdGUgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cbiAgICAgICAgdG9nZ2xlTmljb2xCdXR0b24uY2hlY2tlZCA9IHN0YXRlLmlzQ3Jvc3NOaWNvbFxuICAgICAgICBzdGF0ZS5pc0Nyb3NzTmljb2wgPSAhc3RhdGUuaXNDcm9zc05pY29sO1xuXG5cbiAgICAgICAgcmVzKHN0YXRlKVxuICAgIH0pXG5cbiAgICB0b2dnbGVOaWNvbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIGUgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cblxuICAgIHRvZ2dsZU5pY29sTGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaFwiLFxuICAgICAgICBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdG9nZ2xlTmljb2xCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaFwiLFxuICAgICAgICBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG5cbiAgICB0b2dnbGVOaWNvbExhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2V1cFwiLFxuICAgICAgICBlID0+IHRvZ2dsZU5pY29sSGFuZGxlcihzdGF0ZSlcbiAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHRvZ2dsZU5pY29sTGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBlID0+IHRvZ2dsZU5pY29sSGFuZGxlcihzdGF0ZSlcbiAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG4gICAgICAgICAgICAudGhlbihfID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgZmFsc2VcbiAgICApXG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBNZXNzYWdlQmFyQWN0aXZpdHlTd2l0Y2hlciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZUJhclNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IobWVzc2FnZUJhclNlbGVjdG9yKVxuICAgICAgICB0aGlzLmhvb2sgPSB7fVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLmhvb2tbXCJhY3RpdmF0ZVwiXSh0aGlzLnJvb3QpXG4gICAgICAgIHRoaXMucm9vdC5jbGFzc0xpc3QucmVtb3ZlKFwiaW5hY3RpdmVcIilcbiAgICB9XG5cbiAgICBpbmFjdGl2YXRlKCkge1xuICAgICAgICB0aGlzLmhvb2tbXCJpbmFjdGl2YXRlXCJdKHRoaXMucm9vdClcbiAgICAgICAgdGhpcy5yb290LmNsYXNzTGlzdC5hZGQoXCJpbmFjdGl2ZVwiKVxuICAgIH1cblxuICAgIHNldEhvb2tPbkFjdGl2YXRlKGhvb2sgPSByb290Tm9kZSA9PiB7IH0pIHtcbiAgICAgICAgdGhpcy5ob29rW1wiYWN0aXZhdGVcIl0gPSBob29rXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgc2V0SG9va09uSW5hY3RpdmF0ZShob29rID0gcm9vdE5vZGUgPT4geyB9KSB7XG4gICAgICAgIHRoaXMuaG9va1tcImluYWN0aXZhdGVcIl0gPSBob29rXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxufVxuIiwiaW1wb3J0IE1lc3NhZ2VCYXJBY3Rpdml0eVN3aXRjaGVyIGZyb20gXCIuL01lc3NhZ2VCYXJBY3Rpdml0eVN3aXRjaGVyLmpzXCJcblxuY29uc3Qgc3dpdGNoRXJyb3JNZXNzYWdlID0gbmV3IE1lc3NhZ2VCYXJBY3Rpdml0eVN3aXRjaGVyKFxuICAgIFwiI2Vycm9yX21lc3NhZ2VfYmFyXCJcbikuc2V0SG9va09uSW5hY3RpdmF0ZShcbiAgICByb290Tm9kZSA9PiB7XG4gICAgICAgIHJvb3ROb2RlLmNsYXNzTGlzdC5yZW1vdmUoXCJtZXNzYWdlLWVycm9yXCIpXG4gICAgfVxuKVxuXG5leHBvcnQgZnVuY3Rpb24gaGlkZUVycm9yTWVzc2FnZShzdGF0ZSkge1xuICAgIHN3aXRjaEVycm9yTWVzc2FnZS5pbmFjdGl2YXRlKClcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNob3dFcnJvck1lc3NhZ2UobWVzc2FnZSkge1xuICAgIHJldHVybiAoXykgPT4ge1xuICAgICAgICBzd2l0Y2hFcnJvck1lc3NhZ2Uuc2V0SG9va09uQWN0aXZhdGUoXG4gICAgICAgICAgICByb290RE9NID0+IHtcbiAgICAgICAgICAgICAgICByb290RE9NLnF1ZXJ5U2VsZWN0b3IoXCIubWVzc2FnZV9zcGFjZVwiKS5pbm5lckhUTUwgPSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgcm9vdERPTS5jbGFzc0xpc3QuYWRkKFwibWVzc2FnZS1lcnJvclwiKVxuICAgICAgICAgICAgfVxuICAgICAgICApXG4gICAgICAgIHN3aXRjaEVycm9yTWVzc2FnZS5hY3RpdmF0ZSgpXG4gICAgICAgIHJldHVybiBfXG4gICAgfVxufVxuIiwiaW1wb3J0IE1lc3NhZ2VCYXJBY3Rpdml0eVN3aXRjaGVyIGZyb20gXCIuL01lc3NhZ2VCYXJBY3Rpdml0eVN3aXRjaGVyLmpzXCJcblxuY29uc3Qgc3dpdGNoTG9hZGluZ01lc3NhZ2UgPSBuZXcgTWVzc2FnZUJhckFjdGl2aXR5U3dpdGNoZXIoXG4gICAgXCIjbG9hZGluZ19tZXNzYWdlX2JhclwiXG4pLnNldEhvb2tPbkFjdGl2YXRlKFxuICAgIHJvb3ROb2RlID0+IHtcbiAgICAgICAgcm9vdE5vZGUucXVlcnlTZWxlY3RvcihcIi5tZXNzYWdlX3NwYWNlXCIpLmlubmVySFRNTCA9IFwiTG9hZGluZyBpbWFnZXMuLi5cIlxuICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QuYWRkKFwibWVzc2FnZS1sb2FkaW5nXCIpXG4gICAgfVxuKS5zZXRIb29rT25JbmFjdGl2YXRlKFxuICAgIHJvb3ROb2RlID0+IHtcbiAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnJlbW92ZShcIm1lc3NhZ2UtbG9hZGluZ1wiKVxuICAgIH1cbilcblxuZXhwb3J0IGNvbnN0IHNob3dMb2FkaW5nTWVzc2FnZSA9IHN0YXRlID0+IHtcbiAgICBzd2l0Y2hMb2FkaW5nTWVzc2FnZS5hY3RpdmF0ZSgpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBjb25zdCBoaWRlTG9hZGluZ01lc3NhZ2UgPSBzdGF0ZSA9PiB7XG4gICAgc3dpdGNoTG9hZGluZ01lc3NhZ2UuaW5hY3RpdmF0ZSgpXG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJcblxuZXhwb3J0IGNvbnN0IGhpZGVXZWxjb21lQm9hcmQgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgYm9hcmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3dlbGNvbWUtY2FyZFwiKVxuICAgIGJvYXJkLmNsYXNzTGlzdC5hZGQoXCJpbmFjdGl2ZVwiKTtcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IHNob3dWaWV3ZXIgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgY2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdmlld2VyX3dyYXBwZXJcIilcbiAgICBjYXJkLmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3Qgc2hvd05pY29sQnV0dG9uID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbG93LW5hdmlnYXRpb25cIilcbiAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImluYWN0aXZlXCIpO1xuICAgIHJldHVybiBzdGF0ZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2FuaXRpemVJRChpZCkge1xuICAgIHJldHVybiBpZC5yZXBsYWNlKC9cXC8vZywgXCJfXCIpLnJlcGxhY2UoL1xcLi9nLCBcIlwiKVxufVxuIiwiaWYgKCFIVE1MQ2FudmFzRWxlbWVudC5wcm90b3R5cGUudG9CbG9iKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEhUTUxDYW52YXNFbGVtZW50LnByb3RvdHlwZSwgJ3RvQmxvYicsIHtcbiAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIChjYWxsYmFjaywgdHlwZSwgcXVhbGl0eSkge1xuXG4gICAgICAgICAgICB2YXIgYmluU3RyID0gYXRvYih0aGlzLnRvRGF0YVVSTCh0eXBlLCBxdWFsaXR5KS5zcGxpdCgnLCcpWzFdKSxcbiAgICAgICAgICAgICAgICBsZW4gPSBiaW5TdHIubGVuZ3RoLFxuICAgICAgICAgICAgICAgIGFyciA9IG5ldyBVaW50OEFycmF5KGxlbik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcnJbaV0gPSBiaW5TdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY2FsbGJhY2sobmV3IEJsb2IoW2Fycl0sIHsgdHlwZTogdHlwZSB8fCAnaW1hZ2UvcG5nJyB9KSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0KGJ1ZmZlciwgZXh0KSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXG4gICAgICAgIHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIHZhciBiaW5hcnkgPSAnJztcbiAgICAgICAgdmFyIGxlbiA9IGJ5dGVzLmJ5dGVMZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgIGJpbmFyeSArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXMoYGRhdGE6aW1hZ2UvJHtleHR9O2Jhc2U2NCxgICsgd2luZG93LmJ0b2EoYmluYXJ5KSk7XG4gICAgfSlcbn1cblxuXG5leHBvcnQgZnVuY3Rpb24gYmxvYlRvQmFzZTY0KGJsb2IpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcjtcbiAgICAgICAgcmVhZGVyLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIHJlYWRlci5vbmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKHJlYWRlci5yZXN1bHQpO1xuICAgICAgICB9O1xuICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChibG9iKTtcbiAgICB9KTtcbn1cbiIsImV4cG9ydCBmdW5jdGlvbiBwcm9ncmVzc0xvYWRpbmcoc2VsZWN0b3IpIHtcbiAgICBjb25zdCBwcm9ncmVzcyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpXG4gICAgY29uc3QgYmFyID0gcHJvZ3Jlc3MucXVlcnlTZWxlY3RvcihcIi5iYXJcIilcbiAgICBiYXIuc3R5bGUud2lkdGggPSBcIjAlXCJcbiAgICBjb25zdCB0b3RhbCA9IHByb2dyZXNzLmNsaWVudFdpZHRoXG4gICAgcmV0dXJuIGUgPT4ge1xuICAgICAgICBiYXIuc3R5bGUud2lkdGggPSBgJHsoZS5sb2FkZWQgLyBlLnRvdGFsKSAqIDEwMH0lYFxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXBsZXRlTG9hZGluZyhzZWxlY3Rvcikge1xuICAgIGNvbnN0IHByb2dyZXNzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvcilcbiAgICBjb25zdCBiYXIgPSBwcm9ncmVzcy5xdWVyeVNlbGVjdG9yKFwiLmJhclwiKVxuICAgIHJldHVybiBlID0+IHtcbiAgICAgICAgYmFyLnN0eWxlLndpZHRoID0gXCIwJVwiXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgcHJvZ3Jlc3NMb2FkaW5nLCBjb21wbGV0ZUxvYWRpbmcgfSBmcm9tIFwiLi9wcm9ncmVzc19iYXJfaGFuZGxlcnMuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1bnppcHBlcih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cbiAgICAgICAgWmlwLmluZmxhdGVfZmlsZSh1cmwsIHJlcywgcmVqLCBwcm9ncmVzc0xvYWRpbmcoXCIjcHJvZ3Jlc3NfYmFyXCIpLCBjb21wbGV0ZUxvYWRpbmcoXCIjcHJvZ3Jlc3NfYmFyXCIpKVxuICAgIH0pXG59XG4iLCJpbXBvcnQgeyBidWZmZXJUb0Jhc2U2NCB9IGZyb20gXCIuL2RhdGFfdHJhbnNsYXRlcnMuanNcIlxuXG4vKipcbiAqXG4gKiBAcGFyYW0geyp9IHppcFxuICogQHJldHVybiB7T2JqZWN0W21ldGEsemlwXX1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gZXh0cmFjdEZpbGUoemlwQnl0ZSkge1xuICAgIGNvbnN0IHppcCA9IFppcC5pbmZsYXRlKHppcEJ5dGUpXG4gICAgY29uc3QgaW5mbGF0ZWRfemlwID0ge31cbiAgICBhd2FpdCBQcm9taXNlLmFsbChPYmplY3QuZW50cmllcyh6aXAuZmlsZXMpLm1hcChhc3luYyBrdiA9PiB7XG4gICAgICAgIGlmIChrdlswXS5pbmNsdWRlcyhcIi5qc29uXCIpKSB7XG4gICAgICAgICAgICBpbmZsYXRlZF96aXBba3ZbMF1dID0ga3ZbMV0uaW5mbGF0ZSgpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0ga3ZbMF0ubWF0Y2goLy4qXFwuKFxcdyspJC8pWzFdXG4gICAgICAgICAgICBjb25zdCBiYXNlNjQgPSBhd2FpdCBidWZmZXJUb0Jhc2U2NChrdlsxXS5pbmZsYXRlKCksIHR5cGUpXG4gICAgICAgICAgICBjb25zdCBtaW1lID0gYmFzZTY0Lm1hdGNoKC9eZGF0YTooaW1hZ2VcXC9cXHcrKTsvKVsxXVxuICAgICAgICAgICAgY29uc3QgbWltZV90eXBlID0gbWltZS5zcGxpdChcIi9cIilbMV1cblxuICAgICAgICAgICAgY29uc3QgbmV3X2ZpbGVfbmFtZSA9IGt2WzBdLnNwbGl0KFwiLlwiKVswXSArIFwiLlwiICsgbWltZV90eXBlXG5cbiAgICAgICAgICAgIGluZmxhdGVkX3ppcFtuZXdfZmlsZV9uYW1lXSA9IGJhc2U2NFxuXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pKVxuXG4gICAgcmV0dXJuIGluZmxhdGVkX3ppcFxufVxuIiwiaW1wb3J0IHsgc3RhdGljU2V0dGluZ3MgfSBmcm9tIFwiLi9jb25maWcvY29uZmlnLmpzXCJcbmltcG9ydCBzYW5pdGl6ZUlEIGZyb20gXCIuL3Nhbml0aXplSUQuanNcIlxuaW1wb3J0IHsgYmxvYlRvQmFzZTY0IH0gZnJvbSBcIi4vZGF0YV90cmFuc2xhdGVycy5qc1wiXG5pbXBvcnQgdW56aXBwZXIgZnJvbSBcIi4vdW56aXBwZXIuanNcIlxuaW1wb3J0IGV4dHJhY3RGaWxlIGZyb20gXCIuL2V4dHJhY3RGaWxlLmpzXCJcblxuLyoqXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHJldHVybiB7QXJyYXlbU3RyaW5nLCBCb29sZWFuXX0gW2xhc3RNb2RpZmllZCwgbmV0d29ya0Rpc2Nvbm5lY3RlZF1cbiAqL1xuYXN5bmMgZnVuY3Rpb24gcXVlcnlMYXN0TW9kaWZpZWQodXJsKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgaGVhZGVyID0gYXdhaXQgZmV0Y2godXJsLCB7IG1ldGhvZDogJ0hFQUQnLCBtb2RlOiAnY29ycycgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhcIlBhY2thZ2UgbWV0YWRhdGEgY2Fubm90IGJlIGZldGNoZWQuXCIpXG4gICAgICAgICAgICB0aHJvdyBFcnJvcihlKVxuICAgICAgICB9KVxuICAgICAgICB2YXIgbGFzdE1vZGlmaWVkID0gaGVhZGVyLmhlYWRlcnMuZ2V0KFwibGFzdC1tb2RpZmllZFwiKVxuICAgICAgICB2YXIgbmV0d29ya0Rpc2Nvbm5lY3RlZCA9IGZhbHNlXG4gICAgICAgIHJldHVybiBbbGFzdE1vZGlmaWVkLCBuZXR3b3JrRGlzY29ubmVjdGVkXVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgdmFyIGxhc3RNb2RpZmllZCA9IFwibm9uZVwiXG4gICAgICAgIHZhciBuZXR3b3JrRGlzY29ubmVjdGVkID0gdHJ1ZVxuICAgICAgICByZXR1cm4gW2xhc3RNb2RpZmllZCwgbmV0d29ya0Rpc2Nvbm5lY3RlZF1cbiAgICB9XG59XG5cbmNsYXNzIEFkaG9jUGFja2FnZVJlcG8ge1xuICAgIGNvbnN0cnVjdG9yKHN0YXRlKSB7XG4gICAgICAgIHRoaXMuc3RhdGUgPSBzdGF0ZVxuICAgIH1cblxuICAgIHJlc29sdmVJbWFnZVBhY2thZ2UocGFja2FnZUlkLCBkZXNpcmVkRm9ybWF0LCBtYW5pZmVzdCkge1xuICAgICAgICBmdW5jdGlvbiBzZWxlY3RGb3JtYXRXaXRoRmFsbGJhY2tUb0pwZyhsaXN0LCBmb3JtYXQpIHtcbiAgICAgICAgICAgIGlmIChsaXN0LmluY2x1ZGVzKGZvcm1hdCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBcImpwZ1wiXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZm9ybWF0ID0gbWFuaWZlc3QuaGFzT3duUHJvcGVydHkoJ2ltYWdlX2Zvcm1hdHMnKSAmJiBtYW5pZmVzdFtcImltYWdlX2Zvcm1hdHNcIl0gIT0gbnVsbFxuICAgICAgICAgICAgPyBzZWxlY3RGb3JtYXRXaXRoRmFsbGJhY2tUb0pwZyhtYW5pZmVzdC5pbWFnZV9mb3JtYXRzLCBkZXNpcmVkRm9ybWF0KVxuICAgICAgICAgICAgOiBkZXNpcmVkRm9ybWF0XG4gICAgICAgIGNvbnNvbGUubG9nKGZvcm1hdClcbiAgICAgICAgcmV0dXJuIFtzdGF0aWNTZXR0aW5ncy5nZXRJbWFnZURhdGFQYXRoKHBhY2thZ2VJZCkgKyBmb3JtYXQgKyBcIi56aXBcIiwgZm9ybWF0XVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBwYWNrYWdlSWRcbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZX1cbiAgICAgKiAgICAgemlwOiBPYmplY3Q8U3RyaW5nLCBJbWFnZSBCbG9iPlxuICAgICAqL1xuICAgIGFzeW5jIHJldHJpZXZlKHBhY2thZ2VJZCwgZGVzaXJlZEZvcm1hdCkge1xuICAgICAgICBjb25zdCBtYW5pZmVzdFVybCA9IHN0YXRpY1NldHRpbmdzLmdldEltYWdlRGF0YVBhdGgocGFja2FnZUlkKSArIFwibWFuaWZlc3QuanNvblwiO1xuICAgICAgICBjb25zdCBvcGVuX3RodW1ibmFpbFVybCA9IHN0YXRpY1NldHRpbmdzLmdldEltYWdlRGF0YVBhdGgocGFja2FnZUlkKSArIFwibzEuanBnXCI7XG4gICAgICAgIGNvbnN0IGNyb3NzX3RodW1ibmFpbFVybCA9IHN0YXRpY1NldHRpbmdzLmdldEltYWdlRGF0YVBhdGgocGFja2FnZUlkKSArIFwiYzEuanBnXCI7XG4gICAgICAgIGNvbnN0IG1hbmlmZXN0VGV4dCA9IGF3YWl0IGZldGNoKG1hbmlmZXN0VXJsLCB7IG1vZGU6ICdjb3JzJyB9KS50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLnRleHQoKSlcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKG1hbmlmZXN0VGV4dCk7XG5cbiAgICAgICAgY29uc3QgW3ppcFVybCwgZm9ybWF0XSA9IHRoaXMucmVzb2x2ZUltYWdlUGFja2FnZShwYWNrYWdlSWQsIGRlc2lyZWRGb3JtYXQsIG1hbmlmZXN0KVxuICAgICAgICBjb25zdCBbbGFzdE1vZGlmaWVkLCBfXSA9IGF3YWl0IHF1ZXJ5TGFzdE1vZGlmaWVkKHppcFVybClcbiAgICAgICAgY29uc3QgdW56aXBwZWQgPSBhc3luYyAoKSA9PiB1bnppcHBlcih6aXBVcmwpLnRoZW4oZXh0cmFjdEZpbGUpXG5cbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICBtYW5pZmVzdDogbWFuaWZlc3RUZXh0LFxuICAgICAgICAgICAgdGh1bWJuYWlsOiB7XG4gICAgICAgICAgICAgICAgXCJvMS5qcGdcIjogYXdhaXQgZmV0Y2gob3Blbl90aHVtYm5haWxVcmwsIHsgbW9kZTogJ2NvcnMnIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJsb2IoKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oYmxvYlRvQmFzZTY0KSxcbiAgICAgICAgICAgICAgICBcImMxLmpwZ1wiOiBhd2FpdCBmZXRjaChjcm9zc190aHVtYm5haWxVcmwsIHsgbW9kZTogJ2NvcnMnIH0pXG4gICAgICAgICAgICAgICAgICAgIC50aGVuKHJlc3BvbnNlID0+IHJlc3BvbnNlLmJsb2IoKSlcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oYmxvYlRvQmFzZTY0KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhc3RNb2RpZmllZDogbGFzdE1vZGlmaWVkLFxuICAgICAgICAgICAgaWQ6IHBhY2thZ2VJZCxcbiAgICAgICAgICAgIHppcDogdW56aXBwZWQsXG4gICAgICAgICAgICBpbWFnZV9mb3JtYXQ6IGZvcm1hdFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXNwb25zZVxuICAgIH1cblxuICAgIGFzeW5jIGdldEltYWdlc0xhc3RNb2RpZmllZChwYWNrYWdlSWQsIGRlc2lyZWRGb3JtYXQpIHtcbiAgICAgICAgY29uc3QgbWFuaWZlc3RVcmwgPSBzdGF0aWNTZXR0aW5ncy5nZXRJbWFnZURhdGFQYXRoKHBhY2thZ2VJZCkgKyBcIm1hbmlmZXN0Lmpzb25cIjtcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBhd2FpdCBmZXRjaChtYW5pZmVzdFVybCwgeyBtb2RlOiAnY29ycycgfSkudGhlbihyZXNwb25zZSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgIGNvbnN0IFt6aXBVcmwsIF9dID0gdGhpcy5yZXNvbHZlSW1hZ2VQYWNrYWdlKHBhY2thZ2VJZCwgZGVzaXJlZEZvcm1hdCwgbWFuaWZlc3QpXG4gICAgICAgIGNvbnN0IFtsYXN0TW9kaWZpZWQsIG5ldHdvcmtEaXNjb25uZWN0ZWRdID0gYXdhaXQgcXVlcnlMYXN0TW9kaWZpZWQoemlwVXJsKVxuICAgICAgICByZXR1cm4gW2xhc3RNb2RpZmllZCwgbmV0d29ya0Rpc2Nvbm5lY3RlZF1cbiAgICB9XG59XG5cbi8qKlxuICog5oyH5a6a44GX44Gfa2V544Gu44OH44O844K/44GMRELjga7kuK3jgavjgYLjgovloLTlkIgsIERC44GL44KJ44OH44O844K/44KS5Y+W5b6X44GZ44KLLlxuICog44K144O844OQ44GoRELjgafjg4fjg7zjgr/jga7mnIDntYLmm7TmlrDmmYLliLvjgYzkuIDoh7TjgZnjgozjgbAsXG4gKiAgRELjga7jg4fjg7zjgr/jgpLov5TjgZkuXG4gKiDjg43jg4Pjg4jjg6/jg7zjgq/jgqjjg6njg7zjga7loLTlkIgsIERC44Gu44OH44O844K/44GL54Sh44KS6L+U44GZXG4gKlxuICog44Gd44GG44Gn44Gq44GR44KM44Gw44K144O844OQ44GL44KJbWFuaWZlc3Tjgah0aHVtYm5haWzjgpLlj5blvpfjgZfjgabov5TjgZkuXG4gKiDjgb7jgZ8sIOeUu+WDj+acrOS9k+OBrnppcOODleOCoeOCpOODq+OCkmZldGNo44GZ44KL44Ki44Kv44K344On44Oz44KS6LW344GT44GZ6Zai5pWw44KS6L+U44GZLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZVxuICogQHBhcmFtIHtTdHJpbmd9IHBhY2thZ2VOYW1lXG4gKiBAcmV0dXJuIHtBcnJheVtPYmplY3QsQm9vbGVhbl19IFtyZXNwb25zZSwgdG9CZVN0b3JlZF1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gcXVlcnlJbWFnZVBhY2thZ2UoXG4gICAgc3RhdGUsXG4gICAgcGFja2FnZU5hbWVcbikge1xuICAgIGNvbnN0IGlkID0gc2FuaXRpemVJRChwYWNrYWdlTmFtZSlcbiAgICBjb25zdCBzdG9yZWREYXRhID0gYXdhaXQgc3RhdGUuemlwREJIYW5kbGVyLmdldChzdGF0ZS56aXBEQiwgaWQpXG4gICAgY29uc3QgcmVwbyA9IG5ldyBBZGhvY1BhY2thZ2VSZXBvKHN0YXRlKVxuICAgIGNvbnN0IFtsYXN0TW9kaWZpZWQsIG5ldHdvcmtEaXNjb25uZWN0ZWRdID0gYXdhaXQgcmVwby5nZXRJbWFnZXNMYXN0TW9kaWZpZWQoaWQsIHN0YXRlLnN1cHBvcnRlZEltYWdlVHlwZSlcblxuICAgIGlmIChzdG9yZWREYXRhICE9PSB1bmRlZmluZWQgJiYgc3RvcmVkRGF0YS5sYXN0TW9kaWZpZWQgPT09IGxhc3RNb2RpZmllZCkge1xuICAgICAgICB2YXIgdG9CZVN0b3JlZCA9IGZhbHNlXG4gICAgICAgIHJldHVybiBbc3RvcmVkRGF0YSwgdG9CZVN0b3JlZF1cbiAgICB9XG4gICAgaWYgKG5ldHdvcmtEaXNjb25uZWN0ZWQpIHtcbiAgICAgICAgaWYgKHN0b3JlZERhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdmFyIHRvQmVTdG9yZWQgPSBmYWxzZVxuICAgICAgICAgICAgcmV0dXJuIFtzdG9yZWREYXRhLCB0b0JlU3RvcmVkXVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtudWxsLCBmYWxzZV1cbiAgICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmVwby5yZXRyaWV2ZShpZCwgc3RhdGUuc3VwcG9ydGVkSW1hZ2VUeXBlKVxuICAgICAgICB2YXIgdG9CZVN0b3JlZCA9IHRydWVcbiAgICAgICAgcmV0dXJuIFtyZXNwb25zZSwgdG9CZVN0b3JlZF1cbiAgICB9XG59XG4iLCJpbXBvcnQgc2FuaXRpemVJRCBmcm9tIFwiLi9zYW5pdGl6ZUlELmpzXCJcbmltcG9ydCB7IGN5Y2xlQnksIHN0ZXBCeSB9IGZyb20gXCIuL3JvdGF0aW9uX2RlZ3JlZV9oYW5kbGVycy5qc1wiXG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uQ2VudGVyKG1ldGEpIHtcbiAgICByZXR1cm4gKG1ldGEuaGFzT3duUHJvcGVydHkoXCJyb3RhdGVfY2VudGVyXCIpKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIFwidG9fcmlnaHRcIjogbWV0YS5yb3RhdGVfY2VudGVyWzBdLFxuICAgICAgICAgICAgXCJ0b19ib3R0b21cIjogbWV0YS5yb3RhdGVfY2VudGVyWzFdXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBcInRvX3JpZ2h0XCI6IG1ldGEuaW1hZ2Vfd2lkdGggKiAwLjUsXG4gICAgICAgICAgICBcInRvX2JvdHRvbVwiOiBtZXRhLmltYWdlX2hlaWdodCAqIDAuNVxuICAgICAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlUmFkaXVzKG1ldGEpIHtcbiAgICBjb25zdCBzaGlmdCA9IGdldFJvdGF0aW9uQ2VudGVyKG1ldGEpO1xuICAgIGNvbnN0IGltYWdlX2NlbnRlciA9IHtcbiAgICAgICAgXCJ4XCI6IG1ldGEuaW1hZ2Vfd2lkdGggKiAwLjUsXG4gICAgICAgIFwieVwiOiBtZXRhLmltYWdlX2hlaWdodCAqIDAuNVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICAgIGltYWdlX2NlbnRlci54IC0gTWF0aC5hYnMoaW1hZ2VfY2VudGVyLnggLSBzaGlmdC50b19yaWdodCksXG4gICAgICAgIGltYWdlX2NlbnRlci55IC0gTWF0aC5hYnMoaW1hZ2VfY2VudGVyLnkgLSBzaGlmdC50b19ib3R0b20pXG4gICAgKVxufVxuXG5mdW5jdGlvbiBtYXBNZXRhZGF0YShtZXRhKSB7XG4gICAgY29uc3Qgcm90YXRlX2RlZ3JlZV9zdGVwID0gcGFyc2VJbnQobWV0YS5yb3RhdGVfYnlfZGVncmVlKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNDbG9ja3dpc2U6IG1ldGEucm90YXRlX2Nsb2Nrd2lzZSxcbiAgICAgICAgbG9jYXRpb246IG1ldGEubG9jYXRpb24sXG4gICAgICAgIHJvY2tUeXBlOiBtZXRhLnJvY2tfdHlwZSxcbiAgICAgICAgb3duZXI6IG1ldGEub3duZXIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtZXRhLmhhc093blByb3BlcnR5KFwiZGlzY3JpcHRpb25cIilcbiAgICAgICAgICAgID8gbWV0YS5kaXNjcmlwdGlvblxuICAgICAgICAgICAgOiBtZXRhLmhhc093blByb3BlcnR5KFwiZGVzY3JpcHRpb25cIilcbiAgICAgICAgICAgICAgICA/IG1ldGEuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICByb3RhdGVfY2VudGVyOiBnZXRSb3RhdGlvbkNlbnRlcihtZXRhKSxcbiAgICAgICAgaW1hZ2VXaWR0aDogbWV0YS5pbWFnZV93aWR0aCxcbiAgICAgICAgaW1hZ2VIZWlnaHQ6IG1ldGEuaW1hZ2VfaGVpZ2h0LFxuICAgICAgICBpbWFnZVJhZGl1czogZ2V0SW1hZ2VSYWRpdXMobWV0YSksXG4gICAgICAgIGltYWdlUmFkaXVzT3JpZ2luYWw6IGdldEltYWdlUmFkaXVzKG1ldGEpLFxuICAgICAgICBzY2FsZVdpZHRoOiBtZXRhLmhhc093blByb3BlcnR5KFwic2NhbGUtcGl4ZWxcIilcbiAgICAgICAgICAgID8gcGFyc2VJbnQobWV0YVtcInNjYWxlLXBpeGVsXCJdKVxuICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgc2NhbGVUZXh0OiBtZXRhLmhhc093blByb3BlcnR5KFwic2NhbGUtdW5pdFwiKVxuICAgICAgICAgICAgPyBtZXRhW1wic2NhbGUtdW5pdFwiXVxuICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgcm90YXRlX2RlZ3JlZV9zdGVwOiByb3RhdGVfZGVncmVlX3N0ZXBcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlQnlNZXRhKHN0YXRlKSB7XG4gICAgcmV0dXJuIChjb250YWlub3JJRCwgbWV0YSkgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cbiAgICAgICAgc3RhdGUuY29udGFpbm9ySUQgPSBzYW5pdGl6ZUlEKGNvbnRhaW5vcklEKTtcblxuICAgICAgICBjb25zdCByb3RhdGVfZGVncmVlX3N0ZXAgPSBwYXJzZUludChtZXRhLnJvdGF0ZV9ieV9kZWdyZWUpXG4gICAgICAgIGNvbnN0IGN5Y2xlX2RlZ3JlZSA9IG1ldGEuaGFzT3duUHJvcGVydHkoXCJjeWNsZV9yb3RhdGVfZGVncmVlXCIpXG4gICAgICAgICAgICA/IHBhcnNlSW50KG1ldGEuY3ljbGVfcm90YXRlX2RlZ3JlZSlcbiAgICAgICAgICAgIDogOTA7XG4gICAgICAgIGNvbnN0IGltYWdlX251bWJlciA9IGN5Y2xlX2RlZ3JlZSAvIHJvdGF0ZV9kZWdyZWVfc3RlcCArIDFcbiAgICAgICAgY29uc3QgbWlycm9yX2F0ID0gKGltYWdlX251bWJlciAtIDEpXG4gICAgICAgIGNvbnN0IHRvdGFsX3N0ZXAgPSAoaW1hZ2VfbnVtYmVyIC0gMSkgKiAyXG5cbiAgICAgICAgc3RhdGUuaW1hZ2VfbnVtYmVyID0gaW1hZ2VfbnVtYmVyXG4gICAgICAgIHN0YXRlLmdldEltYWdlTnVtYmVyID0gY3ljbGVfZGVncmVlID4gMFxuICAgICAgICAgICAgPyBkZWdyZWUgPT4gY3ljbGVCeShpbWFnZV9udW1iZXIgLSAxKShcbiAgICAgICAgICAgICAgICBzdGVwQnkocm90YXRlX2RlZ3JlZV9zdGVwKShzdGF0ZS5pc0Nsb2Nrd2lzZSA/IDM2MCAtIGRlZ3JlZSA6IGRlZ3JlZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogZGVncmVlID0+IG1pcnJvckJ5KG1pcnJvcl9hdCkoXG4gICAgICAgICAgICAgICAgY3ljbGVCeSh0b3RhbF9zdGVwKShcbiAgICAgICAgICAgICAgICAgICAgc3RlcEJ5KHJvdGF0ZV9kZWdyZWVfc3RlcCkoZGVncmVlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcblxuICAgICAgICBzdGF0ZS5nZXRBbHBoYSA9IGRlZ3JlZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBudGggPSBjeWNsZUJ5KHRvdGFsX3N0ZXAgKiAyKShcbiAgICAgICAgICAgICAgICBzdGVwQnkocm90YXRlX2RlZ3JlZV9zdGVwKShkZWdyZWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gMSAtIChkZWdyZWUgLSByb3RhdGVfZGVncmVlX3N0ZXAgKiBudGgpIC8gcm90YXRlX2RlZ3JlZV9zdGVwXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5vcGVuX2ltYWdlcyA9IFtdXG4gICAgICAgIHN0YXRlLmNyb3NzX2ltYWdlcyA9IFtdXG5cbiAgICAgICAgc3RhdGUucm90YXRlID0gMDtcblxuICAgICAgICBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oc3RhdGUsIG1hcE1ldGFkYXRhKG1ldGEpKVxuXG4gICAgICAgIHJlcyhzdGF0ZSlcbiAgICB9KVxufVxuIiwiLyoqXG4gKlxuICogQHBhcmFtIHtTdHJpbmcsT2JqZWN0W1N0cmluZyxTdHJpbmddfSBtdWx0aUxhbmd1YWdlVGV4dE9ialxuICogQHJldHVybiB7U3RyaW5nfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZWxlY3RGcm9tTXVsdGlMYW5ndWFnZShtdWx0aUxhbmd1YWdlVGV4dE9iaiwgbGFuZ3VhZ2VDb2RlKSB7XG4gICAgaWYgKHR5cGVvZiAobXVsdGlMYW5ndWFnZVRleHRPYmopID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBtdWx0aUxhbmd1YWdlVGV4dE9ialxuICAgIH0gZWxzZSBpZiAodHlwZW9mIChtdWx0aUxhbmd1YWdlVGV4dE9iaikgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgaWYgKG11bHRpTGFuZ3VhZ2VUZXh0T2JqLmhhc093blByb3BlcnR5KGxhbmd1YWdlQ29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBtdWx0aUxhbmd1YWdlVGV4dE9ialtsYW5ndWFnZUNvZGVdXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMobXVsdGlMYW5ndWFnZVRleHRPYmopXG4gICAgICAgICAgICByZXR1cm4gKGtleXMubGVuZ3RoID4gMClcbiAgICAgICAgICAgICAgICA/IG11bHRpTGFuZ3VhZ2VUZXh0T2JqW2tleXNbMF1dXG4gICAgICAgICAgICAgICAgOiBcIlwiXG4gICAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXCJcIlxuICAgIH1cbn1cbiIsImltcG9ydCBzZWxlY3RGcm9tTXVsdGlMYW5ndWFnZSBmcm9tIFwiLi9zZWxlY3RGcm9tTXVsdGlMYW5ndWFnZS5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVwZGF0ZVZpZXdEZXNjcmlwdGlvbihzdGF0ZSkge1xuICAgIGNvbnN0IGRlc2NyaXB0aW9uQm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN2aWV3X2Rlc2NyaXB0aW9uXCIpXG4gICAgY29uc3QgbGFuZyA9IHN0YXRlLmxhbmd1YWdlXG5cbiAgICBjb25zdCByb2NrRnJvbSA9IGAke3NlbGVjdEZyb21NdWx0aUxhbmd1YWdlKHN0YXRlLnJvY2tUeXBlLCBsYW5nKX0gJHtzdGF0ZS5sb2NhdGlvbiA/IFwiKFwiICsgc2VsZWN0RnJvbU11bHRpTGFuZ3VhZ2Uoc3RhdGUubG9jYXRpb24sIGxhbmcpICsgXCIpXCIgOiBcIlwifWBcbiAgICBjb25zdCByb2NrRGlzYyA9IHNlbGVjdEZyb21NdWx0aUxhbmd1YWdlKHN0YXRlLmRlc2NyaXB0aW9uLCBsYW5nKVxuICAgIGNvbnN0IHJvY2tPd25lciA9IHNlbGVjdEZyb21NdWx0aUxhbmd1YWdlKHN0YXRlLm93bmVyLCBsYW5nKVxuXG4gICAgY29uc3QgdGV4dFRlbXBsYXRlID0gYDx1bCBzdHlsZT1cImxpc3Qtc3R5bGUtdHlwZTpub25lO1wiPlxuICAgICAgICAgICAgPGxpPiR7cm9ja0Zyb219PC9saT5cbiAgICAgICAgICAgIDxsaT4ke3JvY2tEaXNjfTwvbGk+XG4gICAgICAgICAgICA8bGk+JHtyb2NrT3duZXJ9PC9saT5cbiAgICAgICAgPC91bD5gXG5cbiAgICBkZXNjcmlwdGlvbkJveC5pbm5lckhUTUwgPSB0ZXh0VGVtcGxhdGU7XG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRPcGVuQW5kQ3Jvc3NJbWFnZXMoc3RhdGUpIHtcbiAgICByZXR1cm4gaW1nU2V0cyA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgc3RhdGUub3Blbl9pbWFnZXMgPSBpbWdTZXRzLm9wZW5cbiAgICAgICAgc3RhdGUuY3Jvc3NfaW1hZ2VzID0gaW1nU2V0cy5jcm9zc1xuICAgICAgICByZXMoc3RhdGUpXG4gICAgfSlcbn1cbiIsImZ1bmN0aW9uIGhhbmRsZUltZ1NyYyhzcmMpIHtcbiAgICBpZiAoc3JjIGluc3RhbmNlb2YgQmxvYikge1xuICAgICAgICBjb25zdCB1cmwgPSB3aW5kb3cuVVJMIHx8IHdpbmRvdy53ZWJraXRVUkw7XG4gICAgICAgIHJldHVybiB1cmwuY3JlYXRlT2JqZWN0VVJMKHNyYylcbiAgICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFN0cmluZykge1xuICAgICAgICByZXR1cm4gc3JjXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHNyY1xuICAgIH1cbn1cblxuLyoqXG4gKiBAcGFyYW1ldGVyIHNyYyB7ZGF0YVVSTH1cbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9hZEltYWdlU3JjKHNyYykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblxuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuXG4gICAgICAgIGltZy5vbmxvYWQgPSBfID0+IHtcbiAgICAgICAgICAgIGltZy5vbm5lcnJvciA9IG51bGw7XG4gICAgICAgICAgICByZXMoaW1nKVxuICAgICAgICB9XG4gICAgICAgIGltZy5vbmVycm9yID0gZSA9PiB7XG4gICAgICAgICAgICByZXMoaW1nKVxuICAgICAgICB9XG5cbiAgICAgICAgaW1nLnNyYyA9IGhhbmRsZUltZ1NyYyhzcmMpXG4gICAgfSlcbn1cbiIsImltcG9ydCBzZXRPcGVuQW5kQ3Jvc3NJbWFnZXMgZnJvbSBcIi4vc2V0T3BlbkFuZENyb3NzSW1hZ2VzLmpzXCJcbmltcG9ydCBsb2FkSW1hZ2VTcmMgZnJvbSBcIi4vbG9hZEltYWdlU3JjLmpzXCJcblxuZnVuY3Rpb24gc2VsZWN0SW1hZ2VJbkNvbnRhaW5vcihjb250YWlub3IsIHByZWZpeCkge1xuICAgIGlmIChwcmVmaXggaW4gY29udGFpbm9yKSB7XG4gICAgICAgIHJldHVybiBjb250YWlub3JbcHJlZml4XVxuICAgIH1cbiAgICByZXR1cm4gXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsaVZCT1J3MEtHZ29BQUFBTlNVaEVVZ0FBQUFFQUFBQUJDQVFBQUFDMUhBd0NBQUFBQzBsRVFWUUkxMk5nWUFBQUFBTUFBU0RWbE1jQUFBQUFTVVZPUks1Q1lJST1cIlxufVxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGVJbWFnZVNyYyhpbWFnZXNNYXAsIGV4dCkge1xuICAgIHJldHVybiAoc3RhdGUpID0+IG5ldyBQcm9taXNlKGFzeW5jIChyZXMsIHJlaikgPT4ge1xuXG4gICAgICAgIFByb21pc2UuYWxsKFtcbiAgICAgICAgICAgIFByb21pc2UuYWxsKEFycmF5KHN0YXRlLmltYWdlX251bWJlciAtIDEpLmZpbGwoMClcbiAgICAgICAgICAgICAgICAubWFwKChfLCBpKSA9PiBzZWxlY3RJbWFnZUluQ29udGFpbm9yKGltYWdlc01hcCwgYG8ke2kgKyAxfS4ke2V4dH1gKSlcbiAgICAgICAgICAgICAgICAubWFwKGxvYWRJbWFnZVNyYylcbiAgICAgICAgICAgICksXG4gICAgICAgICAgICBQcm9taXNlLmFsbChBcnJheShzdGF0ZS5pbWFnZV9udW1iZXIgLSAxKS5maWxsKDApXG4gICAgICAgICAgICAgICAgLm1hcCgoXywgaSkgPT4gc2VsZWN0SW1hZ2VJbkNvbnRhaW5vcihpbWFnZXNNYXAsIGBjJHtpICsgMX0uJHtleHR9YCkpXG4gICAgICAgICAgICAgICAgLm1hcChsb2FkSW1hZ2VTcmMpXG4gICAgICAgICAgICApXG4gICAgICAgIF0pLnRoZW4oaW1nRE9NcyA9PiB7XG4gICAgICAgICAgICBjb25zdCBvcGVuX2ltZ3MgPSBpbWdET01zWzBdXG5cbiAgICAgICAgICAgIGNvbnN0IGNyb3NzX2ltZ3MgPSBpbWdET01zWzFdXG5cbiAgICAgICAgICAgIHJldHVybiB7IG9wZW46IG9wZW5faW1ncywgY3Jvc3M6IGNyb3NzX2ltZ3MgfVxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oc2V0T3BlbkFuZENyb3NzSW1hZ2VzKHN0YXRlKSlcbiAgICAgICAgICAgIC50aGVuKHJlcylcbiAgICB9KVxufVxuIiwiLyoqXG4gKlxuICogQHBhcmFtIHsqfSBzdGF0ZVxuICogQHBhcmFtIHsqfSBrZXlcbiAqIEByZXR1cm4ge09iamVjdFttZXRhLHppcF19XG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlZ2lzdGVyWmlwKHN0YXRlKSB7XG4gICAgcmV0dXJuIGFzeW5jIChlbnRyeSkgPT4ge1xuXG4gICAgICAgIGNvbnN0IG5ld09uZSA9IGF3YWl0IHN0YXRlLnppcERCSGFuZGxlci5wdXQoc3RhdGUuemlwREIsIGVudHJ5KVxuXG4gICAgICAgIHN0YXRlLnN0b3JlZEtleXMucHVzaChlbnRyeS5pZClcblxuICAgICAgICBpZiAoc3RhdGUuc3RvcmVkS2V5cy5sZW5ndGggPiAyMCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkZXN0ID0gc3RhdGUuc3RvcmVkS2V5cy5zaGlmdCgpXG4gICAgICAgICAgICBjb25zdCBkZWxldGVkID0gYXdhaXQgc3RhdGUuemlwREJIYW5kbGVyLmRlbGV0ZShzdGF0ZS56aXBEQiwgb2xkZXN0KVxuICAgICAgICAgICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKGAjcm9ja19zZWxlY3Rvcj5vcHRpb25bdmFsdWU9JHtvbGRlc3R9XWApKS5mb3JFYWNoKG9wdGlvbiA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb24uaW5uZXJIVE1MLnJlcGxhY2UoXCLinJMgXCIsIFwiXCIpXG4gICAgICAgICAgICAgICAgb3B0aW9uLmlubmVySFRNTCA9IGxhYmVsXG4gICAgICAgICAgICAgICAgb3B0aW9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb3dubG9hZGVkXCIpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHN0YXRlXG4gICAgfVxufVxuIiwiaW1wb3J0IHJlZ2lzdGVyWmlwIGZyb20gXCIuL3JlZ2lzdGVyWmlwLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmVnaXN0ZXIoc3RhdGUsIGlzTmV3RGF0YSkge1xuICAgIGlmIChpc05ld0RhdGEpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5ID0+IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgcmVnaXN0ZXJaaXAoc3RhdGUpKGVudHJ5KVxuICAgICAgICAgICAgICAgIC50aGVuKHJlcylcbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gXyA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIHJlcyhzdGF0ZSlcbiAgICAgICAgfSlcbiAgICB9XG59XG4iLCIvKipcbiAqXG4gKiBAcGFyYW0geyp9IHBhY2thZ2VOYW1lXG4gKiBAcmV0dXJuIHtPYmplY3RbbWV0YSx6aXBdfVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBtYXJrRG93bmxvYWRlZE9wdGlvbihwYWNrYWdlTmFtZSkge1xuICAgIHJldHVybiBtYW5pZmVzdCA9PiBfID0+IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoYCNyb2NrX3NlbGVjdG9yPm9wdGlvblt2YWx1ZT0ke3BhY2thZ2VOYW1lfV1gKSkuZm9yRWFjaChvcHRpb24gPT4ge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBvcHRpb24uaW5uZXJIVE1MLnJlcGxhY2UoXCLinJMgXCIsIFwiXCIpXG4gICAgICAgICAgICBvcHRpb24uaW5uZXJIVE1MID0gXCLinJMgXCIgKyBsYWJlbFxuICAgICAgICAgICAgb3B0aW9uLmNsYXNzTGlzdC5hZGQoXCJkb3dubG9hZGVkXCIpXG4gICAgICAgIH0pXG4gICAgICAgIHJlcyhfKVxuICAgIH0pXG59XG4iLCJpbXBvcnQgeyBoaWRlRXJyb3JNZXNzYWdlIH0gZnJvbSBcIi4vZXJyb3JfaW5kaWNhdG9yX2hhbmRsZXIuanNcIlxuaW1wb3J0IHsgc2hvd0xvYWRpbmdNZXNzYWdlIH0gZnJvbSBcIi4vbG9hZGluZ19pbmRpY2F0b3JfaGFuZGxlci5qc1wiXG5pbXBvcnQgeyBoaWRlV2VsY29tZUJvYXJkLCBzaG93Vmlld2VyLCBzaG93Tmljb2xCdXR0b24gfSBmcm9tIFwiLi92aWV3ZXJfaGFuZGxlcnMuanNcIlxuaW1wb3J0IHF1ZXJ5SW1hZ2VQYWNrYWdlIGZyb20gXCIuL3F1ZXJ5SW1hZ2VQYWNrYWdlLmpzXCJcbmltcG9ydCB1cGRhdGVTdGF0ZUJ5TWV0YSBmcm9tIFwiLi91cGRhdGVTdGF0ZUJ5TWV0YS5qc1wiXG5pbXBvcnQgdXBkYXRlVmlld0Rlc2NyaXB0aW9uIGZyb20gXCIuL3VwZGF0ZVZpZXdEZXNjcmlwdGlvbi5qc1wiXG5pbXBvcnQgdXBkYXRlSW1hZ2VTcmMgZnJvbSBcIi4vdXBkYXRlSW1hZ2VTcmMuanNcIlxuaW1wb3J0IHJlZ2lzdGVyIGZyb20gXCIuL3JlZ2lzdGVyLmpzXCJcbmltcG9ydCBtYXJrRG93bmxvYWRlZE9wdGlvbiBmcm9tIFwiLi9tYXJrRG93bmxvYWRlZE9wdGlvbi5qc1wiXG5pbXBvcnQgdXBkYXRlVmlldyBmcm9tIFwiLi91cGRhdGVWaWV3LmpzXCJcblxuLyoqXG4gKiBmZXRjaCBsYXN0bW9kaWZpZWRcbiAqIGZldGNoIG1hbmlmZXN0XG4gKiBmZXRjaCBzdW1ibmFpbFxuICpcbiAqIHNob3cgc3VtYm5haWxcbiAqIHNob3cgZGlzY3JpcHRpb25cbiAqXG4gKiBsb2FkIGltYWdlc1xuICogIGZyb20gZGJcbiAqICBmZXRjaFxuICpcbiAqIHN0b3JlIGRhdGFcbiAqL1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcm9ja05hbWVTZWxlY3RIYW5kbGVyKHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXMsIHJlaikgPT4ge1xuICAgICAgICBjb25zdCByb2NrX3NlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb2NrX3NlbGVjdG9yXCIpXG4gICAgICAgIGNvbnN0IHBhY2thZ2VOYW1lID0gcm9ja19zZWxlY3Rvci5vcHRpb25zW3JvY2tfc2VsZWN0b3Iuc2VsZWN0ZWRJbmRleF0udmFsdWVcbiAgICAgICAgbG9jYXRpb24uaGFzaCA9IHBhY2thZ2VOYW1lXG5cbiAgICAgICAgc3RhdGUuY2FuUm90YXRlID0gZmFsc2U7XG4gICAgICAgIGhpZGVFcnJvck1lc3NhZ2UoKVxuICAgICAgICBzaG93TG9hZGluZ01lc3NhZ2UoKVxuICAgICAgICBoaWRlV2VsY29tZUJvYXJkKClcbiAgICAgICAgc2hvd1ZpZXdlcigpXG4gICAgICAgIHNob3dOaWNvbEJ1dHRvbigpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtyZXNwb25zZSwgaXNOZXdEYXRhXSA9IGF3YWl0IHF1ZXJ5SW1hZ2VQYWNrYWdlKHN0YXRlLCBwYWNrYWdlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IEpTT04ucGFyc2UocmVzcG9uc2UubWFuaWZlc3QpO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdfc3RhdGUgPSBhd2FpdCB1cGRhdGVTdGF0ZUJ5TWV0YShzdGF0ZSkocGFja2FnZU5hbWUsIG1hbmlmZXN0KVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXdEZXNjcmlwdGlvbilcbiAgICAgICAgICAgICAgICAudGhlbih1cGRhdGVJbWFnZVNyYyhyZXNwb25zZS50aHVtYm5haWwsIFwianBnXCIpKVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG5cbiAgICAgICAgICAgIG5ld19zdGF0ZS5jYW5Sb3RhdGUgPSB0cnVlXG5cbiAgICAgICAgICAgIGlmIChpc05ld0RhdGEpIHtcbiAgICAgICAgICAgICAgICByZXNwb25zZS56aXAgPSBhd2FpdCByZXNwb25zZS56aXAoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB1cGRhdGVJbWFnZVNyYyhyZXNwb25zZS56aXAsIHJlc3BvbnNlLmltYWdlX2Zvcm1hdCkobmV3X3N0YXRlKVxuICAgICAgICAgICAgICAgIC50aGVuKHN0YXRlID0+IHJlZ2lzdGVyKHN0YXRlLCBpc05ld0RhdGEpKHJlc3BvbnNlKSlcbiAgICAgICAgICAgICAgICAudGhlbihtYXJrRG93bmxvYWRlZE9wdGlvbihwYWNrYWdlTmFtZSkobWFuaWZlc3QpKVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG4gICAgICAgICAgICAgICAgLnRoZW4ocmVzKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZWooZSlcbiAgICAgICAgfVxuICAgIH0pXG59XG4iLCJpbXBvcnQgcm9ja05hbWVTZWxlY3RIYW5kbGVyIGZyb20gXCIuL3JvY2tOYW1lU2VsZWN0SGFuZGxlci5qc1wiXG5pbXBvcnQgdXBkYXRlVmlldyBmcm9tIFwiLi91cGRhdGVWaWV3LmpzXCJcbmltcG9ydCB7IHNob3dFcnJvck1lc3NhZ2UsIGhpZGVFcnJvck1lc3NhZ2UgfSBmcm9tIFwiLi9lcnJvcl9pbmRpY2F0b3JfaGFuZGxlci5qc1wiXG5pbXBvcnQgeyBoaWRlTG9hZGluZ01lc3NhZ2UgfSBmcm9tIFwiLi9sb2FkaW5nX2luZGljYXRvcl9oYW5kbGVyLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0Um9ja1NlbGVjdEV2ZW50SGFuZGxlcnMoc3RhdGUpIHtcbiAgICBjb25zdCByb2NrX3NlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb2NrX3NlbGVjdG9yXCIpXG5cbiAgICByb2NrX3NlbGVjdG9yLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgcm9ja05hbWVTZWxlY3RIYW5kbGVyKHN0YXRlKVxuICAgICAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG4gICAgICAgICAgICAgICAgLnRoZW4oaGlkZUVycm9yTWVzc2FnZSlcbiAgICAgICAgICAgICAgICAudGhlbihoaWRlTG9hZGluZ01lc3NhZ2UpXG4gICAgICAgICAgICAgICAgLmNhdGNoKGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIlNhbXBsZSBjYW5ub3QgYmUgbG9hZGVkIGJlY2F1c2Ugb2YgbmV0d29yayBlcnJvci5cIilcbiAgICAgICAgICAgICAgICAgICAgc2hvd0Vycm9yTWVzc2FnZShcIkludGVybmV0IGRpc2Nvbm5lY3RlZC5cIikoZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVPbkNhbnZhcyhjYW52YXMpIHtcbiAgICByZXR1cm4gKGUsIGZpbmd1ciA9IDApID0+IHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBXaGVlbEV2ZW50KVxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICBlLmRlbHRhWCxcbiAgICAgICAgICAgICAgICAgICAgZS5kZWx0YVlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgICAgIGUucGFnZVggLSBjYW52YXMub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgZS5wYWdlWSAtIGNhbnZhcy5vZmZzZXRUb3BcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQgJiYgZS50b3VjaGVzLmxlbmd0aCA+IGZpbmd1cikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBlLnRvdWNoZXNbZmluZ3VyXS5wYWdlWCAtIGNhbnZhcy5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIGUudG91Y2hlc1tmaW5ndXJdLnBhZ2VZIC0gY2FudmFzLm9mZnNldFRvcFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmFkaXVuQmV0d2VlbihjeCwgY3kpIHtcbiAgICByZXR1cm4gKF94MSwgX3kxLCBfeDIsIF95MikgPT4ge1xuICAgICAgICBjb25zdCB4MSA9IF94MSAtIGN4XG4gICAgICAgIGNvbnN0IHgyID0gX3gyIC0gY3hcbiAgICAgICAgY29uc3QgeTEgPSBfeTEgLSBjeVxuICAgICAgICBjb25zdCB5MiA9IF95MiAtIGN5XG5cbiAgICAgICAgY29uc3QgY29zID0gKHgxICogeDIgKyB5MSAqIHkyKSAvIE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSlcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbih4MSAqIHkyIC0geDIgKiB5MSkgKiBNYXRoLmFjb3MoY29zKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IHZpZXdlciB9IGZyb20gXCIuL3ZpZXdlcl9jYW52YXMuanNcIlxuaW1wb3J0IGdldENvb3JkaW5hdGVPbkNhbnZhcyBmcm9tIFwiLi9nZXRDb29yZGluYXRlT25DYW52YXMuanNcIlxuaW1wb3J0IHJhZGl1bkJldHdlZW4gZnJvbSBcIi4vcmFkaXVuQmV0d2Vlbi5qc1wiXG5cblxuZXhwb3J0IGNvbnN0IGNhbnZhc0Nvb3JkaW5hdGUgPSBnZXRDb29yZGluYXRlT25DYW52YXModmlld2VyKVxuXG4vKipcbiAqIFVwZGF0ZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uXG4gKiBAcGFyYW0geyp9IHN0YXRlXG4gKiBAcGFyYW0geyp9IGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNvb3JkaW5hdGUoc3RhdGUsIGUpIHtcbiAgICBzdGF0ZS5kcmFnX3N0YXJ0ID0gc3RhdGUuZHJhZ19lbmQgfHwgdW5kZWZpbmVkXG4gICAgc3RhdGUuZHJhZ19lbmQgPSBjYW52YXNDb29yZGluYXRlKGUpXG5cbiAgICBzdGF0ZS5waW5jaF9zdGFydCA9IHN0YXRlLnBpbmNoX2VuZCB8fCB1bmRlZmluZWRcbiAgICBzdGF0ZS5waW5jaF9lbmQgPSBjYW52YXNDb29yZGluYXRlKGUsIDEpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHNtYWxsIGRpZmZlcmVuY2Ugb2Ygcm90YXRpb24uXG4gKiBVcGRhdGUgdG90YWwgcm90YXRpb24uXG4gKlxuICogQHBhcmFtIHsqfSBzdGF0ZVxuICogQHBhcmFtIHsqfSBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVSb3RhdGUoc3RhdGUsIGUpIHtcbiAgICBpZiAoIXN0YXRlLmNhblJvdGF0ZSkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5kcmFnX3N0YXJ0ID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIC8vIGRlbHRhIHJvdGF0ZSByYWRpdXNcbiAgICBjb25zdCByb3RhdGVfZW5kID0gcmFkaXVuQmV0d2VlbihcbiAgICAgICAgc3RhdGUuY2FudmFzV2lkdGggKiAwLjUsXG4gICAgICAgIHN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNVxuICAgICkoLi4uc3RhdGUuZHJhZ19lbmQsIC4uLnN0YXRlLmRyYWdfc3RhcnQpXG5cbiAgICBzdGF0ZS5yb3RhdGUgKz0gcm90YXRlX2VuZCAvIE1hdGguUEkgKiAxODBcbiAgICBpZiAoc3RhdGUucm90YXRlID49IDM2MCkge1xuICAgICAgICBzdGF0ZS5yb3RhdGUgLT0gMzYwXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5yb3RhdGUgPCAwKSB7XG4gICAgICAgIHN0YXRlLnJvdGF0ZSArPSAzNjBcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJpbXBvcnQgeyB1cGRhdGVDb29yZGluYXRlLCB1cGRhdGVSb3RhdGUgfSBmcm9tIFwiLi9jb29yZGluYXRlX3VwZGF0b3JzLmpzXCJcbmltcG9ydCB7IGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lIH0gZnJvbSBcIi4vZHJhd19zdGF0ZV91cGRhdG9ycy5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJvdGF0ZUltYWdlKHN0YXRlLCBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShzdGF0ZSwgZSlcbiAgICAgICAgdXBkYXRlUm90YXRlKHN0YXRlLCBlKVxuICAgICAgICBibG9iVG9DYW52YXMoc3RhdGUpXG4gICAgICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjYW52YXNDb29yZGluYXRlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZV91cGRhdG9ycy5qc1wiXG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNYWduaWZ5QnlQaW5jaChzdGF0ZSwgZSkge1xuICAgIGlmIChzdGF0ZS5kcmFnX3N0YXJ0ID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIGlmIChzdGF0ZS5waW5jaF9zdGFydCA9PT0gdW5kZWZpbmVkKSByZXR1cm5cblxuICAgIGNvbnN0IHgxID0gWy4uLnN0YXRlLmRyYWdfc3RhcnRdXG4gICAgY29uc3QgeTEgPSBbLi4uc3RhdGUucGluY2hfc3RhcnRdXG4gICAgY29uc3QgeDIgPSBbLi4uc3RhdGUuZHJhZ19lbmRdXG4gICAgY29uc3QgeTIgPSBbLi4uc3RhdGUucGluY2hfZW5kXVxuXG4gICAgY29uc3QgZXhwYW5zaW9uID0gTWF0aC5zcXJ0KCh4MlswXSAtIHkyWzBdKSAqKiAyICsgKHgyWzFdIC0geTJbMV0pICoqIDIpIC8gTWF0aC5zcXJ0KCh4MVswXSAtIHkxWzBdKSAqKiAyICsgKHgxWzFdIC0geTFbMV0pICoqIDIpXG5cbiAgICBjb25zdCBuZXdSYWRpdXMgPSAoZXhwYW5zaW9uID4gMilcbiAgICAgICAgPyBzdGF0ZS5pbWFnZVJhZGl1c1xuICAgICAgICA6IHN0YXRlLmltYWdlUmFkaXVzIC8gZXhwYW5zaW9uXG4gICAgc3RhdGUuaW1hZ2VSYWRpdXMgPSAobmV3UmFkaXVzKSA+IHN0YXRlLmltYWdlUmFkaXVzT3JpZ2luYWxcbiAgICAgICAgPyBzdGF0ZS5pbWFnZVJhZGl1c09yaWdpbmFsXG4gICAgICAgIDogKG5ld1JhZGl1cyA8IDEwMClcbiAgICAgICAgICAgID8gMTAwXG4gICAgICAgICAgICA6IG5ld1JhZGl1c1xuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWFnbmlmeUJ5V2hlZWwoc3RhdGUsIGUpIHtcbiAgICBjb25zdCBzY3JvbGxlZCA9IGNhbnZhc0Nvb3JkaW5hdGUoZSlbMV1cblxuICAgIGNvbnN0IG5ld1JhZGl1cyA9IHN0YXRlLmltYWdlUmFkaXVzICsgc2Nyb2xsZWRcbiAgICBzdGF0ZS5pbWFnZVJhZGl1cyA9IChuZXdSYWRpdXMpID4gc3RhdGUuaW1hZ2VSYWRpdXNPcmlnaW5hbFxuICAgICAgICA/IHN0YXRlLmltYWdlUmFkaXVzT3JpZ2luYWxcbiAgICAgICAgOiAobmV3UmFkaXVzIDwgMTAwKVxuICAgICAgICAgICAgPyAxMDBcbiAgICAgICAgICAgIDogbmV3UmFkaXVzXG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJpbXBvcnQgeyB1cGRhdGVDb29yZGluYXRlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZV91cGRhdG9ycy5qc1wiXG5pbXBvcnQgeyB1cGRhdGVNYWduaWZ5QnlQaW5jaCB9IGZyb20gXCIuL3VwZGF0ZU1hZ25pZnkuanNcIlxuaW1wb3J0IHsgYmxvYlRvQ2FudmFzLCBkcmF3SGFpckxpbmUsIGRyYXdTY2FsZSB9IGZyb20gXCIuL2RyYXdfc3RhdGVfdXBkYXRvcnMuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaW5jaEltYWdlKHN0YXRlLCBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShzdGF0ZSwgZSlcbiAgICAgICAgdXBkYXRlTWFnbmlmeUJ5UGluY2goc3RhdGUsIGUpXG4gICAgICAgIGJsb2JUb0NhbnZhcyhzdGF0ZSlcbiAgICAgICAgZHJhd0hhaXJMaW5lKHN0YXRlKVxuICAgICAgICBkcmF3U2NhbGUoc3RhdGUpXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2FudmFzQ29vcmRpbmF0ZSB9IGZyb20gXCIuL2Nvb3JkaW5hdGVfdXBkYXRvcnMuanNcIlxuaW1wb3J0IHJvdGF0ZUltYWdlIGZyb20gXCIuL3JvdGF0ZUltYWdlLmpzXCJcbmltcG9ydCBwaW5jaEltYWdlIGZyb20gXCIuL3BpbmNoSW1hZ2UuanNcIlxuXG5leHBvcnQgY29uc3QgdG91Y2hTdGFydEhhbmRsZXIgPSBzdGF0ZSA9PiBlID0+IHtcbiAgICBzdGF0ZS5pc01vdXNlZG93biA9IHRydWVcbiAgICBzdGF0ZS5kcmFnX2VuZCA9IGNhbnZhc0Nvb3JkaW5hdGUoZSlcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBjb25zdCB0b3VjaE1vdmVIYW5kbGVyID0gc3RhdGUgPT4gZSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5pc01vdXNlZG93bikgcmV0dXJuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50IHx8IGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXG4gICAgICAgICAgICByb3RhdGVJbWFnZShzdGF0ZSwgZSlcbiAgICAgICAgKVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICAgICAgcGluY2hJbWFnZShzdGF0ZSwgZSlcbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvdWNoRW5kSGFuZGxlciA9IHN0YXRlID0+IGUgPT4ge1xuICAgIHN0YXRlLmlzTW91c2Vkb3duID0gZmFsc2VcbiAgICBzdGF0ZS5kcmFnX2VuZCA9IHVuZGVmaW5lZFxuICAgIHN0YXRlLnBpbmNoX2VuZCA9IHVuZGVmaW5lZFxuICAgIGUucHJldmVudERlZmF1bHQoKVxufVxuIiwiaW1wb3J0IHsgdXBkYXRlTWFnbmlmeUJ5V2hlZWwgfSBmcm9tIFwiLi91cGRhdGVNYWduaWZ5LmpzXCJcbmltcG9ydCB7IGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lLCBkcmF3U2NhbGUgfSBmcm9tIFwiLi9kcmF3X3N0YXRlX3VwZGF0b3JzLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2hlZWxJbWFnZShzdGF0ZSwgZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZU1hZ25pZnlCeVdoZWVsKHN0YXRlLCBlKVxuICAgICAgICBibG9iVG9DYW52YXMoc3RhdGUpXG4gICAgICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICAgICAgZHJhd1NjYWxlKHN0YXRlKVxuICAgIH1cbn1cbiIsImltcG9ydCB3aGVlbEltYWdlIGZyb20gXCIuL3doZWVsSW1hZ2UuanNcIlxuXG5leHBvcnQgY29uc3Qgd2hlZWxIYW5kbGVyID0gc3RhdGUgPT4gZSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgd2hlZWxJbWFnZShzdGF0ZSwgZSlcbiAgICApXG59XG4iLCJpbXBvcnQgeyB2aWV3ZXIgfSBmcm9tIFwiLi92aWV3ZXJfY2FudmFzLmpzXCJcbmltcG9ydCB7IHRvdWNoU3RhcnRIYW5kbGVyLCB0b3VjaE1vdmVIYW5kbGVyLCB0b3VjaEVuZEhhbmRsZXIgfSBmcm9tIFwiLi90b3VjaEV2ZW50SGFuZGxlcnMuanNcIlxuaW1wb3J0IHsgd2hlZWxIYW5kbGVyIH0gZnJvbSBcIi4vd2hlZWxFdmVudEhhbmRsZXIuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZXRDYW52YXNFdmVudEhhbmRsZXJzKHN0YXRlKSB7XG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2Vkb3duXCIsXG4gICAgICAgIHRvdWNoU3RhcnRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJkcmFnc3RhcnRcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImRyYWdcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImRyYWdlbmRcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAgIHRvdWNoU3RhcnRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZW1vdmVcIixcbiAgICAgICAgdG91Y2hNb3ZlSGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAgIHRvdWNoTW92ZUhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNldXBcIixcbiAgICAgICAgdG91Y2hFbmRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICB0b3VjaEVuZEhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIndoZWVsXCIsXG4gICAgICAgIHdoZWVsSGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbGFuZ3VhZ2VDaGFuZ2VIYW5kbGVyKHN0YXRlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGxhbmd1YWdlU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2xhbmd1YWdlX3NlbGVjdG9yXCIpXG4gICAgICAgICAgICBjb25zdCBsYW5nID0gbGFuZ3VhZ2VTZWxlY3Rvci5vcHRpb25zW2xhbmd1YWdlU2VsZWN0b3Iuc2VsZWN0ZWRJbmRleF0udmFsdWU7XG4gICAgICAgICAgICBzdGF0ZS5sYW5ndWFnZSA9IGxhbmdcbiAgICAgICAgICAgIHN0YXRlLmxvY2FsU3RvcmFnZS5wdXQoXCJsYW5ndWFnZVwiLCBsYW5nKVxuICAgICAgICAgICAgcmVzKHN0YXRlKVxuICAgICAgICB9KVxuICAgIH1cbn1cbiIsIi8qKlxuICog44K144Oz44OX44Or44Oq44K544OI44KSc2VsZWN044K/44Kw5YaF44Gr6L+95Yqg44GZ44KLXG4gKiBAcGFyYW0geyp9IHN0YXRlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNob3dTYW1wbGVMaXN0KHN0YXRlLCByZXNwb25zZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzLCByZWopID0+IHtcblxuICAgICAgICBjb25zdCBzYXZlZFNhbXBsZU5hbWVzID0gc3RhdGUuc3RvcmVkS2V5cztcblxuICAgICAgICBjb25zdCBzYW1wbGVMaXN0ID0gcmVzcG9uc2VbXCJsaXN0X29mX3NhbXBsZVwiXTtcbiAgICAgICAgY29uc3Qgc2FtcGxlU2VsZWN0RE9NID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb2NrX3NlbGVjdG9yXCIpO1xuICAgICAgICBzYW1wbGVTZWxlY3RET00uaW5uZXJIVE1MID0gXCI8b3B0aW9uIHZhbHVlPScnIGRpc2FibGVkIHNlbGVjdGVkIHN0eWxlPSdkaXNwbGF5Om5vbmU7Jz5TZWxlY3Qgc2FtcGxlPC9vcHRpb24+XCI7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzYW1wbGVMaXN0Lm1hcCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgb3B0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKVxuICAgICAgICAgICAgb3B0aW9uLnZhbHVlID0gdltcInBhY2thZ2UtbmFtZVwiXTtcbiAgICAgICAgICAgIG9wdGlvbi5pbm5lckhUTUwgPSAoc2F2ZWRTYW1wbGVOYW1lcy5pbmNsdWRlcyh2W1wicGFja2FnZS1uYW1lXCJdKSA/IFwi4pyTIFwiIDogXCJcIikgKyBgJHtpICsgMX0uICR7dltcImxpc3QtbmFtZVwiXVtzdGF0ZS5sYW5ndWFnZV19YFxuICAgICAgICAgICAgaWYgKHNhdmVkU2FtcGxlTmFtZXMuaW5jbHVkZXModltcInBhY2thZ2UtbmFtZVwiXSkpIHtcbiAgICAgICAgICAgICAgICBvcHRpb24uY2xhc3NMaXN0LmFkZChcImRvd25sb2FkZWRcIilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcHRpb25cbiAgICAgICAgfSlcbiAgICAgICAgb3B0aW9ucy5mb3JFYWNoKHYgPT4ge1xuICAgICAgICAgICAgc2FtcGxlU2VsZWN0RE9NLmFwcGVuZENoaWxkKHYpXG4gICAgICAgIH0pXG5cbiAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN0b3AtbmF2aWdhdGlvblwiKS5jbGFzc0xpc3QuYWRkKFwiaXNyZWFkeVwiKTtcbiAgICAgICAgc2FtcGxlU2VsZWN0RE9NLmNsYXNzTGlzdC5hZGQoXCJpc3JlYWR5XCIpXG4gICAgICAgIHJlcyhzdGF0ZSk7XG4gICAgfSlcbn1cbiIsImltcG9ydCB7IHN0YXRpY1NldHRpbmdzIH0gZnJvbSBcIi4vY29uZmlnL2NvbmZpZy5qc1wiXG5pbXBvcnQgeyBzaG93RXJyb3JNZXNzYWdlIH0gZnJvbSBcIi4vZXJyb3JfaW5kaWNhdG9yX2hhbmRsZXIuanNcIlxuaW1wb3J0IHNob3dTYW1wbGVMaXN0IGZyb20gXCIuL3Nob3dTYW1wbGVMaXN0LmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbG9hZFNhbXBsZUxpc3RGcm9tUmVtb3RlKHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGFzeW5jIChyZXMsIHJlaikgPT4ge1xuICAgICAgICBjb25zdCBsaXN0VVJMID0gc3RhdGljU2V0dGluZ3MuZ2V0U2FtcGxlTGlzdFVSTCgpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gobGlzdFVSTCwgeyBtb2RlOiAnY29ycycgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goKGUpID0+IHsgdGhyb3cgRXJyb3IoZSkgfSlcbiAgICAgICAgICAgICAgICAudGhlbihyID0+IHIuanNvbigpKVxuICAgICAgICAgICAgc3RhdGUubG9jYWxTdG9yYWdlLnB1dChcImxpc3Rfb2Zfc2FtcGxlXCIsIEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlW1wibGlzdF9vZl9zYW1wbGVcIl0pKVxuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICB2YXIgc3RvcmVkX2xpc3QgPSBzdGF0ZS5sb2NhbFN0b3JhZ2UuZ2V0KFwibGlzdF9vZl9zYW1wbGVcIilcbiAgICAgICAgICAgIHZhciByZXNwb25zZSA9IHsgXCJsaXN0X29mX3NhbXBsZVwiOiBKU09OLnBhcnNlKHN0b3JlZF9saXN0KSB9XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oZSlcbiAgICAgICAgICAgIHNob3dFcnJvck1lc3NhZ2UoXCI8cD5JbnRlcm5ldCBkaXNjb25uZWN0ZWQuPC9wPlwiKSgpXG4gICAgICAgIH1cbiAgICAgICAgc2hvd1NhbXBsZUxpc3Qoc3RhdGUsIHJlc3BvbnNlKS50aGVuKHJlcylcbiAgICB9KVxufVxuIiwiaW1wb3J0IGxhbmd1YWdlQ2hhbmdlSGFuZGxlciBmcm9tIFwiLi9sYW5ndWFnZUNoYW5nZUhhbmRsZXIuanNcIlxuaW1wb3J0IHNhbXBsZUxpc3RMb2FkZXIgZnJvbSBcIi4vbG9hZFNhbXBsZUxpc3RGcm9tUmVtb3RlLmpzXCJcbmltcG9ydCB1cGRhdGVWaWV3RGVzY3JpcHRpb24gZnJvbSBcIi4vdXBkYXRlVmlld0Rlc2NyaXB0aW9uLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc2V0TGFuZ3VhZ2VTZWxlY3RFdmVudEhhbmRsZXJzKHN0YXRlKSB7XG4gICAgY29uc3QgbGFuZ3VhZ2VTZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbGFuZ3VhZ2Vfc2VsZWN0b3JcIilcblxuICAgIGxhbmd1YWdlU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLFxuICAgICAgICBlID0+IGxhbmd1YWdlQ2hhbmdlSGFuZGxlcihzdGF0ZSkoZSlcbiAgICAgICAgICAgIC50aGVuKHNhbXBsZUxpc3RMb2FkZXIpXG4gICAgICAgICAgICAudGhlbih1cGRhdGVWaWV3RGVzY3JpcHRpb24pLFxuICAgICAgICBmYWxzZVxuICAgIClcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIHNlbmRDb250YWN0TWVzc2FnZShlLCBtZXNzYWdlRE9NKSB7XG5cbiAgICBjb25zdCBidXR0b24gPSBlLnRhcmdldFxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwicGVuZGluZ1wiKVxuXG4gICAgbWVzc2FnZURPTS5jbGFzc0xpc3QuYWRkKFwiaW5hY3RpdmVcIilcbiAgICBtZXNzYWdlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJzdWNjZXNzXCIpXG4gICAgbWVzc2FnZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiZXJyb3JcIilcblxuICAgIGNvbnN0IGZvcm0gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Zvcm0tY29udGFjdFwiKVxuICAgIGNvbnN0IHNlbGVjdGlvbiA9IGZvcm0ucXVlcnlTZWxlY3RvcihcIiNzZWxlY3QtY29udGFjdF90b3BpY1wiKVxuICAgIGNvbnN0IHRvcGljID0gc2VsZWN0aW9uW3NlbGVjdGlvbi5zZWxlY3RlZEluZGV4XS52YWx1ZVxuICAgIGNvbnN0IG1lc3NhZ2UgPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoXCJ0ZXh0YXJlYVwiKS52YWx1ZVxuICAgIGNvbnN0IGZyb20gPSBmb3JtLnF1ZXJ5U2VsZWN0b3IoXCJpbnB1dFt0eXBlPWVtYWlsXCIpLnZhbHVlXG5cbiAgICBpZiAodG9waWMgPT09IFwiXCIpIHtcbiAgICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJwZW5kaW5nXCIpXG4gICAgICAgIG1lc3NhZ2VET00uaW5uZXJIVE1MID0gXCJTZWxlY3QgdG9waWMgIVwiXG4gICAgICAgIG1lc3NhZ2VET00uY2xhc3NMaXN0LmFkZChcImVycm9yXCIpXG4gICAgICAgIG1lc3NhZ2VET00uY2xhc3NMaXN0LnJlbW92ZShcImluYWN0aXZlXCIpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIGlmIChtZXNzYWdlID09PSB1bmRlZmluZWQgfHwgbWVzc2FnZSA9PSBcIlwiKSB7XG4gICAgICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwicGVuZGluZ1wiKVxuICAgICAgICBtZXNzYWdlRE9NLmlubmVySFRNTCA9IFwiV3JpdGUgbWVzc2FnZSAhXCJcbiAgICAgICAgbWVzc2FnZURPTS5jbGFzc0xpc3QuYWRkKFwiZXJyb3JcIilcbiAgICAgICAgbWVzc2FnZURPTS5jbGFzc0xpc3QucmVtb3ZlKFwiaW5hY3RpdmVcIilcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3Qgb2JqID0ge1xuICAgICAgICBcImZyb21cIjogZnJvbSxcbiAgICAgICAgXCJ0aXRsZVwiOiB0b3BpYyxcbiAgICAgICAgXCJib2R5XCI6IG1lc3NhZ2VcbiAgICB9XG5cbiAgICBjb25zdCBtZXRob2QgPSBcIlBPU1RcIjtcbiAgICBjb25zdCBib2R5ID0gSlNPTi5zdHJpbmdpZnkob2JqKTtcbiAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAnQWNjZXB0JzogJ3RleHQvcGxhaW4sYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nOiAnKicsXG4gICAgICAgICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1IZWFkZXJzJzogJ0NvbnRlbnQtVHlwZSxYLUFtei1EYXRlLEF1dGhvcml6YXRpb24sWC1BcGktS2V5LFgtQW16LVNlY3VyaXR5LVRva2VuJyxcblxuICAgIH07XG5cbiAgICBjb25zb2xlLmxvZyh7IG1ldGhvZCwgaGVhZGVycywgYm9keSB9KVxuXG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHBzOi8vZGdvOTZ5aHVuaS5leGVjdXRlLWFwaS51cy1lYXN0LTEuYW1hem9uYXdzLmNvbS9jb250YWN0YXBpL2NvbnRhY3RcIiwgeyBtZXRob2QsIGhlYWRlcnMsIGJvZHksICdtb2RlJzogJ25vLWNvcnMnIH0pXG4gICAgICAgIG1lc3NhZ2VET00uaW5uZXJIVE1MID0gXCJTdWNjZXNzLiBUaGFuayB5b3UgZm9yIGNvbnRyaWJ1dGluZyAhXCJcbiAgICAgICAgbWVzc2FnZURPTS5jbGFzc0xpc3QuYWRkKFwic3VjY2Vzc1wiKVxuICAgICAgICBtZXNzYWdlRE9NLmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5sb2coZSlcbiAgICAgICAgbWVzc2FnZURPTS5pbm5lckhUTUwgPSBcIk5ldHdvcmsgZXJyb3IgIVwiXG4gICAgICAgIG1lc3NhZ2VET00uY2xhc3NMaXN0LmFkZChcImVycm9yXCIpXG4gICAgICAgIG1lc3NhZ2VET00uY2xhc3NMaXN0LnJlbW92ZShcImluYWN0aXZlXCIpXG4gICAgfVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QucmVtb3ZlKFwicGVuZGluZ1wiKVxuXG4gICAgcmV0dXJuIGZhbHNlXG59XG4iLCJpbXBvcnQgc2VuZENvbnRhY3RNZXNzYWdlIGZyb20gXCIuL3NlbmRDb250YWN0TWVzc2FnZS5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNldENvbnRhY3RGb3JtRXZlbnRIYW5kbGVycyhzdGF0ZSkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9ybS1jb250YWN0IGRpdi5idXR0b25cIikuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICBlID0+IChBcnJheS5mcm9tKGUudGFyZ2V0LmNsYXNzTGlzdCkuaW5jbHVkZXMoXCJwZW5kaW5nXCIpKVxuICAgICAgICAgICAgPyBudWxsXG4gICAgICAgICAgICA6IHNlbmRDb250YWN0TWVzc2FnZShcbiAgICAgICAgICAgICAgICBlLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZm9ybS1jb250YWN0IC5mb3JtLW1lc3NhZ2VcIilcbiAgICAgICAgICAgICksXG4gICAgICAgIGZhbHNlXG4gICAgKVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZ2V0TWF4Vmlld2VyU2l6ZSgpIHtcbiAgICBjb25zdCB0b3BCYXJTcGFjZUhlaWdodCA9IDIwMCAvLyBweFxuICAgIGNvbnN0IHdpZHRoID0gd2luZG93LmlubmVyV2lkdGhcbiAgICBjb25zdCBoZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgLSB0b3BCYXJTcGFjZUhlaWdodFxuICAgIHJldHVybiB3aWR0aCA8IGhlaWdodCA/IHdpZHRoIDogaGVpZ2h0XG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzZWxlY3RMYW5ndWFnZUNvZGUoKSB7XG4gICAgY29uc3QgY29kZSA9ICh3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlcyAmJiB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlc1swXSkgfHxcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSB8fFxuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fFxuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLmJyb3dzZXJMYW5ndWFnZTtcblxuICAgIGNvbnN0IGxhbmcgPSBjb2RlLm1hdGNoKFwiamFcIikgPyBcImphXCIgOiBcImVuXCI7XG5cbiAgICByZXR1cm4gbGFuZ1xufVxuIiwiaW1wb3J0IGdldE1heFZpZXdlclNpemUgZnJvbSBcIi4vZ2V0TWF4Vmlld2VyU2l6ZS5qc1wiXG5pbXBvcnQgc2VsZWN0TGFuZ3VhZ2VDb2RlIGZyb20gXCIuL3NlbGVjdExhbmd1YWdlQ29kZS5qc1wiXG5cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdFN0YXRlKCkge1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJjb250YWlub3JJRFwiOiBcIlwiLFxuICAgICAgICBcImltYWdlTnVtYmVyXCI6IDEsXG4gICAgICAgIFwiY2FudmFzV2lkdGhcIjogZ2V0TWF4Vmlld2VyU2l6ZSgpIDw9IDUwMFxuICAgICAgICAgICAgPyBnZXRNYXhWaWV3ZXJTaXplKClcbiAgICAgICAgICAgIDogNTAwLFxuICAgICAgICBcImNhbnZhc0hlaWdodFwiOiBnZXRNYXhWaWV3ZXJTaXplKCkgPD0gNTAwXG4gICAgICAgICAgICA/IGdldE1heFZpZXdlclNpemUoKVxuICAgICAgICAgICAgOiA1MDAsXG4gICAgICAgIFwiaW1hZ2VSYWRpdXNcIjogMCxcbiAgICAgICAgXCJvcGVuX2ltYWdlX3NyY3NcIjogW10sXG4gICAgICAgIFwib3Blbl9pbWFnZXNcIjogW10sXG4gICAgICAgIFwiY3Jvc3NfaW1hZ2Vfc3Jjc1wiOiBbXSxcbiAgICAgICAgXCJjcm9zc19pbWFnZXNcIjogW10sXG4gICAgICAgIFwiaXNNb3VzZWRvd25cIjogZmFsc2UsXG4gICAgICAgIFwiZHJhZ19zdGFydFwiOiBbMCwgMF0sXG4gICAgICAgIFwiZHJhZ19lbmRcIjogWzAsIDBdLFxuICAgICAgICBcInJvdGF0ZVwiOiAwLFxuICAgICAgICBcInJvdGF0ZV9heGlzX3RyYW5zbGF0ZVwiOiBbXSxcbiAgICAgICAgXCJpc0Nsb2Nrd2lzZVwiOiB0cnVlLFxuICAgICAgICBcImlzQ3Jvc3NOaWNvbFwiOiBmYWxzZSxcbiAgICAgICAgXCJsYW5ndWFnZVwiOiBzZWxlY3RMYW5ndWFnZUNvZGUoKSxcbiAgICAgICAgXCJzdG9yZWRLZXlzXCI6IFtdLFxuICAgICAgICBcImRyYXdIYWlyTGluZVwiOiB0cnVlLFxuICAgICAgICBcImNhblJvdGF0ZVwiOiB0cnVlLFxuICAgIH1cbn1cbiIsImltcG9ydCB7IHZpZXdlciwgdmlld2VyX2N0eCB9IGZyb20gXCIuL3ZpZXdlcl9jYW52YXMuanNcIlxuaW1wb3J0IGdldE1heFZpZXdlclNpemUgZnJvbSBcIi4vZ2V0TWF4Vmlld2VyU2l6ZS5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVwZGF0ZVZpZXdlckdlb21ldHJ5KHN0YXRlKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICBjb25zdCBwYWRkaW5nID0gMjAgLy8gcHhcbiAgICAgICAgc3RhdGUuY2FudmFzV2lkdGggPSBnZXRNYXhWaWV3ZXJTaXplKCkgLSBwYWRkaW5nXG4gICAgICAgIHN0YXRlLmNhbnZhc0hlaWdodCA9IGdldE1heFZpZXdlclNpemUoKSAtIHBhZGRpbmdcblxuICAgICAgICB2aWV3ZXIud2lkdGggPSBzdGF0ZS5jYW52YXNXaWR0aFxuICAgICAgICB2aWV3ZXIuaGVpZ2h0ID0gc3RhdGUuY2FudmFzSGVpZ2h0XG4gICAgICAgIHZpZXdlcl9jdHgudHJhbnNsYXRlKHN0YXRlLmNhbnZhc1dpZHRoICogMC41LCBzdGF0ZS5jYW52YXNIZWlnaHQgKiAwLjUpXG4gICAgICAgIHJlcyhzdGF0ZSlcbiAgICB9KVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZXM2QXZhaWxhYmxlKCkge1xuICAgIHJldHVybiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2woKSA9PT0gXCJzeW1ib2xcIilcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIE5hdGl2ZUxvY2FsU3RvcmFnZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZGIgPSB3aW5kb3cubG9jYWxTdG9yYWdlXG4gICAgfVxuXG4gICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYi5zZXRJdGVtKGtleSwgdmFsdWUpO1xuICAgIH1cblxuICAgIGdldChrZXkpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmRiLmdldEl0ZW0oa2V5KVxuICAgICAgICByZXR1cm4gKHZhbHVlID09IG51bGwpXG4gICAgICAgICAgICA/IHVuZGVmaW5lZFxuICAgICAgICAgICAgOiB2YWx1ZVxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIER1bW15TG9jYWxTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYiA9IHt9XG4gICAgfVxuXG4gICAgcHV0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5kYltrZXldID0gdmFsdWU7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gKHRoaXMuZGIuaGFzT3duUHJvcGVydHkoXCJrZXlcIikpXG4gICAgICAgICAgICA/IHRoaXMuZGJba2V5XVxuICAgICAgICAgICAgOiB1bmRlZmluZWRcbiAgICB9XG59XG4iLCJcbmltcG9ydCBOYXRpdmVMb2NhbFN0b3JhZ2UgZnJvbSBcIi4vTmF0aXZlTG9jYWxTdG9yYWdlXCI7XG5pbXBvcnQgRHVtbXlMb2NhbFN0b3JhZ2UgZnJvbSBcIi4vRHVtbXlMb2NhbFN0b3JhZ2VcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gSVNtYWxsU3RvcmFnZUZhY3RvcnkoKSB7XG4gICAgcmV0dXJuICh3aW5kb3cubG9jYWxTdG9yYWdlKVxuICAgICAgICA/IG5ldyBOYXRpdmVMb2NhbFN0b3JhZ2UoKVxuICAgICAgICA6IG5ldyBEdW1teUxvY2FsU3RvcmFnZSgpXG59XG4iLCJpbXBvcnQgSVNtYWxsU3RvcmFnZUZhY3RvcnkgZnJvbSBcIi4vSVNtYWxsU3RvcmFnZUZhY3RvcnkuanNcIlxuXG4vLyBjb25uZWN0TG9jYWxTdG9yYWdlID0gSVNtYWxsU3RvcmFnZSAtPiBzdGF0ZSAtPiBzdGF0ZSDjgavjgZnjgos/XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjb25uZWN0TG9jYWxTdG9yYWdlKHN0YXRlKSB7XG4gICAgc3RhdGUubG9jYWxTdG9yYWdlID0gSVNtYWxsU3RvcmFnZUZhY3RvcnkoKTtcbiAgICByZXR1cm4gc3RhdGVcbn1cbiIsImV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlY3RXZWJwU3VwcG9ydCgpIHtcblxuICAgIGNvbnN0IHRlc3RJbWFnZVNvdXJjZXMgPSBbXG4gICAgICAgIFwiZGF0YTppbWFnZS93ZWJwO2Jhc2U2NCxVa2xHUmpJQUFBQlhSVUpRVmxBNElDWUFBQUN5QWdDZEFTb0NBQUVBTG1rMG1rMGlJaUlpSWdCb1N5Z0FCYzZ6YkFBQS92NTZRQUFBQUE9PVwiLFxuICAgICAgICBcImRhdGE6aW1hZ2Uvd2VicDtiYXNlNjQsVWtsR1JoNEFBQUJYUlVKUVZsQTRUQkVBQUFBdkFRQUFBQWZRLy83M3YvK0JpT2gvQUFBPVwiXG4gICAgXVxuXG4gICAgY29uc3QgdGVzdEltYWdlID0gKHNyYykgPT4ge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdmFyIGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIilcbiAgICAgICAgICAgIGltZy5vbmVycm9yID0gZXJyb3IgPT4gcmVzb2x2ZShmYWxzZSlcbiAgICAgICAgICAgIGltZy5vbmxvYWQgPSAoKSA9PiByZXNvbHZlKHRydWUpXG4gICAgICAgICAgICBpbWcuc3JjID0gc3JjXG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKHRlc3RJbWFnZVNvdXJjZXMubWFwKHRlc3RJbWFnZSkpXG5cbiAgICByZXR1cm4gcmVzdWx0cy5ldmVyeShyZXN1bHQgPT4gISFyZXN1bHQpXG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBkZXRlY3RKMmtTdXBwb3J0KCkge1xuICAgIGNvbnN0IHRlc3RJbWFnZVNvdXJjZXMgPSBbXG4gICAgICAgICdkYXRhOmltYWdlL2pwMjtiYXNlNjQsQUFBQURHcFFJQ0FOQ29jS0FBQUFGR1owZVhCcWNESWdBQUFBQUdwd01pQUFBQUF0YW5BeWFBQUFBQlpwYUdSeUFBQUFCQUFBQUFRQUF3OEhBQUFBQUFBUFkyOXNjZ0VBQUFBQUFCQUFBQUJwYW5BeVkvOVAvMUVBTHdBQUFBQUFCQUFBQUFRQUFBQUFBQUFBQUFBQUFBUUFBQUFFQUFBQUFBQUFBQUFBQXc4QkFROEJBUThCQWY5U0FBd0FBQUFCQVFBRUJBQUIvMXdBQkVDQS81QUFDZ0FBQUFBQUdBQUIvNVBQL0JBUUZBQmNyNENBLzlrPSdcbiAgICBdXG5cbiAgICBjb25zdCB0ZXN0SW1hZ2UgPSAoc3JjKSA9PiB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB2YXIgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKVxuICAgICAgICAgICAgaW1nLm9uZXJyb3IgPSBlcnJvciA9PiByZXNvbHZlKGZhbHNlKVxuICAgICAgICAgICAgaW1nLm9ubG9hZCA9ICgpID0+IHJlc29sdmUodHJ1ZSlcbiAgICAgICAgICAgIGltZy5zcmMgPSBzcmNcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgUHJvbWlzZS5hbGwodGVzdEltYWdlU291cmNlcy5tYXAodGVzdEltYWdlKSlcblxuICAgIHJldHVybiByZXN1bHRzLmV2ZXJ5KHJlc3VsdCA9PiAhIXJlc3VsdClcbn1cbiIsImltcG9ydCB7IGRldGVjdFdlYnBTdXBwb3J0LCBkZXRlY3RKMmtTdXBwb3J0IH0gZnJvbSBcIi4vZGV0ZWN0X3N1cHBvcnRlZF9pbWFnZS5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGdldFN1cHBvcnRlZEltYWdlVHlwZSgpIHtcbiAgICBpZiAoYXdhaXQgZGV0ZWN0V2VicFN1cHBvcnQoKSkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJwXCJcbiAgICB9XG4gICAgaWYgKGF3YWl0IGRldGVjdEoya1N1cHBvcnQoKSkge1xuICAgICAgICByZXR1cm4gXCJqcDJcIlxuICAgIH1cbiAgICByZXR1cm4gXCJqcGdcIlxufVxuIiwiaW1wb3J0IHsgZGV0ZWN0V2VicFN1cHBvcnQsIGRldGVjdEoya1N1cHBvcnQgfSBmcm9tIFwiLi9kZXRlY3Rfc3VwcG9ydGVkX2ltYWdlLmpzXCJcbmltcG9ydCBnZXRTdXBwb3J0ZWRJbWFnZVR5cGUgZnJvbSBcIi4vZ2V0U3VwcG9ydGVkSW1hZ2VUeXBlLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gY2hlY2tTdXBwb3J0ZWRJbWFnZUZvcm1hdChzdGF0ZSkge1xuICAgIHN0YXRlLnN1cHBvcnRXZWJwID0gYXdhaXQgZGV0ZWN0V2VicFN1cHBvcnQoKTtcbiAgICBzdGF0ZS5zdXBwb3J0SjJrID0gYXdhaXQgZGV0ZWN0SjJrU3VwcG9ydCgpO1xuICAgIHN0YXRlLnN1cHBvcnRlZEltYWdlVHlwZSA9IGF3YWl0IGdldFN1cHBvcnRlZEltYWdlVHlwZSgpO1xuICAgIHJldHVybiBzdGF0ZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gb3ZlcndyaWRlTGFuZ3VhZ2VCeUxvY2FsU3RvcmFnZShzdGF0ZSkge1xuICAgIGNvbnN0IGxhbmdJbkxvY2FsU3RvcmFnZSA9IHN0YXRlLmxvY2FsU3RvcmFnZS5nZXQoXCJsYW5ndWFnZVwiKVxuICAgIGNvbnN0IGxhbmcgPSAobGFuZ0luTG9jYWxTdG9yYWdlICE9PSB1bmRlZmluZWQpXG4gICAgICAgID8gbGFuZ0luTG9jYWxTdG9yYWdlXG4gICAgICAgIDogc3RhdGUubGFuZ3VhZ2U7XG4gICAgc3RhdGUubGFuZ3VhZ2UgPSBsYW5nXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm9wdGlvblt2YWx1ZT1cIiArIGxhbmcgKyBcIl1cIikuc2VsZWN0ZWQgPSB0cnVlXG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBEYXRhYmFzZUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGRiX25hbWUsIHZlcnNpb24sIHN0b3JlTmFtZSwgcHJpbWFyeUtleU5hbWUpIHtcbiAgICAgICAgdGhpcy5kYiA9IHdpbmRvdy5pbmRleGVkREI7XG4gICAgICAgIHRoaXMuZGJfbmFtZSA9IGRiX25hbWU7XG4gICAgICAgIHRoaXMuZGJfdmVyc2lvbiA9IHZlcnNpb247XG4gICAgICAgIHRoaXMuc3RvcmVOYW1lID0gc3RvcmVOYW1lO1xuICAgICAgICB0aGlzLnByaW1hcnlLZXkgPSBwcmltYXJ5S2V5TmFtZTtcbiAgICB9XG5cbiAgICBzY2hlbWVEZWYoZGIpIHtcbiAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUsIHsga2V5UGF0aDogdGhpcy5wcmltYXJ5S2V5LCBhdXRvSW5jcmVtZW50OiB0cnVlIH0pO1xuICAgIH1cblxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIGNvbnN0IGRicCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHJlcSA9IHRoaXMuZGIub3Blbih0aGlzLmRiX25hbWUsIHRoaXMuZGJfdmVyc2lvbik7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gZXYgPT4gcmVzb2x2ZShldi50YXJnZXQucmVzdWx0KTtcbiAgICAgICAgICAgIHJlcS5vbmVycm9yID0gZXYgPT4gcmVqZWN0KCdmYWlscyB0byBvcGVuIGRiJyk7XG4gICAgICAgICAgICByZXEub251cGdyYWRlbmVlZGVkID0gZXYgPT4gdGhpcy5zY2hlbWVEZWYoZXYudGFyZ2V0LnJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgICAgICBkYnAudGhlbihkID0+IGQub25lcnJvciA9IGV2ID0+IGFsZXJ0KFwiZXJyb3I6IFwiICsgZXYudGFyZ2V0LmVycm9yQ29kZSkpO1xuICAgICAgICByZXR1cm4gZGJwO1xuICAgIH1cblxuICAgIGFzeW5jIHB1dChkYiwgb2JqKSB7IC8vIHJldHVybnMgb2JqIGluIElEQlxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jcyA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZV0sICdyZWFkd3JpdGUnKS5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSk7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBkb2NzLnB1dChvYmopO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoT2JqZWN0LmFzc2lnbih7IFt0aGlzLnByaW1hcnlLZXldOiByZXEucmVzdWx0IH0sIG9iaikpO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGdldChkYiwgaWQpIHsgLy8gTk9URTogaWYgbm90IGZvdW5kLCByZXNvbHZlcyB3aXRoIHVuZGVmaW5lZC5cbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRvY3MgPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWUsXSkub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcmVxID0gZG9jcy5nZXQoaWQpO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUocmVxLnJlc3VsdCk7XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZGVsZXRlKGRiLCBpZCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZG9jcyA9IGRiLnRyYW5zYWN0aW9uKFt0aGlzLnN0b3JlTmFtZSxdLCAncmVhZHdyaXRlJylcbiAgICAgICAgICAgICAgICAub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpO1xuICAgICAgICAgICAgY29uc3QgcmVxID0gZG9jcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgcmVxLm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUoaWQpO1xuICAgICAgICAgICAgcmVxLm9uZXJyb3IgPSByZWplY3Q7XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgYXN5bmMgbG9hZEFsbEtleShkYikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgc2F2ZXMgPSBbXTtcbiAgICAgICAgICAgIHZhciByYW5nZSA9IElEQktleVJhbmdlLmxvd2VyQm91bmQoMCk7XG4gICAgICAgICAgICBjb25zdCByZXEgPSBkYi50cmFuc2FjdGlvbihbdGhpcy5zdG9yZU5hbWVdKS5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSkub3BlbkN1cnNvcihyYW5nZSk7XG4gICAgICAgICAgICByZXEub25zdWNjZXNzID0gZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gZS50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgIC8vIOazqO+8iei1sOafu+OBmeOBueOBjU9iamVjdOOBjOOBk+OCjOS7peS4iueEoeOBhOWgtOWQiFxuICAgICAgICAgICAgICAgIC8vICAgICByZXN1bHQgPT0gbnVsbCDjgajjgarjgorjgb7jgZnvvIFcbiAgICAgICAgICAgICAgICBpZiAoISFyZXN1bHQgPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShzYXZlcylcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyDjgZPjgZPjgat2YWx1ZeOBjOOBj+OCi++8gVxuICAgICAgICAgICAgICAgICAgICBzYXZlcy5wdXNoKHJlc3VsdC5rZXkpO1xuICAgICAgICAgICAgICAgICAgICAvLyDjgqvjg7zjgr3jg6vjgpLkuIDlgIvjgZrjgonjgZlcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LmNvbnRpbnVlKCk7XG4gICAgICAgICAgICAgICAgfVxuXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZ2V0QWxsS2V5cyhkYikge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgcmVxID0gZGIudHJhbnNhY3Rpb24oW3RoaXMuc3RvcmVOYW1lXSkub2JqZWN0U3RvcmUodGhpcy5zdG9yZU5hbWUpXG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUoW10pXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChyZXEuZ2V0QWxsS2V5cykge1xuICAgICAgICAgICAgICAgIHJlcS5nZXRBbGxLZXlzKCkub25zdWNjZXNzID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvd3MgPSBldmVudC50YXJnZXQucmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlKHJvd3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IGF3YWl0IHRoaXMubG9hZEFsbEtleShkYilcbiAgICAgICAgICAgICAgICByZXNvbHZlKGVudHJpZXMpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXEub25lcnJvciA9IHJlamVjdFxuICAgICAgICB9KVxuICAgIH1cbn1cbiIsImltcG9ydCBEYXRhYmFzZUhhbmRsZXIgZnJvbSBcIi4vRGF0YWJhc2VIYW5kbGVyLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHVtbXlEYXRhYmFzZUhhbmRsZXIgZXh0ZW5kcyBEYXRhYmFzZUhhbmRsZXIge1xuICAgIGNvbnN0cnVjdG9yKGRiX25hbWUsIHZlcnNpb24sIHN0b3JlTmFtZSwgcHJpbWFyeUtleU5hbWUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiSW5kZXhlZERCIGlzIG5vdCBhdmFpbGFibGUgIVwiKVxuICAgICAgICBzdXBlcihkYl9uYW1lLCB2ZXJzaW9uLCBzdG9yZU5hbWUsIHByaW1hcnlLZXlOYW1lKVxuICAgICAgICB0aGlzLnN0b3JhZ2UgPSB7fVxuICAgIH1cblxuICAgIGNvbm5lY3QoKSB7XG4gICAgICAgIHJldHVybiB7fVxuICAgIH1cblxuICAgIHB1dChkYiwgb2JqKSB7XG4gICAgICAgIGlmIChkYi5oYXNPd25Qcm9wZXJ0eShvYmpbdGhpcy5wcmltYXJ5S2V5XSkpIHtcbiAgICAgICAgICAgIHZhciBvbGQgPSBkYltvYmpbdGhpcy5wcmltYXJ5S2V5XV1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciBvbGQgPSB7fVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5ld19lbnRyeSA9IE9iamVjdC5hc3NpZ24ob2xkLCBvYmopXG4gICAgICAgIGRiW29ialt0aGlzLnByaW1hcnlLZXldXSA9IG5ld19lbnRyeTtcbiAgICAgICAgcmV0dXJuIHsgW29ialt0aGlzLnByaW1hcnlLZXldXTogbmV3X2VudHJ5IH1cbiAgICB9XG5cbiAgICBnZXQoZGIsIGlkKSB7XG4gICAgICAgIGlmIChkYi5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYltpZF1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWRcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlbGV0ZShkYiwgaWQpIHtcbiAgICAgICAgaWYgKGRiLmhhc093blByb3BlcnR5KGlkKSkge1xuICAgICAgICAgICAgZGJbaWRdID0gbnVsbDtcbiAgICAgICAgICAgIHJldHVybiBpZFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgbG9hZEFsbChkYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMoZGIpXG4gICAgfVxuXG4gICAgZ2V0QWxsS2V5cyhkYikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMoZGIpXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgc3RhdGljU2V0dGluZ3MgfSBmcm9tIFwiLi9jb25maWcvY29uZmlnLmpzXCJcbmltcG9ydCBEYXRhYmFzZUhhbmRsZXIgZnJvbSBcIi4vRGF0YWJhc2VIYW5kbGVyLmpzXCJcbmltcG9ydCBEdW1teURhdGFiYXNlSGFuZGxlciBmcm9tIFwiLi9EdW1teURhdGFiYXNlSGFuZGxlci5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGNvbm5lY3REYXRhYmFzZShzdGF0ZSkge1xuICAgIHN0YXRlLnppcERCSGFuZGxlciA9ICh3aW5kb3cuaW5kZXhlZERCKVxuICAgICAgICA/ICghbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChcIkVkZ2VcIikpXG4gICAgICAgICAgICA/IG5ldyBEYXRhYmFzZUhhbmRsZXIoc3RhdGljU2V0dGluZ3MuZ2V0REJOYW1lKCksIDIsIHN0YXRpY1NldHRpbmdzLmdldFN0b3JhZ2VOYW1lKCksIFwiaWRcIilcbiAgICAgICAgICAgIDogbmV3IERhdGFiYXNlSGFuZGxlcihzdGF0aWNTZXR0aW5ncy5nZXREQk5hbWUoKSwgMSwgc3RhdGljU2V0dGluZ3MuZ2V0U3RvcmFnZU5hbWUoKSwgXCJpZFwiKVxuICAgICAgICA6IG5ldyBEdW1teURhdGFiYXNlSGFuZGxlcihzdGF0aWNTZXR0aW5ncy5nZXREQk5hbWUoKSwgMiwgc3RhdGljU2V0dGluZ3MuZ2V0U3RvcmFnZU5hbWUoKSwgXCJpZFwiKVxuICAgIHN0YXRlLnppcERCID0gYXdhaXQgc3RhdGUuemlwREJIYW5kbGVyLmNvbm5lY3QoKVxuICAgIHJldHVybiBzdGF0ZVxufTtcbiIsImV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGdldFN0b3JlZERCRW50cnlLZXlzKHN0YXRlKSB7XG4gICAgc3RhdGUuc3RvcmVkS2V5cyA9IGF3YWl0IHN0YXRlLnppcERCSGFuZGxlci5nZXRBbGxLZXlzKHN0YXRlLnppcERCKVxuICAgIHJldHVybiBzdGF0ZVxufVxuIiwiaW1wb3J0IHsgaGlkZUVycm9yTWVzc2FnZSB9IGZyb20gXCIuL2Vycm9yX2luZGljYXRvcl9oYW5kbGVyLmpzXCJcbmltcG9ydCB7IHNob3dMb2FkaW5nTWVzc2FnZSB9IGZyb20gXCIuL2xvYWRpbmdfaW5kaWNhdG9yX2hhbmRsZXIuanNcIlxuaW1wb3J0IHsgaGlkZVdlbGNvbWVCb2FyZCwgc2hvd1ZpZXdlciwgc2hvd05pY29sQnV0dG9uIH0gZnJvbSBcIi4vdmlld2VyX2hhbmRsZXJzLmpzXCJcbmltcG9ydCBxdWVyeUltYWdlUGFja2FnZSBmcm9tIFwiLi9xdWVyeUltYWdlUGFja2FnZS5qc1wiXG5pbXBvcnQgdXBkYXRlU3RhdGVCeU1ldGEgZnJvbSBcIi4vdXBkYXRlU3RhdGVCeU1ldGEuanNcIlxuaW1wb3J0IHVwZGF0ZVZpZXdEZXNjcmlwdGlvbiBmcm9tIFwiLi91cGRhdGVWaWV3RGVzY3JpcHRpb24uanNcIlxuaW1wb3J0IHVwZGF0ZUltYWdlU3JjIGZyb20gXCIuL3VwZGF0ZUltYWdlU3JjLmpzXCJcbmltcG9ydCByZWdpc3RlciBmcm9tIFwiLi9yZWdpc3Rlci5qc1wiXG5pbXBvcnQgbWFya0Rvd25sb2FkZWRPcHRpb24gZnJvbSBcIi4vbWFya0Rvd25sb2FkZWRPcHRpb24uanNcIlxuaW1wb3J0IHVwZGF0ZVZpZXcgZnJvbSBcIi4vdXBkYXRlVmlldy5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGZldGNoUGFja2FnZUJ5SWQoc3RhdGUsIHBhY2thZ2VJRCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShhc3luYyAocmVzLCByZWopID0+IHtcblxuICAgICAgICBzdGF0ZS5jYW5Sb3RhdGUgPSBmYWxzZTtcbiAgICAgICAgaGlkZUVycm9yTWVzc2FnZSgpXG4gICAgICAgIHNob3dMb2FkaW5nTWVzc2FnZSgpXG4gICAgICAgIGhpZGVXZWxjb21lQm9hcmQoKVxuICAgICAgICBzaG93Vmlld2VyKClcbiAgICAgICAgc2hvd05pY29sQnV0dG9uKClcblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgW3Jlc3BvbnNlLCBpc05ld0RhdGFdID0gYXdhaXQgcXVlcnlJbWFnZVBhY2thZ2Uoc3RhdGUsIHBhY2thZ2VJRCk7XG4gICAgICAgICAgICBjb25zdCBtYW5pZmVzdCA9IEpTT04ucGFyc2UocmVzcG9uc2UubWFuaWZlc3QpO1xuXG4gICAgICAgICAgICBjb25zdCBuZXdfc3RhdGUgPSBhd2FpdCB1cGRhdGVTdGF0ZUJ5TWV0YShzdGF0ZSkocGFja2FnZUlELCBtYW5pZmVzdClcbiAgICAgICAgICAgICAgICAudGhlbih1cGRhdGVWaWV3RGVzY3JpcHRpb24pXG4gICAgICAgICAgICAgICAgLnRoZW4odXBkYXRlSW1hZ2VTcmMocmVzcG9uc2UudGh1bWJuYWlsLCBcImpwZ1wiKSlcbiAgICAgICAgICAgICAgICAudGhlbih1cGRhdGVWaWV3KVxuXG4gICAgICAgICAgICBuZXdfc3RhdGUuY2FuUm90YXRlID0gdHJ1ZVxuXG4gICAgICAgICAgICBpZiAoaXNOZXdEYXRhKSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2UuemlwID0gYXdhaXQgcmVzcG9uc2UuemlwKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdXBkYXRlSW1hZ2VTcmMocmVzcG9uc2UuemlwLCByZXNwb25zZS5pbWFnZV9mb3JtYXQpKG5ld19zdGF0ZSlcbiAgICAgICAgICAgICAgICAudGhlbihzdGF0ZSA9PiByZWdpc3RlcihzdGF0ZSwgaXNOZXdEYXRhKShyZXNwb25zZSkpXG4gICAgICAgICAgICAgICAgLnRoZW4obWFya0Rvd25sb2FkZWRPcHRpb24ocGFja2FnZUlEKShtYW5pZmVzdCkpXG4gICAgICAgICAgICAgICAgLnRoZW4odXBkYXRlVmlldylcbiAgICAgICAgICAgICAgICAudGhlbihyZXMpXG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJlaihlKVxuICAgICAgICB9XG4gICAgfSlcbn0iLCIvKipcbiAqICBMYW5ndWFnZSBjb2RlIG9mIHNhbXBsZSBsaXN0IGlzIHN1Y2ggYXMgXCJqYVwiIG9yIFwiZW5cIi5cbiAqL1xuaW1wb3J0IGRlbGV0ZU9sZFZlcnNpb25EYXRhYmFzZSBmcm9tIFwiLi9kZWxldGVPbGRWZXJzaW9uRGF0YWJhc2UuanNcIlxuaW1wb3J0IHNldFRvZ2dsZU5pY29sRXZlbnRzIGZyb20gXCIuL3NldFRvZ2dsZU5pY29sRXZlbnRzLmpzXCJcbmltcG9ydCBzZXRSb2NrU2VsZWN0RXZlbnRIYW5kbGVycyBmcm9tIFwiLi9zZXRSb2NrU2VsZWN0RXZlbnRIYW5kbGVycy5qc1wiXG5pbXBvcnQgc2V0Q2FudmFzRXZlbnRIYW5kbGVycyBmcm9tIFwiLi9zZXRDYW52YXNFdmVudEhhbmRsZXJzLmpzXCJcbmltcG9ydCBzZXRMYW5ndWFnZVNlbGVjdEV2ZW50SGFuZGxlcnMgZnJvbSBcIi4vc2V0TGFuZ3VhZ2VTZWxlY3RFdmVudEhhbmRsZXJzLmpzXCJcbmltcG9ydCBzZXRDb250YWN0Rm9ybUV2ZW50SGFuZGxlcnMgZnJvbSBcIi4vc2V0Q29udGFjdEZvcm1FdmVudEhhbmRsZXJzLmpzXCJcbmltcG9ydCBpbml0U3RhdGUgZnJvbSBcIi4vaW5pdFN0YXRlLmpzXCJcbmltcG9ydCB1cGRhdGVWaWV3ZXJHZW9tZXRyeSBmcm9tIFwiLi91cGRhdGVWaWV3ZXJHZW9tZXRyeS5qc1wiXG5pbXBvcnQgdXBkYXRlVmlldyBmcm9tIFwiLi91cGRhdGVWaWV3LmpzXCJcbmltcG9ydCBlczZBdmFpbGFibGUgZnJvbSBcIi4vZXM2QXZhaWxhYmxlLmpzXCJcbmltcG9ydCBjb25uZWN0TG9jYWxTdG9yYWdlIGZyb20gXCIuL2Nvbm5lY3RMb2NhbFN0b3JhZ2UuanNcIlxuaW1wb3J0IGNoZWNrU3VwcG9ydGVkSW1hZ2VGb3JtYXQgZnJvbSBcIi4vY2hlY2tTdXBwb3J0ZWRJbWFnZUZvcm1hdC5qc1wiXG5pbXBvcnQgb3ZlcnJpZGVMYW5ndWFnZUJ5TG9jYWxTdG9yYWdlIGZyb20gXCIuL292ZXJyaWRlTGFuZ3VhZ2VCeUxvY2FsU3RvcmFnZS5qc1wiXG5pbXBvcnQgY29ubmVjdERhdGFiYXNlIGZyb20gXCIuL2Nvbm5lY3REYXRhYmFzZS5qc1wiXG5pbXBvcnQgZ2V0U3RvcmVkREJFbnRyeUtleXMgZnJvbSBcIi4vZ2V0U3RvcmVkREJFbnRyeUtleXMuanNcIlxuaW1wb3J0IGxvYWRTYW1wbGVMaXN0RnJvbVJlbW90ZSBmcm9tIFwiLi9sb2FkU2FtcGxlTGlzdEZyb21SZW1vdGUuanNcIlxuaW1wb3J0IHsgaGlkZUxvYWRpbmdNZXNzYWdlIH0gZnJvbSBcIi4vbG9hZGluZ19pbmRpY2F0b3JfaGFuZGxlci5qc1wiXG5pbXBvcnQgZmV0Y2hQYWNrYWdlQnlJZCBmcm9tIFwiLi9mZXRjaF9wYWNrYWdlX2J5X3F1ZXJ5LmpzXCJcblxuZGVsZXRlT2xkVmVyc2lvbkRhdGFiYXNlKClcblxuXG5cblxuZnVuY3Rpb24gaGFuZGxlRXJyb3JzKHJlc3BvbnNlKSB7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICBjYXNlIDQwMDogdGhyb3cgbmV3IEVycm9yKCdJTlZBTElEX1RPS0VOJyk7XG4gICAgICAgIGNhc2UgNDAxOiB0aHJvdyBuZXcgRXJyb3IoJ1VOQVVUSE9SSVpFRCcpO1xuICAgICAgICBjYXNlIDUwMDogdGhyb3cgbmV3IEVycm9yKCdJTlRFUk5BTF9TRVJWRVJfRVJST1InKTtcbiAgICAgICAgY2FzZSA1MDI6IHRocm93IG5ldyBFcnJvcignQkFEX0dBVEVXQVknKTtcbiAgICAgICAgY2FzZSA0MDQ6IHRocm93IG5ldyBFcnJvcignTk9UX0ZPVU5EJyk7XG4gICAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcignVU5IQU5ETEVEX0VSUk9SJyk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBpc01vYmlsZUVudih1c2VyQWdlbnQpIHtcbiAgICByZXR1cm4gKHVzZXJBZ2VudC5pbmRleE9mKFwiaVBob25lXCIpID49IDAgfHwgdXNlckFnZW50LmluZGV4T2YoXCJpUGFkXCIpID49IDAgfHwgdXNlckFnZW50LmluZGV4T2YoXCJBbmRyb2lkXCIpID49IDApXG59XG5cbmZ1bmN0aW9uIG5vdGlmeUluY29tcGF0aWJsZUVudigpIHtcbiAgICB2YXIgd2Fybm5pbmdDYXJkID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwbGVhc2VfdXNlX21vZGVybl9icm93c2VyXCIpXG4gICAgd2Fybm5pbmdDYXJkLmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKVxufVxuXG5jb25zdCBnZXRfcGFja2FnZV9pZCA9ICgpID0+IHtcbiAgICBjb25zdCBoYXNoID0gbG9jYXRpb24uaGFzaC5zbGljZSgxKVxuICAgIHJldHVybiBoYXNoID09PSBcIlwiID8gdW5kZWZpbmVkIDogaGFzaFxufVxuXG4vKipcbiAgICAqXG4gICAgKiBFbnRyeSBwb2ludCBmdW5jdGlvbiAhXG4gICAgKi9cbmZ1bmN0aW9uIGluaXQoc3RhdGUpIHtcbiAgICAvLyBDaGVjayBFUzYgYXZhaWxhYmlsaXR5XG4gICAgLy8gU2V0IHdpbmRvdyBldmVudCBsaXN0ZW5lclxuICAgIC8vXG4gICAgaWYgKCFlczZBdmFpbGFibGUpIHtcbiAgICAgICAgbm90aWZ5SW5jb21wYXRpYmxlRW52KClcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8g44K544Oe44O844OI44OV44Kp44Oz44Gu5aC05ZCI44Gvb3JpZW50YXRpb25jaGFuZ2XjgqTjg5njg7Pjg4jjgpLnm6PoppbjgZnjgotcbiAgICBpZiAoaXNNb2JpbGVFbnYobmF2aWdhdG9yLnVzZXJBZ2VudCkpXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJvcmllbnRhdGlvbmNoYW5nZVwiLFxuICAgICAgICAgICAgZSA9PiB1cGRhdGVWaWV3ZXJHZW9tZXRyeShzdGF0ZSkudGhlbih1cGRhdGVWaWV3KSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgICk7XG5cblxuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInJlc2l6ZVwiLFxuICAgICAgICBlID0+IHVwZGF0ZVZpZXdlckdlb21ldHJ5KHN0YXRlKS50aGVuKHVwZGF0ZVZpZXcpLFxuICAgICAgICBmYWxzZVxuICAgICk7XG5cblxuICAgIHVwZGF0ZVZpZXdlckdlb21ldHJ5KHN0YXRlKVxuICAgICAgICAudGhlbihjb25uZWN0TG9jYWxTdG9yYWdlKVxuICAgICAgICAudGhlbihjaGVja1N1cHBvcnRlZEltYWdlRm9ybWF0KVxuICAgICAgICAudGhlbihvdmVycmlkZUxhbmd1YWdlQnlMb2NhbFN0b3JhZ2UpXG4gICAgICAgIC50aGVuKGNvbm5lY3REYXRhYmFzZSlcbiAgICAgICAgLnRoZW4oZ2V0U3RvcmVkREJFbnRyeUtleXMpXG4gICAgICAgIC50aGVuKGxvYWRTYW1wbGVMaXN0RnJvbVJlbW90ZSlcbiAgICAgICAgLnRoZW4oc3RhdGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgcGFja2FnZUlEID0gZ2V0X3BhY2thZ2VfaWQoKVxuICAgICAgICAgICAgaWYgKHBhY2thZ2VJRCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHBhY2thZ2VJRClcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hQYWNrYWdlQnlJZChzdGF0ZSwgcGFja2FnZUlEKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RhdGVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgLnRoZW4oaGlkZUxvYWRpbmdNZXNzYWdlKVxuICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpXG4gICAgICAgICAgICBoaWRlTG9hZGluZ01lc3NhZ2UoZSk7XG4gICAgICAgIH0pXG5cblxuICAgIHNldFRvZ2dsZU5pY29sRXZlbnRzKHN0YXRlKVxuICAgIHNldFJvY2tTZWxlY3RFdmVudEhhbmRsZXJzKHN0YXRlKVxuICAgIHNldENhbnZhc0V2ZW50SGFuZGxlcnMoc3RhdGUpXG4gICAgc2V0TGFuZ3VhZ2VTZWxlY3RFdmVudEhhbmRsZXJzKHN0YXRlKVxuICAgIHNldENvbnRhY3RGb3JtRXZlbnRIYW5kbGVycyhzdGF0ZSlcblxufVxuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICBcIkRPTWNvbnRlbnRsb2FkZWRcIixcbiAgICBpbml0KGluaXRTdGF0ZSgpKSxcbiAgICBmYWxzZVxuKVxuIl0sIm1hcHBpbmdzIjoiOzs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7OztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQkE7QUFDQTtBQUNBOzs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNqSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM3QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDekJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ25CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzVDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzdCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3BCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBOzs7QUNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')}]);