!function(g){var I={};function n(t){if(I[t])return I[t].exports;var e=I[t]={i:t,l:!1,exports:{}};return g[t].call(e.exports,e,e.exports,n),e.l=!0,e.exports}n.m=g,n.c=I,n.d=function(g,I,t){n.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:t})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,I){if(1&I&&(g=n(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var e in g)n.d(t,e,function(I){return g[I]}.bind(null,e));return t},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/getMaxViewerSize.js\nfunction getMaxViewerSize() {\n    const topBarSpaceHeight = 200 // px\n    const width = window.innerWidth\n    const height = window.innerHeight - topBarSpaceHeight\n    return width < height ? width : height\n}\n\n// CONCATENATED MODULE: ./src/js/remote_repo/static/filter_by_category.js\nclass SampleFilter {\n    constructor(queries = []) {\n        this.queries = new Set(queries.map(this.listToQuery))\n    }\n\n    add(query) {\n        this.queries.add(this.listToQuery(query))\n    }\n\n    addMany(queries) {\n        queries.forEach(v => {\n            this.queries.add(this.listToQuery(v))\n        })\n    }\n\n    remove(value) {\n        this.queries.delete(this.listToQuery(value))\n    }\n\n    removeMany(values) {\n        values.forEach(v => {\n            this.queries.delete(this.listToQuery(v))\n        })\n    }\n\n    reset(queries) {\n        this.queries = new Set(queries.map(this.listToQuery))\n    }\n\n    list() {\n        return this.queries\n    }\n\n    listToQuery(path) {\n        return path.reduce((acc, e) => {\n            if (acc === "") return e\n            return acc + "::" + e\n        }, "")\n    }\n\n    filter(sampleList) {\n        if (this.queries.size === 0) return sampleList\n\n        const queries = [...this.queries].map(v => v.split("::"))\n        return sampleList.filter(sample => {\n            if (!sample.hasOwnProperty("category")) return false\n            const superset = new Set(sample.category)\n            for (let query of queries) {\n                if (isSubset(query, superset)) return true\n            }\n        })\n    }\n}\n\n\n/**\n *\n * @param {Set} set\n * @param {Set} superset\n */\nfunction isSubset(set, superset) {\n    if (set.size == 0) {\n        return true\n    }\n    for (let elem of set) {\n        if (!superset.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// CONCATENATED MODULE: ./src/js/local_storage/NativeLocalStorage.js\nclass NativeLocalStorage {\n    constructor() {\n        this.db = window.localStorage\n    }\n\n    put(key, value) {\n        this.db.setItem(key, value);\n    }\n\n    get(key) {\n        const value = this.db.getItem(key)\n        return (value == null)\n            ? undefined\n            : value\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/local_storage/DummyLocalStorage.js\nclass DummyLocalStorage {\n    constructor() {\n        this.db = {}\n    }\n\n    put(key, value) {\n        this.db[key] = value;\n    }\n\n    get(key) {\n        return (this.db.hasOwnProperty("key"))\n            ? this.db[key]\n            : undefined\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/config/config.js\n/**\n * TODO split these config as different objects\n *\n * - Package list endpoint\n * - Package CDN endpoint\n * - Cache DB version name\n * - Cache DB table name\n */\n\n\n\nclass Config {\n    constructor() {\n        this.endpoint = compileEnv == "production"\n            ? "https://d3uqzv7l1ih05d.cloudfront.net/"\n            : "../../image_package_root/"\n\n        this.indexedDBName = "db_v3"\n        this.storageName = "files"\n    }\n\n    getSampleListURL() {\n        return this.endpoint + "rock_list.json"\n    }\n\n    getSampleCategoryURL() {\n        return this.endpoint + "category.json"\n    }\n\n    getImageDataPath(packageName) {\n        return this.endpoint + "packages/" + packageName + "/"\n    }\n\n    getDBName() {\n        return this.indexedDBName;\n    }\n\n    getStorageName() {\n        return this.storageName\n    }\n}\n\n\nconst compileEnv = "production"\n\nconsole.info("config.js: compileEnv: ", compileEnv)\n\nconst staticSettings = new Config()\n\nconst VIEW_PADDING = 0 // px\n\nconst cacheStorage = window.localStorage\n    ? new NativeLocalStorage()\n    : new DummyLocalStorage()\n// CONCATENATED MODULE: ./src/js/state/ui_state.js\n\n\n\nfunction overrideLanguageByLocalStorage(systemLanguage) {\n    const langInLocalStorage = cacheStorage.get("language")\n    const lang = (langInLocalStorage !== undefined)\n        ? langInLocalStorage\n        : systemLanguage;\n    document.querySelector("option[value=" + lang + "]").selected = true\n    return lang\n}\n\nfunction getSystemLanguage() {\n    const code = (window.navigator.languages && window.navigator.languages[0]) ||\n        window.navigator.language ||\n        window.navigator.userLanguage ||\n        window.navigator.browserLanguage;\n\n    const lang = code.match("ja") ? "ja" : "en";\n\n    return lang\n}\n\nconst uiState = {\n    "sampleFilter": new SampleFilter(),\n    "storedKeys": [],\n    "language": overrideLanguageByLocalStorage(getSystemLanguage()),\n}\n// CONCATENATED MODULE: ./src/js/state/viewer_state.js\n\n\nconst viewerState = {\n    "containorID": "",\n    "imageNumber": 1,\n    "canvasWidth": getMaxViewerSize() <= 500\n        ? getMaxViewerSize()\n        : 500,\n    "canvasHeight": getMaxViewerSize() <= 500\n        ? getMaxViewerSize()\n        : 500,\n    "imageRadius": 0,\n    "open_image_srcs": [],\n    "open_images": [],\n    "cross_image_srcs": [],\n    "cross_images": [],\n    "rotate": 0,\n    "rotate_axis_translate": [],\n    "isClockwise": true,\n    "isCrossNicol": false,\n    "drawHairLine": true,\n    "canRotate": true,\n}\n// CONCATENATED MODULE: ./src/js/state/initState.js\n\n\n\n\nfunction initState() {\n    return {\n        "isMousedown": false,\n        "drag_start": [0, 0],\n        "drag_end": [0, 0],\n        "uiState": uiState,\n        ...viewerState // TODO viewerState should be independent\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/package_manifest.js\nclass PackageManifest {\n    constructor() {\n        this.packageID = null\n        this.listName = {}\n        this.location = {}\n        this.owner = {}\n        this.rockType = {}\n        this.description = {}\n        this.geoSystem = ""\n        this.geoPosition = [null, null]\n        this.rotateCenter = [undefined, undefined]\n        this.rotateDirection = "clockwise"\n        this.imageSize = { "width": 0, "height": 0 }\n    }\n\n    toJSON() {\n        return {\n            "package-id": this.getPackageID(),\n            "list-name": this.getListName(),\n            "image_width": this.getImageWidth(),\n            "image_height": this.getImageHeight(),\n            "rotate_center": this.getRotateCenter(),\n            "cycle_rotate_degree": this.getRotateSectionDegree(),\n            "rotate_clockwise": this.isRotateClockwise(),\n            "rotate_by_degree": this.getEachRotateDegree(),\n            "location": this.getSampleLocation(),\n            "owner": this.getOwner(),\n            "rock_type": this.getRockType(),\n            "description": this.getDescription(),\n            "scale-unit": this.getScaleUnit(),\n            "scale-pixel": this.getScalePixel(),\n            "magnify": this.getMagnify(),\n            "sample_label": this.getSampleLabel(),\n            "geographic-coordinate": this.getGeoLocation(),\n            "image_formats": this.getImageFormats()\n        }\n    }\n\n    getSampleListEntry() {\n        return {\n            "package-name": this.getPackageID(),\n            "list-name": this.getListName()\n        }\n    }\n\n    setPackageID(id) {\n        this.packageID = id\n        return this\n    }\n\n    getPackageID() {\n        return this.packageID || ""\n    }\n\n    setListName(lang, s) {\n        this.listName[lang] = s;\n        return this;\n    }\n\n    getListName() {\n        return this.listName;\n    }\n\n    setSampleLocation(lang, desc) {\n        this.location[lang] = desc;\n        return this\n    }\n\n    getSampleLocation() {\n        return this.location;\n    }\n\n    setLocation(system, v1, v2) {\n        this.geoSystem = system,\n            this.geoPosition = [v1, v2]\n        return this\n    }\n\n    getGeoLocation() {\n        return {\n            "system": this.geoSystem,\n            "position": {\n                "latitude": this.geoPosition[0],\n                "longitude": this.geoPosition[1]\n            }\n        }\n    }\n\n    setMagnify(magnificationValue) {\n        this.magnify = magnificationValue\n        return this\n    }\n\n    getMagnify() {\n        return this.magnify\n    }\n\n    setScaleUnit(scaleUnit) {\n        this.scaleUnit = scaleUnit;\n        return this\n    }\n\n    getScaleUnit() {\n        return this.scaleUnit\n    }\n\n    setScalePixel(scaleLengthAsPixel) {\n        this.scalePixel = scaleLengthAsPixel\n        return this\n    }\n\n    getScalePixel() {\n        return this.scalePixel\n    }\n\n    setSampleLabel(s) {\n        this.sampleLabel = s\n    }\n\n    getSampleLabel() {\n        return this.sampleLabel || ""\n    }\n\n    setImageSize(img) {\n        this.imageSize = {\n            "width": img.width,\n            "height": img.height\n        }\n        return this\n    }\n\n    getImageWidth() {\n        return this.imageSize.width\n    }\n\n    getImageHeight() {\n        return this.imageSize.height\n    }\n\n    setRotateCenter(fromLeft, fromTop) {\n        this.rotateCenter = [fromLeft, fromTop]\n        return this\n    }\n\n    getRotateCenter() {\n        return [\n            this.rotateCenter[0] === undefined\n                ? this.getImageWidth() * 0.5\n                : this.rotateCenter[0],\n            this.rotateCenter[1] === undefined\n                ? this.getImageHeight() * 0.5\n                : this.rotateCenter[1]\n        ]\n    }\n\n    setImagesNumber(value) {\n        this.imagesNumber = value\n        return this\n    }\n\n    getImagesNumber() {\n        return this.imagesNumber\n    }\n\n    getRotateSectionDegree() {\n        return this.getEachRotateDegree() * (this.getImagesNumber() - 1)\n    }\n\n    setRotateDirection(direction) {\n        this.rotateDirection = direction\n        return this\n    }\n\n    isRotateClockwise() {\n        return this.rotateDirection === "clockwise"\n    }\n\n    setEachRotateDegree(degree) {\n        this.eachRotateDegree = degree\n        return this\n    }\n\n    getEachRotateDegree() {\n        return this.eachRotateDegree\n    }\n\n    setRockType(lang, desc) {\n        this.rockType[lang] = desc\n        return this\n    }\n\n    getRockType() {\n        return this.rockType\n    }\n\n    setOwner(lang, desc) {\n        this.owner[lang] = desc\n        return this\n    }\n\n    getOwner() {\n        return this.owner\n    }\n\n    setDescription(lang, desc) {\n        this.description[lang] = desc\n        return this\n    }\n\n    getDescription() {\n        return this.description\n    }\n\n    setImageFormats(formats) {\n        formats.forEach(format => {\n            console.assert(["webp", "jpg", "jp2"].includes(format))\n        })\n        this.imageFormats = formats\n    }\n\n    getImageFormats() {\n        return this.imageFormats || []\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/viewer_canvas.js\nconst viewer = document.querySelector("#main-viewer")\nconst viewer_ctx = viewer.getContext("2d")\n\n// CONCATENATED MODULE: ./src/js/updateViewerGeometry.js\n\n\n\nfunction updateViewerGeometry(state) {\n    return new Promise((res, rej) => {\n        const padding = 20 // px\n        state.canvasWidth = getMaxViewerSize() - padding\n        state.canvasHeight = getMaxViewerSize() - padding\n\n        viewer.width = state.canvasWidth\n        viewer.height = state.canvasHeight\n        viewer_ctx.translate(state.canvasWidth * 0.5, state.canvasHeight * 0.5)\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/sanitizeID.js\nfunction sanitizeID(id) {\n    return id.replace(/\\//g, "_").replace(/\\./g, "")\n}\n\n// CONCATENATED MODULE: ./src/js/rotation_degree_handlers.js\nconst stepBy = unit => val => Math.floor(val / unit)\n\nconst cycleBy = unit => val => {\n    const cycle_count = Math.floor(val / unit)\n    return val < 0\n        ? val + unit\n        : (unit <= val)\n            ? val - unit * cycle_count\n            : val\n}\n\nconst rotation_degree_handlers_mirrorBy = (center) => val => val > center ? 2 * center - val : val\n\nconst isInverse = degree => (180 <= degree)\n\nconst rotateSign = (clockwise = true) => clockwise ? -1 : 1\n\n// CONCATENATED MODULE: ./src/js/updateStateByMeta.js\n\n\n\nfunction getRotationCenter(meta) {\n    return (meta.hasOwnProperty("rotate_center"))\n        ? {\n            "to_right": meta.rotate_center[0],\n            "to_bottom": meta.rotate_center[1]\n        }\n        : {\n            "to_right": meta.image_width * 0.5,\n            "to_bottom": meta.image_height * 0.5\n        }\n}\n\nfunction getImageRadius(meta) {\n    const shift = getRotationCenter(meta);\n    const image_center = {\n        "x": meta.image_width * 0.5,\n        "y": meta.image_height * 0.5\n    }\n    return Math.min(\n        image_center.x - Math.abs(image_center.x - shift.to_right),\n        image_center.y - Math.abs(image_center.y - shift.to_bottom)\n    )\n}\n\nfunction mapMetadata(meta) {\n    const rotate_degree_step = parseInt(meta.rotate_by_degree)\n\n    return {\n        isClockwise: meta.rotate_clockwise,\n        location: meta.location,\n        rockType: meta.rock_type,\n        owner: meta.owner,\n        description: meta.hasOwnProperty("discription")\n            ? meta.discription\n            : meta.hasOwnProperty("description")\n                ? meta.description\n                : {},\n        rotate_center: getRotationCenter(meta),\n        imageWidth: meta.image_width,\n        imageHeight: meta.image_height,\n        imageRadius: getImageRadius(meta),\n        imageRadiusOriginal: getImageRadius(meta),\n        scaleWidth: meta.hasOwnProperty("scale-pixel")\n            ? parseInt(meta["scale-pixel"])\n            : false,\n        scaleText: meta.hasOwnProperty("scale-unit")\n            ? meta["scale-unit"]\n            : false,\n        rotate_degree_step: rotate_degree_step\n    }\n}\n\nfunction updateStateByMeta(state) {\n    return (containorID, meta) => new Promise((res, rej) => {\n\n        state.containorID = sanitizeID(containorID);\n\n        const rotate_degree_step = parseInt(meta.rotate_by_degree)\n        const cycle_degree = meta.hasOwnProperty("cycle_rotate_degree")\n            ? parseInt(meta.cycle_rotate_degree)\n            : 90;\n        const image_number = cycle_degree / rotate_degree_step + 1\n        const mirror_at = (image_number - 1)\n        const total_step = (image_number - 1) * 2\n\n        state.image_number = image_number\n        state.getImageNumber = cycle_degree > 0\n            ? degree => cycleBy(image_number - 1)(\n                stepBy(rotate_degree_step)(state.isClockwise ? 360 - degree : degree)\n            )\n            : degree => mirrorBy(mirror_at)(\n                cycleBy(total_step)(\n                    stepBy(rotate_degree_step)(degree)\n                )\n            )\n\n        state.getAlpha = degree => {\n            const nth = cycleBy(total_step * 2)(\n                stepBy(rotate_degree_step)(degree)\n            )\n            return 1 - (degree - rotate_degree_step * nth) / rotate_degree_step\n        }\n\n        state.open_images = []\n        state.cross_images = []\n\n        state.rotate = 0;\n\n        state = Object.assign(state, mapMetadata(meta))\n\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/viewer_handlers.js\n\n\nconst hideWelcomeBoard = state => {\n    const board = document.querySelector("#welcome-card")\n    board.classList.add("inactive");\n    return state\n}\n\nconst showViewer = state => {\n    const card = document.querySelector("#viewer_wrapper")\n    card.classList.remove("inactive")\n    return state\n}\n\nconst showNicolButton = state => {\n    const button = document.querySelector("#low-navigation")\n    button.classList.remove("inactive");\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/clipGeometryFromImageCenter.js\nfunction clipGeometoryFromImageCenter(state) {\n\n    return [\n        state.rotate_center.to_right - state.imageRadius,\n        state.rotate_center.to_bottom - state.imageRadius,\n        state.imageRadius * 2,\n        state.imageRadius * 2\n    ]\n}\n\n// CONCATENATED MODULE: ./src/js/draw_state_updators.js\n\n\n\n\n\nfunction clearView(state) {\n    viewer_ctx.clearRect(-state.canvasWidth * 0.5, -state.canvasHeight * 0.5, state.canvasWidth, state.canvasHeight)\n    return state\n}\n\nfunction blobToCanvas(state) {\n\n    const image_srcs = state.isCrossNicol\n        ? state.cross_images\n        : state.open_images\n\n    // view window circle\n\n    viewer_ctx.save()\n    viewer_ctx.beginPath()\n    viewer_ctx.arc(0, 0, state.canvasWidth / 2 - VIEW_PADDING, 0, Math.PI * 2, false)\n    viewer_ctx.clip()\n\n    // Draw a image\n    const alpha = state.getAlpha(state.rotate)\n\n    viewer_ctx.rotate(\n        rotateSign(state.isClockwise) * (state.rotate + state.getImageNumber(state.rotate) * state.rotate_degree_step) / 180 * Math.PI\n    )\n\n    viewer_ctx.globalAlpha = 1\n    const image1 = image_srcs[state.getImageNumber(state.rotate)]\n\n    try {\n        viewer_ctx.drawImage(\n            image1,\n            ...clipGeometoryFromImageCenter(state),\n            -state.canvasWidth / 2,\n            -state.canvasHeight / 2,\n            state.canvasWidth,\n            state.canvasHeight\n        );\n    } catch (e) {\n\n    }\n\n    viewer_ctx.restore()\n\n    // Draw next image\n    viewer_ctx.save()\n    viewer_ctx.beginPath()\n    viewer_ctx.arc(0, 0, state.canvasWidth / 2 - VIEW_PADDING, 0, Math.PI * 2, false)\n    viewer_ctx.clip()\n\n    viewer_ctx.rotate(\n        rotateSign(state.isClockwise) * (state.rotate + state.getImageNumber(state.rotate + state.rotate_degree_step) * state.rotate_degree_step) / 180 * Math.PI\n    )\n\n    viewer_ctx.globalAlpha = 1 - alpha\n    const image2 = image_srcs[state.getImageNumber(state.rotate + state.rotate_degree_step)]\n    try {\n        viewer_ctx.drawImage(\n            image2,\n            ...clipGeometoryFromImageCenter(state),\n            -state.canvasWidth / 2,\n            -state.canvasHeight / 2,\n            state.canvasWidth,\n            state.canvasHeight)\n    } catch (e) {\n\n    }\n    viewer_ctx.restore()\n    return state\n}\n\nfunction drawHairLine(state) {\n    if (!state.drawHairLine) return\n    viewer_ctx.strokeStyle = state.isCrossNicol\n        ? "white"\n        : "black";\n    viewer_ctx.globalAlpha = 1\n    viewer_ctx.beginPath()\n    viewer_ctx.moveTo(0, -state.canvasHeight * 0.5 + VIEW_PADDING)\n    viewer_ctx.lineTo(0, state.canvasHeight * 0.5 - VIEW_PADDING)\n    viewer_ctx.moveTo(-state.canvasWidth * 0.5 + VIEW_PADDING, 0)\n    viewer_ctx.lineTo(state.canvasWidth * 0.5 - VIEW_PADDING, 0)\n    viewer_ctx.closePath()\n    viewer_ctx.stroke()\n    return state\n}\n\nconst scaleLength = (canvasWidth, imageWidth, scaleWidth) => canvasWidth * scaleWidth / imageWidth\n\nfunction drawScale(state) {\n    if (!state["scaleWidth"]) return;\n    let scalePixel = scaleLength(state.canvasWidth, state.imageRadius * 2, state.scaleWidth)\n    const canvasWidth = state.canvasWidth;\n    const scaleBar = document.querySelector("#scalebar")\n\n\n    let scaleNumber = state.scaleText.match(/(\\d+\\.?\\d*)/)[0] * 1\n    const scaleUnit = state.scaleText.match(/\\D*$/)[0]\n\n    while (scalePixel >= canvasWidth) {\n        scalePixel *= 0.5\n        scaleNumber *= 0.5\n    }\n    scaleBar.style.width = scalePixel + "px";\n    scaleBar.querySelector("div:first-child").innerHTML = `${scaleNumber} ${scaleUnit}`;\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/getCoordinateOnCanvas.js\nfunction getCoordinateOnCanvas(canvas) {\n    return (e, fingur = 0) => {\n        if (e instanceof MouseEvent) {\n            return (e instanceof WheelEvent)\n                ? [\n                    e.deltaX,\n                    e.deltaY\n                ]\n                : [\n                    e.pageX - canvas.offsetLeft,\n                    e.pageY - canvas.offsetTop\n                ]\n        } else if (e instanceof TouchEvent && e.touches.length > fingur) {\n            return [\n                e.touches[fingur].pageX - canvas.offsetLeft,\n                e.touches[fingur].pageY - canvas.offsetTop\n            ]\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/radiunBetween.js\nfunction radiunBetween(cx, cy) {\n    return (_x1, _y1, _x2, _y2) => {\n        const x1 = _x1 - cx\n        const x2 = _x2 - cx\n        const y1 = _y1 - cy\n        const y2 = _y2 - cy\n\n        const cos = (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n        return Math.sign(x1 * y2 - x2 * y1) * Math.acos(cos)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/coordinate_updators.js\n\n\n\n\n\nconst canvasCoordinate = getCoordinateOnCanvas(viewer)\n\n/**\n * Update start and end position\n * @param {*} state\n * @param {*} e\n */\nfunction updateCoordinate(state, e) {\n    state.drag_start = state.drag_end || undefined\n    state.drag_end = canvasCoordinate(e)\n\n    state.pinch_start = state.pinch_end || undefined\n    state.pinch_end = canvasCoordinate(e, 1)\n    return state\n}\n\n/**\n * Calculate small difference of rotation.\n * Update total rotation.\n *\n * @param {*} state\n * @param {*} e\n */\nfunction updateRotate(state, e) {\n    if (!state.canRotate) return;\n    if (state.drag_start === undefined) return\n    // delta rotate radius\n    const rotate_end = radiunBetween(\n        state.canvasWidth * 0.5,\n        state.canvasHeight * 0.5\n    )(...state.drag_end, ...state.drag_start)\n\n    state.rotate += rotate_end / Math.PI * 180\n    if (state.rotate >= 360) {\n        state.rotate -= 360\n    } else if (state.rotate < 0) {\n        state.rotate += 360\n    }\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/rotateImage.js\n\n\n\nfunction rotateImage(state, e) {\n    return () => {\n        updateCoordinate(state, e)\n        updateRotate(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateMagnify.js\n\n\nfunction updateMagnifyByPinch(state, e) {\n    if (state.drag_start === undefined) return\n    if (state.pinch_start === undefined) return\n\n    const x1 = [...state.drag_start]\n    const y1 = [...state.pinch_start]\n    const x2 = [...state.drag_end]\n    const y2 = [...state.pinch_end]\n\n    const expansion = Math.sqrt((x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2) / Math.sqrt((x1[0] - y1[0]) ** 2 + (x1[1] - y1[1]) ** 2)\n\n    const newRadius = (expansion > 2)\n        ? state.imageRadius\n        : state.imageRadius / expansion\n    state.imageRadius = (newRadius) > state.imageRadiusOriginal\n        ? state.imageRadiusOriginal\n        : (newRadius < 100)\n            ? 100\n            : newRadius\n    return state\n}\n\nfunction updateMagnifyByWheel(state, e) {\n    const scrolled = canvasCoordinate(e)[1]\n\n    const newRadius = state.imageRadius + scrolled\n    state.imageRadius = (newRadius) > state.imageRadiusOriginal\n        ? state.imageRadiusOriginal\n        : (newRadius < 100)\n            ? 100\n            : newRadius\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/pinchImage.js\n\n\n\n\nfunction pinchImage(state, e) {\n    return () => {\n        updateCoordinate(state, e)\n        updateMagnifyByPinch(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n        drawScale(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/touchEventHandlers.js\n\n\n\n\nconst touchStartHandler = state => e => {\n    state.isMousedown = true\n    state.drag_end = canvasCoordinate(e)\n    e.preventDefault();\n}\n\nconst touchMoveHandler = state => e => {\n    if (!state.isMousedown) return\n    if (e instanceof MouseEvent || e.touches.length === 1) {\n        e.preventDefault();\n        requestAnimationFrame(\n            rotateImage(state, e)\n        )\n    } else if (e.touches.length === 2) {\n        e.preventDefault()\n        requestAnimationFrame(\n            pinchImage(state, e)\n        )\n    }\n}\n\nconst touchEndHandler = state => e => {\n    state.isMousedown = false\n    state.drag_end = undefined\n    state.pinch_end = undefined\n    e.preventDefault()\n}\n\n// CONCATENATED MODULE: ./src/js/wheelImage.js\n\n\n\nfunction wheelImage(state, e) {\n    return () => {\n        updateMagnifyByWheel(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n        drawScale(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/wheelEventHandler.js\n\n\nconst wheelHandler = state => e => {\n    e.preventDefault();\n    requestAnimationFrame(\n        wheelImage(state, e)\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/index_make_package.js\n\n\n\n\n\n\n\n\n\n\n\nconst packageMap = new PackageManifest();\nconst upload_state = Object.assign(\n    initState(),\n    {\n        "loadImages": [false, true],\n        "autoRotate": false,\n        "viewMode": "validation",\n        "language": "ja",\n        "desiredImageSize": 150,\n        "desiredThumbnailImageSize": 100,\n    }\n)\n\nfunction bothImagesLoaded(flags) {\n    return flags.reduce((acc, e) => acc && e, true)\n}\n\nfunction fileSelectHander(e) {\n    function read(file) {\n        return new Promise((res, rej) => {\n            const reader = new FileReader()\n            reader.readAsDataURL(file)\n            reader.onloadend = function () {\n                res(reader.result)\n            };\n        })\n    }\n\n    return new Promise((res, rej) => {\n        const files = e.target.files;\n        Promise.all(\n            Array.from(files)\n                .map(file => read(file))\n        ).then(res)\n    })\n}\n\nfunction readImageSize(state) {\n    packageMap.setImageSize(state.open_images[0])\n    return state\n}\n\nfunction readImagesNumber(state) {\n    packageMap.setImagesNumber(state.open_images.length)\n    return state\n}\n\nasync function showImages(state) {\n    readImageSize(state)\n    readImagesNumber(state)\n    const new_state = await updateStateByMeta(state, "upload")(packageMap.packageID, packageMap.toJSON())\n\n    new_state.open_images = await Promise.all(state.open_image_srcs.map(loadImageFromSrc))\n    new_state.cross_images = await Promise.all(state.cross_image_srcs.map(loadImageFromSrc))\n\n    return updateView(new_state)\n        .then(showViewer)\n        .then(showNicolButton)\n}\n\nfunction loadImageFromSrc(src) {\n    return new Promise((res, rej) => {\n\n        const img = new Image()\n\n        img.onload = _ => {\n            res(img)\n        }\n\n        img.src = src\n\n    })\n}\n\nfunction openImagesSelectHandler(state) {\n    return e => new Promise(async (res, rej) => {\n        state.open_image_srcs = await fileSelectHander(e)\n        state.loadImages[0] = true\n        state.open_images = await Promise.all(state.open_image_srcs.map(loadImageFromSrc))\n        await showImages(state)\n\n        res(state)\n    })\n}\n\nfunction crossImagesSelectHandler(state) {\n    return e => new Promise(async (res, rej) => {\n        state.cross_image_srcs = await fileSelectHander(e)\n        state.loadImages[1] = true\n        state.cross_images = await Promise.all(state.cross_image_srcs.map(loadImageFromSrc))\n        await showImages(state)\n\n        res(state)\n    })\n}\n\nasync function updateView(state) {\n    clearView(state)\n    blobToCanvas(state)\n    drawHairLine(state)\n    drawScale(state)\n    return state\n}\n\n\nfunction activateDom(selector) {\n    Array.from(document.querySelectorAll(selector))\n        .forEach(dom => {\n            dom.classList.remove("inactive")\n        })\n}\n\n\nfunction base64ToBlob(base64, mime) {\n    var binary = atob(base64);\n    var buffer = new Uint8Array(binary.length)\n    for (var i = 0; i < binary.length; i++) {\n        buffer[i] = binary.charCodeAt(i);\n    }\n    return new Blob([buffer.buffer], {\n        type: mime\n    });\n}\n\nfunction compressImageSrc(src, format, desiredKByte = 150) {\n    console.assert(["jpeg", "webp"].includes(format))\n\n    const image = new Image()\n    image.src = src\n    const w = image.width\n    const h = image.height\n    const cvs = document.querySelector("#working_canvas")\n    cvs.width = w\n    cvs.height = h\n    const ctx = cvs.getContext("2d")\n    ctx.drawImage(image, 0, 0, w, h)\n\n    const originalBinary = cvs.toDataURL(`image/${format}`); //画質落とさずバイナリ化\n    const mime = originalBinary.match(/(:)([a-z\\/]+)(;)/)[2]\n\n    const originalBlob = base64ToBlob(originalBinary.split(",")[1], mime);\n\n    if (desiredKByte * 1e3 < originalBlob["size"]) {\n        const capacityRatio = desiredKByte * 1e3 / originalBlob["size"];\n        const processingBinary = cvs.toDataURL(`image/${format}`, capacityRatio); //画質落としてバイナリ化\n        return base64ToBlob(processingBinary.split(",")[1], mime);\n    } else {\n        return originalBlob\n    }\n}\n\nfunction showErrorMessage(domId, message) {\n    const messageDom = document.querySelector(domId)\n    messageDom.innerHTML = message\n    messageDom.classList.remove("inactive")\n}\n\nfunction hideErrorMessage(domId) {\n    const messageDom = document.querySelector(domId)\n    messageDom.classList.add("inactive")\n}\n\n\nfunction sendSampleListEntry(json_obj) {\n    if (json_obj["package-name"].match(new RegExp("^[0-9a-zA-Z_-]+$")) === null) {\n        throw new Error("Package ID should contain only number, alphabet, _, and -.")\n    }\n    if (Object.keys(json_obj["list-name"]).length === 0) {\n        throw new Error("Sample title is not set.")\n    }\n    document.querySelector("#dev_sample_list_entry").innerHTML = JSON.stringify(json_obj, null, 2)\n};\n\nfunction initializeOrUpdateInput(inputDom, value) {\n    if (!inputDom.value) {\n        inputDom.value = value\n    }\n}\n\nfunction showPackageSize(state) {\n    // Sum open and cross images (contains thumbnail)\n    const imagesSize = (state.open_image_srcs.length * state.desiredImageSize + state.desiredThumbnailImageSize) * 2\n    document.querySelector("#message_package_size").innerHTML = imagesSize\n}\n\n(function (state) {\n    document.querySelector("#input_package_id").addEventListener(\n        "change",\n        e => {\n            packageMap.setPackageID(e.target.value)\n        },\n        false\n    )\n\n    document.querySelector("#input_desired_image_size").addEventListener(\n        "change",\n        e => {\n            state.desiredImageSize = parseFloat(e.target.value)\n            showPackageSize(state)\n        },\n        false\n    )\n\n    document.querySelector("#input_desired_thumbnail_image_size").addEventListener(\n        "change",\n        e => {\n            state.desiredThumbnailImageSize = parseFloat(e.target.value)\n            showPackageSize(state)\n        },\n        false\n    )\n\n    const centerToRight = document.querySelector("#rotate_center_from_left")\n    centerToRight.addEventListener(\n        "change",\n        e => {\n            state.rotate_center.to_right = parseFloat(centerToRight.value)\n            updateView(state)\n        },\n        false\n    )\n    const centerToBottom = document.querySelector("#rotate_center_from_top")\n    centerToBottom.addEventListener(\n        "change",\n        e => {\n            state.rotate_center.to_bottom = parseFloat(centerToBottom.value)\n            updateView(state)\n        },\n        false\n    )\n\n    document.querySelector("#open_nicol_images").addEventListener(\n        "change",\n        e => {\n            openImagesSelectHandler(state)(e).then(state => {\n                initializeOrUpdateInput(centerToRight, state.open_images[0].width / 2)\n                initializeOrUpdateInput(centerToBottom, state.open_images[0].height / 2)\n                showPackageSize(state)\n            })\n        },\n        false\n    )\n\n    document.querySelector("#cross_nicol_images").addEventListener(\n        "change",\n        e => {\n            crossImagesSelectHandler(state)(e).then(state => {\n                initializeOrUpdateInput(centerToRight, state.cross_images[0].width / 2)\n                initializeOrUpdateInput(centerToBottom, state.cross_images[0].height / 2)\n                showPackageSize(state)\n            })\n        },\n        false\n    )\n\n    const rotateDirectionSelector = document.querySelector("#select_rotate_direction")\n    rotateDirectionSelector.addEventListener(\n        "change",\n        e => {\n            const direction = e.target.options[e.target.selectedIndex].value\n            packageMap.setRotateDirection(direction)\n        },\n        false\n    )\n\n    const inputRotationInterval = document.querySelector("#input_rotation_interval")\n    inputRotationInterval.addEventListener(\n        "change",\n        e => {\n            packageMap.setEachRotateDegree(inputRotationInterval.value)\n            activateDom("#select_image_wrapper")\n        },\n        false\n    )\n\n    const inputScaleUnit = document.querySelector("#input_scale_unit")\n    inputScaleUnit.addEventListener(\n        "change",\n        e => {\n            packageMap.setScaleUnit(inputScaleUnit.value)\n        },\n        false\n    )\n\n    const inputScaleLength = document.querySelector("#input_scale_length")\n    inputScaleLength.addEventListener(\n        "change",\n        e => {\n            packageMap.setScalePixel(inputScaleLength.value)\n        },\n        false\n    )\n\n    const inputMagnification = document.querySelector("#input_magnification")\n    inputMagnification.addEventListener(\n        "change",\n        e => {\n            packageMap.setMagnify(e.target.value)\n        },\n        false\n    )\n\n    const inputSampleLabel = document.querySelector("#input_sample_label")\n    inputSampleLabel.addEventListener(\n        "change",\n        e => {\n            packageMap.setSampleLabel(e.target.value)\n        },\n        false\n    )\n\n    Array.from(document.querySelectorAll(".input_sample_location")).forEach(dom => {\n        dom.addEventListener(\n            "change",\n            e => {\n                packageMap.setSampleLocation(e.target.dataset.lang, e.target.value)\n            },\n            false\n        )\n    })\n\n    Array.from(document.querySelectorAll(".input_sample_type")).forEach(dom => {\n        dom.addEventListener(\n            "change",\n            e => {\n                packageMap.setRockType(e.target.dataset.lang, e.target.value)\n            },\n            false\n        )\n    })\n\n    Array.from(document.querySelectorAll(".input_description")).forEach(dom => {\n        dom.addEventListener(\n            "change",\n            e => {\n                packageMap.setDescription(e.target.dataset.lang, e.target.value)\n            },\n            false\n        )\n    })\n\n    Array.from(document.querySelectorAll(".input_sample_title"))\n        .forEach(dom => {\n            dom.addEventListener(\n                "change",\n                e => {\n                    packageMap.setListName(e.target.dataset.lang, e.target.value)\n\n                }\n            )\n        })\n\n    Array.from(document.querySelectorAll(".input_owner")).forEach(dom => {\n        dom.addEventListener(\n            "change",\n            e => {\n                packageMap.setOwner(e.target.dataset.lang, e.target.value)\n            },\n            false\n        )\n    })\n\n    const toggleNicolButton = document.querySelector("#change_nicol")\n    const toggleNicolLabel = document.querySelector("#change_nicol + label")\n\n    const toggleNicolHandler = state => new Promise((res, rej) => {\n\n        toggleNicolButton.checked = state.isCrossNicol\n        state.isCrossNicol = !state.isCrossNicol;\n\n        res(state)\n    })\n\n    toggleNicolButton.addEventListener(\n        "click",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n    toggleNicolLabel.addEventListener(\n        "touch",\n        e => { e.preventDefault() },\n        false\n    )\n\n    toggleNicolButton.addEventListener(\n        "touch",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n    toggleNicolLabel.addEventListener(\n        "mouseup",\n        e => toggleNicolHandler(state)\n            .then(updateView),\n        false\n    )\n\n    toggleNicolLabel.addEventListener(\n        "touchend",\n        e => toggleNicolHandler(state)\n            .then(updateView)\n            .then(_ => {\n                if (e.cancelable) {\n                    e.preventDefault();\n                }\n            }),\n        false\n    )\n\n    viewer.oncontextmenu = function (e) {\n        const position_on_canvas = canvasCoordinate(e)\n        const current_rotate_center = Object.values(state.rotate_center)\n        const shift = [\n            position_on_canvas[0] - state.canvasWidth * 0.5,\n            position_on_canvas[1] - state.canvasHeight * 0.5\n        ]\n\n        state.rotate_center.to_right += parseInt(shift[0] * state.imageRadius / state.canvasWidth * 2)\n        state.rotate_center.to_bottom += parseInt(shift[1] * state.imageRadius / state.canvasWidth * 2)\n\n        packageMap.setRotateCenter(\n            state.rotate_center.to_right,\n            state.rotate_center.to_bottom\n        )\n\n        centerToRight.value = state.rotate_center.to_right\n        centerToBottom.value = state.rotate_center.to_bottom\n\n        e.preventDefault()\n        updateView(state)\n        return false;\n    }\n\n    viewer.addEventListener(\n        "mousedown",\n        touchStartHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "dragstart",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "drag",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "dragend",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "touchstart",\n        touchStartHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "mousemove",\n        touchMoveHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "touchmove",\n        touchMoveHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "mouseup",\n        touchEndHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "touchend",\n        touchEndHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "wheel",\n        wheelHandler(state),\n        false\n    )\n\n    document.querySelector("#create_package_button").addEventListener(\n        "click",\n        e => {\n            e.preventDefault()\n            async function makeZip() {\n                const listEntry = packageMap.getSampleListEntry()\n                sendSampleListEntry(listEntry)\n\n                const zip = new JSZip();\n                const jpgZip = new JSZip()\n                const webpZip = new JSZip()\n\n                if (state.open_image_srcs.length === 0) {\n                    throw new Error("No open Nicol images are selected.")\n                }\n                if (state.cross_image_srcs.length === 0) {\n                    throw new Error("No crossed Nicol images are selected.")\n                }\n\n                // Thumbnails\n                zip.file("o1.jpg", compressImageSrc(state.open_image_srcs[0], "jpeg", state.desiredThumbnailImageSize))\n                zip.file("c1.jpg", compressImageSrc(state.cross_image_srcs[0], "jpeg", state.desiredThumbnailImageSize))\n\n                // Image sets\n                packageMap.setImageFormats(["webp", "jpg"])\n                state.open_image_srcs.forEach((src, i) => {\n                    webpZip.file(`o${i + 1}.webp`, compressImageSrc(src, "webp", state.desiredImageSize))\n                    jpgZip.file(`o${i + 1}.jpg`, compressImageSrc(src, "jpeg", state.desiredImageSize))\n                })\n                state.cross_image_srcs.forEach((src, i) => {\n                    webpZip.file(`c${i + 1}.webp`, compressImageSrc(src, "webp", state.desiredImageSize))\n                    jpgZip.file(`c${i + 1}.jpg`, compressImageSrc(src, "jpeg", state.desiredImageSize))\n                })\n\n                const meta = new Blob([JSON.stringify(packageMap.toJSON(), null, 2)], { "type": "text/json" });\n                zip.file("manifest.json", meta)\n                zip.file("webp.zip", await webpZip.generateAsync({ type: "blob" }))\n                zip.file("jpg.zip", await jpgZip.generateAsync({ type: "blob" }))\n                const zipContent = await zip.generateAsync({ type: "blob" })\n\n                const a = document.querySelector("#working_anchor")\n                a.download = `${packageMap.getPackageID()}.zip`\n                a.href = window.URL.createObjectURL(zipContent)\n                a.click()\n\n            }\n            makeZip()\n                .then(() => {\n                    hideErrorMessage("#error_make_package")\n                })\n                .catch(e => {\n                    showErrorMessage("#error_make_package", e)\n                })\n        },\n        false\n    )\n\n    updateViewerGeometry(state)\n})(upload_state)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9nZXRNYXhWaWV3ZXJTaXplLmpzPzg1YTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JlbW90ZV9yZXBvL3N0YXRpYy9maWx0ZXJfYnlfY2F0ZWdvcnkuanM/ZmVhMCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9jYWxfc3RvcmFnZS9OYXRpdmVMb2NhbFN0b3JhZ2UuanM/ZjcyYSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9jYWxfc3RvcmFnZS9EdW1teUxvY2FsU3RvcmFnZS5qcz8zNWM1Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb25maWcvY29uZmlnLmpzP2RmYWQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N0YXRlL3VpX3N0YXRlLmpzPzYzZmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N0YXRlL3ZpZXdlcl9zdGF0ZS5qcz9kOGUxIiwid2VicGFjazovLy8uL3NyYy9qcy9zdGF0ZS9pbml0U3RhdGUuanM/NmRlOSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcGFja2FnZV9tYW5pZmVzdC5qcz8yNDYyIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3ZXJfY2FudmFzLmpzP2NmNzUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3VwZGF0ZVZpZXdlckdlb21ldHJ5LmpzP2I2NjMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3Nhbml0aXplSUQuanM/MDY0YyIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcm90YXRpb25fZGVncmVlX2hhbmRsZXJzLmpzP2U1YWUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3VwZGF0ZVN0YXRlQnlNZXRhLmpzPzk2MTIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3ZpZXdlcl9oYW5kbGVycy5qcz9hODA1Iiwid2VicGFjazovLy8uL3NyYy9qcy9jbGlwR2VvbWV0cnlGcm9tSW1hZ2VDZW50ZXIuanM/ZDJjZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZHJhd19zdGF0ZV91cGRhdG9ycy5qcz9lOTI5Iiwid2VicGFjazovLy8uL3NyYy9qcy9nZXRDb29yZGluYXRlT25DYW52YXMuanM/MGU3ZiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcmFkaXVuQmV0d2Vlbi5qcz80ZjIzIiwid2VicGFjazovLy8uL3NyYy9qcy9jb29yZGluYXRlX3VwZGF0b3JzLmpzPzBiZTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JvdGF0ZUltYWdlLmpzPzFlODIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3VwZGF0ZU1hZ25pZnkuanM/N2NhYSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcGluY2hJbWFnZS5qcz84MjE1Iiwid2VicGFjazovLy8uL3NyYy9qcy90b3VjaEV2ZW50SGFuZGxlcnMuanM/ZTMxZSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvd2hlZWxJbWFnZS5qcz8zMjZkIiwid2VicGFjazovLy8uL3NyYy9qcy93aGVlbEV2ZW50SGFuZGxlci5qcz9iMjEwIiwid2VicGFjazovLy8uL3NyYy9qcy9pbmRleF9tYWtlX3BhY2thZ2UuanM/NTQ0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYXhWaWV3ZXJTaXplKCkge1xuICAgIGNvbnN0IHRvcEJhclNwYWNlSGVpZ2h0ID0gMjAwIC8vIHB4XG4gICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcEJhclNwYWNlSGVpZ2h0XG4gICAgcmV0dXJuIHdpZHRoIDwgaGVpZ2h0ID8gd2lkdGggOiBoZWlnaHRcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNhbXBsZUZpbHRlciB7XG4gICAgY29uc3RydWN0b3IocXVlcmllcyA9IFtdKSB7XG4gICAgICAgIHRoaXMucXVlcmllcyA9IG5ldyBTZXQocXVlcmllcy5tYXAodGhpcy5saXN0VG9RdWVyeSkpXG4gICAgfVxuXG4gICAgYWRkKHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcmllcy5hZGQodGhpcy5saXN0VG9RdWVyeShxdWVyeSkpXG4gICAgfVxuXG4gICAgYWRkTWFueShxdWVyaWVzKSB7XG4gICAgICAgIHF1ZXJpZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5hZGQodGhpcy5saXN0VG9RdWVyeSh2KSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZW1vdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5xdWVyaWVzLmRlbGV0ZSh0aGlzLmxpc3RUb1F1ZXJ5KHZhbHVlKSlcbiAgICB9XG5cbiAgICByZW1vdmVNYW55KHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5kZWxldGUodGhpcy5saXN0VG9RdWVyeSh2KSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZXNldChxdWVyaWVzKSB7XG4gICAgICAgIHRoaXMucXVlcmllcyA9IG5ldyBTZXQocXVlcmllcy5tYXAodGhpcy5saXN0VG9RdWVyeSkpXG4gICAgfVxuXG4gICAgbGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllc1xuICAgIH1cblxuICAgIGxpc3RUb1F1ZXJ5KHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVkdWNlKChhY2MsIGUpID0+IHtcbiAgICAgICAgICAgIGlmIChhY2MgPT09IFwiXCIpIHJldHVybiBlXG4gICAgICAgICAgICByZXR1cm4gYWNjICsgXCI6OlwiICsgZVxuICAgICAgICB9LCBcIlwiKVxuICAgIH1cblxuICAgIGZpbHRlcihzYW1wbGVMaXN0KSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJpZXMuc2l6ZSA9PT0gMCkgcmV0dXJuIHNhbXBsZUxpc3RcblxuICAgICAgICBjb25zdCBxdWVyaWVzID0gWy4uLnRoaXMucXVlcmllc10ubWFwKHYgPT4gdi5zcGxpdChcIjo6XCIpKVxuICAgICAgICByZXR1cm4gc2FtcGxlTGlzdC5maWx0ZXIoc2FtcGxlID0+IHtcbiAgICAgICAgICAgIGlmICghc2FtcGxlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcnlcIikpIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgY29uc3Qgc3VwZXJzZXQgPSBuZXcgU2V0KHNhbXBsZS5jYXRlZ29yeSlcbiAgICAgICAgICAgIGZvciAobGV0IHF1ZXJ5IG9mIHF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdWJzZXQocXVlcnksIHN1cGVyc2V0KSkgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtTZXR9IHNldFxuICogQHBhcmFtIHtTZXR9IHN1cGVyc2V0XG4gKi9cbmZ1bmN0aW9uIGlzU3Vic2V0KHNldCwgc3VwZXJzZXQpIHtcbiAgICBpZiAoc2V0LnNpemUgPT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBmb3IgKGxldCBlbGVtIG9mIHNldCkge1xuICAgICAgICBpZiAoIXN1cGVyc2V0LmhhcyhlbGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF0aXZlTG9jYWxTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYiA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VcbiAgICB9XG5cbiAgICBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRiLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGIuZ2V0SXRlbShrZXkpXG4gICAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHZhbHVlXG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHVtbXlMb2NhbFN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRiID0ge31cbiAgICB9XG5cbiAgICBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRiW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kYi5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgID8gdGhpcy5kYltrZXldXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgIH1cbn1cbiIsIi8qKlxuICogVE9ETyBzcGxpdCB0aGVzZSBjb25maWcgYXMgZGlmZmVyZW50IG9iamVjdHNcbiAqXG4gKiAtIFBhY2thZ2UgbGlzdCBlbmRwb2ludFxuICogLSBQYWNrYWdlIENETiBlbmRwb2ludFxuICogLSBDYWNoZSBEQiB2ZXJzaW9uIG5hbWVcbiAqIC0gQ2FjaGUgREIgdGFibGUgbmFtZVxuICovXG5pbXBvcnQgTmF0aXZlTG9jYWxTdG9yYWdlIGZyb20gXCIuLi9sb2NhbF9zdG9yYWdlL05hdGl2ZUxvY2FsU3RvcmFnZS5qc1wiO1xuaW1wb3J0IER1bW15TG9jYWxTdG9yYWdlIGZyb20gXCIuLi9sb2NhbF9zdG9yYWdlL0R1bW15TG9jYWxTdG9yYWdlLmpzXCI7XG5cbmNsYXNzIENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBjb21waWxlRW52ID09IFwicHJvZHVjdGlvblwiXG4gICAgICAgICAgICA/IFwiaHR0cHM6Ly9kM3VxenY3bDFpaDA1ZC5jbG91ZGZyb250Lm5ldC9cIlxuICAgICAgICAgICAgOiBcIi4uLy4uL2ltYWdlX3BhY2thZ2Vfcm9vdC9cIlxuXG4gICAgICAgIHRoaXMuaW5kZXhlZERCTmFtZSA9IFwiZGJfdjNcIlxuICAgICAgICB0aGlzLnN0b3JhZ2VOYW1lID0gXCJmaWxlc1wiXG4gICAgfVxuXG4gICAgZ2V0U2FtcGxlTGlzdFVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kcG9pbnQgKyBcInJvY2tfbGlzdC5qc29uXCJcbiAgICB9XG5cbiAgICBnZXRTYW1wbGVDYXRlZ29yeVVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kcG9pbnQgKyBcImNhdGVnb3J5Lmpzb25cIlxuICAgIH1cblxuICAgIGdldEltYWdlRGF0YVBhdGgocGFja2FnZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kcG9pbnQgKyBcInBhY2thZ2VzL1wiICsgcGFja2FnZU5hbWUgKyBcIi9cIlxuICAgIH1cblxuICAgIGdldERCTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZERCTmFtZTtcbiAgICB9XG5cbiAgICBnZXRTdG9yYWdlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZU5hbWVcbiAgICB9XG59XG5cblxuY29uc3QgY29tcGlsZUVudiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WXG5cbmNvbnNvbGUuaW5mbyhcImNvbmZpZy5qczogY29tcGlsZUVudjogXCIsIGNvbXBpbGVFbnYpXG5cbmV4cG9ydCBjb25zdCBzdGF0aWNTZXR0aW5ncyA9IG5ldyBDb25maWcoKVxuXG5leHBvcnQgY29uc3QgVklFV19QQURESU5HID0gMCAvLyBweFxuXG5leHBvcnQgY29uc3QgY2FjaGVTdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZVxuICAgID8gbmV3IE5hdGl2ZUxvY2FsU3RvcmFnZSgpXG4gICAgOiBuZXcgRHVtbXlMb2NhbFN0b3JhZ2UoKSIsImltcG9ydCBTYW1wbGVGaWx0ZXIgZnJvbSBcIi4uL3JlbW90ZV9yZXBvL3N0YXRpYy9maWx0ZXJfYnlfY2F0ZWdvcnkuanNcIlxuaW1wb3J0IHsgY2FjaGVTdG9yYWdlIH0gZnJvbSBcIi4uL2NvbmZpZy9jb25maWcuanNcIlxuXG5mdW5jdGlvbiBvdmVycmlkZUxhbmd1YWdlQnlMb2NhbFN0b3JhZ2Uoc3lzdGVtTGFuZ3VhZ2UpIHtcbiAgICBjb25zdCBsYW5nSW5Mb2NhbFN0b3JhZ2UgPSBjYWNoZVN0b3JhZ2UuZ2V0KFwibGFuZ3VhZ2VcIilcbiAgICBjb25zdCBsYW5nID0gKGxhbmdJbkxvY2FsU3RvcmFnZSAhPT0gdW5kZWZpbmVkKVxuICAgICAgICA/IGxhbmdJbkxvY2FsU3RvcmFnZVxuICAgICAgICA6IHN5c3RlbUxhbmd1YWdlO1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCJvcHRpb25bdmFsdWU9XCIgKyBsYW5nICsgXCJdXCIpLnNlbGVjdGVkID0gdHJ1ZVxuICAgIHJldHVybiBsYW5nXG59XG5cbmZ1bmN0aW9uIGdldFN5c3RlbUxhbmd1YWdlKCkge1xuICAgIGNvbnN0IGNvZGUgPSAod2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXMgJiYgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZXNbMF0pIHx8XG4gICAgICAgIHdpbmRvdy5uYXZpZ2F0b3IubGFuZ3VhZ2UgfHxcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci51c2VyTGFuZ3VhZ2UgfHxcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5icm93c2VyTGFuZ3VhZ2U7XG5cbiAgICBjb25zdCBsYW5nID0gY29kZS5tYXRjaChcImphXCIpID8gXCJqYVwiIDogXCJlblwiO1xuXG4gICAgcmV0dXJuIGxhbmdcbn1cblxuZXhwb3J0IGNvbnN0IHVpU3RhdGUgPSB7XG4gICAgXCJzYW1wbGVGaWx0ZXJcIjogbmV3IFNhbXBsZUZpbHRlcigpLFxuICAgIFwic3RvcmVkS2V5c1wiOiBbXSxcbiAgICBcImxhbmd1YWdlXCI6IG92ZXJyaWRlTGFuZ3VhZ2VCeUxvY2FsU3RvcmFnZShnZXRTeXN0ZW1MYW5ndWFnZSgpKSxcbn0iLCJpbXBvcnQgZ2V0TWF4Vmlld2VyU2l6ZSBmcm9tIFwiLi4vZ2V0TWF4Vmlld2VyU2l6ZS5qc1wiXG5cbmV4cG9ydCBjb25zdCB2aWV3ZXJTdGF0ZSA9IHtcbiAgICBcImNvbnRhaW5vcklEXCI6IFwiXCIsXG4gICAgXCJpbWFnZU51bWJlclwiOiAxLFxuICAgIFwiY2FudmFzV2lkdGhcIjogZ2V0TWF4Vmlld2VyU2l6ZSgpIDw9IDUwMFxuICAgICAgICA/IGdldE1heFZpZXdlclNpemUoKVxuICAgICAgICA6IDUwMCxcbiAgICBcImNhbnZhc0hlaWdodFwiOiBnZXRNYXhWaWV3ZXJTaXplKCkgPD0gNTAwXG4gICAgICAgID8gZ2V0TWF4Vmlld2VyU2l6ZSgpXG4gICAgICAgIDogNTAwLFxuICAgIFwiaW1hZ2VSYWRpdXNcIjogMCxcbiAgICBcIm9wZW5faW1hZ2Vfc3Jjc1wiOiBbXSxcbiAgICBcIm9wZW5faW1hZ2VzXCI6IFtdLFxuICAgIFwiY3Jvc3NfaW1hZ2Vfc3Jjc1wiOiBbXSxcbiAgICBcImNyb3NzX2ltYWdlc1wiOiBbXSxcbiAgICBcInJvdGF0ZVwiOiAwLFxuICAgIFwicm90YXRlX2F4aXNfdHJhbnNsYXRlXCI6IFtdLFxuICAgIFwiaXNDbG9ja3dpc2VcIjogdHJ1ZSxcbiAgICBcImlzQ3Jvc3NOaWNvbFwiOiBmYWxzZSxcbiAgICBcImRyYXdIYWlyTGluZVwiOiB0cnVlLFxuICAgIFwiY2FuUm90YXRlXCI6IHRydWUsXG59IiwiaW1wb3J0IGdldE1heFZpZXdlclNpemUgZnJvbSBcIi4uL2dldE1heFZpZXdlclNpemUuanNcIlxuaW1wb3J0IHsgdWlTdGF0ZSB9IGZyb20gXCIuL3VpX3N0YXRlLmpzXCJcbmltcG9ydCB7IHZpZXdlclN0YXRlIH0gZnJvbSBcIi4vdmlld2VyX3N0YXRlLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5pdFN0YXRlKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIFwiaXNNb3VzZWRvd25cIjogZmFsc2UsXG4gICAgICAgIFwiZHJhZ19zdGFydFwiOiBbMCwgMF0sXG4gICAgICAgIFwiZHJhZ19lbmRcIjogWzAsIDBdLFxuICAgICAgICBcInVpU3RhdGVcIjogdWlTdGF0ZSxcbiAgICAgICAgLi4udmlld2VyU3RhdGUgLy8gVE9ETyB2aWV3ZXJTdGF0ZSBzaG91bGQgYmUgaW5kZXBlbmRlbnRcbiAgICB9XG59XG4iLCJleHBvcnQgZGVmYXVsdCBjbGFzcyBQYWNrYWdlTWFuaWZlc3Qge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnBhY2thZ2VJRCA9IG51bGxcbiAgICAgICAgdGhpcy5saXN0TmFtZSA9IHt9XG4gICAgICAgIHRoaXMubG9jYXRpb24gPSB7fVxuICAgICAgICB0aGlzLm93bmVyID0ge31cbiAgICAgICAgdGhpcy5yb2NrVHlwZSA9IHt9XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSB7fVxuICAgICAgICB0aGlzLmdlb1N5c3RlbSA9IFwiXCJcbiAgICAgICAgdGhpcy5nZW9Qb3NpdGlvbiA9IFtudWxsLCBudWxsXVxuICAgICAgICB0aGlzLnJvdGF0ZUNlbnRlciA9IFt1bmRlZmluZWQsIHVuZGVmaW5lZF1cbiAgICAgICAgdGhpcy5yb3RhdGVEaXJlY3Rpb24gPSBcImNsb2Nrd2lzZVwiXG4gICAgICAgIHRoaXMuaW1hZ2VTaXplID0geyBcIndpZHRoXCI6IDAsIFwiaGVpZ2h0XCI6IDAgfVxuICAgIH1cblxuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwicGFja2FnZS1pZFwiOiB0aGlzLmdldFBhY2thZ2VJRCgpLFxuICAgICAgICAgICAgXCJsaXN0LW5hbWVcIjogdGhpcy5nZXRMaXN0TmFtZSgpLFxuICAgICAgICAgICAgXCJpbWFnZV93aWR0aFwiOiB0aGlzLmdldEltYWdlV2lkdGgoKSxcbiAgICAgICAgICAgIFwiaW1hZ2VfaGVpZ2h0XCI6IHRoaXMuZ2V0SW1hZ2VIZWlnaHQoKSxcbiAgICAgICAgICAgIFwicm90YXRlX2NlbnRlclwiOiB0aGlzLmdldFJvdGF0ZUNlbnRlcigpLFxuICAgICAgICAgICAgXCJjeWNsZV9yb3RhdGVfZGVncmVlXCI6IHRoaXMuZ2V0Um90YXRlU2VjdGlvbkRlZ3JlZSgpLFxuICAgICAgICAgICAgXCJyb3RhdGVfY2xvY2t3aXNlXCI6IHRoaXMuaXNSb3RhdGVDbG9ja3dpc2UoKSxcbiAgICAgICAgICAgIFwicm90YXRlX2J5X2RlZ3JlZVwiOiB0aGlzLmdldEVhY2hSb3RhdGVEZWdyZWUoKSxcbiAgICAgICAgICAgIFwibG9jYXRpb25cIjogdGhpcy5nZXRTYW1wbGVMb2NhdGlvbigpLFxuICAgICAgICAgICAgXCJvd25lclwiOiB0aGlzLmdldE93bmVyKCksXG4gICAgICAgICAgICBcInJvY2tfdHlwZVwiOiB0aGlzLmdldFJvY2tUeXBlKCksXG4gICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IHRoaXMuZ2V0RGVzY3JpcHRpb24oKSxcbiAgICAgICAgICAgIFwic2NhbGUtdW5pdFwiOiB0aGlzLmdldFNjYWxlVW5pdCgpLFxuICAgICAgICAgICAgXCJzY2FsZS1waXhlbFwiOiB0aGlzLmdldFNjYWxlUGl4ZWwoKSxcbiAgICAgICAgICAgIFwibWFnbmlmeVwiOiB0aGlzLmdldE1hZ25pZnkoKSxcbiAgICAgICAgICAgIFwic2FtcGxlX2xhYmVsXCI6IHRoaXMuZ2V0U2FtcGxlTGFiZWwoKSxcbiAgICAgICAgICAgIFwiZ2VvZ3JhcGhpYy1jb29yZGluYXRlXCI6IHRoaXMuZ2V0R2VvTG9jYXRpb24oKSxcbiAgICAgICAgICAgIFwiaW1hZ2VfZm9ybWF0c1wiOiB0aGlzLmdldEltYWdlRm9ybWF0cygpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRTYW1wbGVMaXN0RW50cnkoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBcInBhY2thZ2UtbmFtZVwiOiB0aGlzLmdldFBhY2thZ2VJRCgpLFxuICAgICAgICAgICAgXCJsaXN0LW5hbWVcIjogdGhpcy5nZXRMaXN0TmFtZSgpXG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRQYWNrYWdlSUQoaWQpIHtcbiAgICAgICAgdGhpcy5wYWNrYWdlSUQgPSBpZFxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldFBhY2thZ2VJRCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFja2FnZUlEIHx8IFwiXCJcbiAgICB9XG5cbiAgICBzZXRMaXN0TmFtZShsYW5nLCBzKSB7XG4gICAgICAgIHRoaXMubGlzdE5hbWVbbGFuZ10gPSBzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBnZXRMaXN0TmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubGlzdE5hbWU7XG4gICAgfVxuXG4gICAgc2V0U2FtcGxlTG9jYXRpb24obGFuZywgZGVzYykge1xuICAgICAgICB0aGlzLmxvY2F0aW9uW2xhbmddID0gZGVzYztcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRTYW1wbGVMb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubG9jYXRpb247XG4gICAgfVxuXG4gICAgc2V0TG9jYXRpb24oc3lzdGVtLCB2MSwgdjIpIHtcbiAgICAgICAgdGhpcy5nZW9TeXN0ZW0gPSBzeXN0ZW0sXG4gICAgICAgICAgICB0aGlzLmdlb1Bvc2l0aW9uID0gW3YxLCB2Ml1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRHZW9Mb2NhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwic3lzdGVtXCI6IHRoaXMuZ2VvU3lzdGVtLFxuICAgICAgICAgICAgXCJwb3NpdGlvblwiOiB7XG4gICAgICAgICAgICAgICAgXCJsYXRpdHVkZVwiOiB0aGlzLmdlb1Bvc2l0aW9uWzBdLFxuICAgICAgICAgICAgICAgIFwibG9uZ2l0dWRlXCI6IHRoaXMuZ2VvUG9zaXRpb25bMV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldE1hZ25pZnkobWFnbmlmaWNhdGlvblZhbHVlKSB7XG4gICAgICAgIHRoaXMubWFnbmlmeSA9IG1hZ25pZmljYXRpb25WYWx1ZVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldE1hZ25pZnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1hZ25pZnlcbiAgICB9XG5cbiAgICBzZXRTY2FsZVVuaXQoc2NhbGVVbml0KSB7XG4gICAgICAgIHRoaXMuc2NhbGVVbml0ID0gc2NhbGVVbml0O1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldFNjYWxlVW5pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVVbml0XG4gICAgfVxuXG4gICAgc2V0U2NhbGVQaXhlbChzY2FsZUxlbmd0aEFzUGl4ZWwpIHtcbiAgICAgICAgdGhpcy5zY2FsZVBpeGVsID0gc2NhbGVMZW5ndGhBc1BpeGVsXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0U2NhbGVQaXhlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NhbGVQaXhlbFxuICAgIH1cblxuICAgIHNldFNhbXBsZUxhYmVsKHMpIHtcbiAgICAgICAgdGhpcy5zYW1wbGVMYWJlbCA9IHNcbiAgICB9XG5cbiAgICBnZXRTYW1wbGVMYWJlbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2FtcGxlTGFiZWwgfHwgXCJcIlxuICAgIH1cblxuICAgIHNldEltYWdlU2l6ZShpbWcpIHtcbiAgICAgICAgdGhpcy5pbWFnZVNpemUgPSB7XG4gICAgICAgICAgICBcIndpZHRoXCI6IGltZy53aWR0aCxcbiAgICAgICAgICAgIFwiaGVpZ2h0XCI6IGltZy5oZWlnaHRcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldEltYWdlV2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlU2l6ZS53aWR0aFxuICAgIH1cblxuICAgIGdldEltYWdlSGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZVNpemUuaGVpZ2h0XG4gICAgfVxuXG4gICAgc2V0Um90YXRlQ2VudGVyKGZyb21MZWZ0LCBmcm9tVG9wKSB7XG4gICAgICAgIHRoaXMucm90YXRlQ2VudGVyID0gW2Zyb21MZWZ0LCBmcm9tVG9wXVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldFJvdGF0ZUNlbnRlcigpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIHRoaXMucm90YXRlQ2VudGVyWzBdID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0SW1hZ2VXaWR0aCgpICogMC41XG4gICAgICAgICAgICAgICAgOiB0aGlzLnJvdGF0ZUNlbnRlclswXSxcbiAgICAgICAgICAgIHRoaXMucm90YXRlQ2VudGVyWzFdID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICA/IHRoaXMuZ2V0SW1hZ2VIZWlnaHQoKSAqIDAuNVxuICAgICAgICAgICAgICAgIDogdGhpcy5yb3RhdGVDZW50ZXJbMV1cbiAgICAgICAgXVxuICAgIH1cblxuICAgIHNldEltYWdlc051bWJlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLmltYWdlc051bWJlciA9IHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0SW1hZ2VzTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZXNOdW1iZXJcbiAgICB9XG5cbiAgICBnZXRSb3RhdGVTZWN0aW9uRGVncmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFYWNoUm90YXRlRGVncmVlKCkgKiAodGhpcy5nZXRJbWFnZXNOdW1iZXIoKSAtIDEpXG4gICAgfVxuXG4gICAgc2V0Um90YXRlRGlyZWN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgICB0aGlzLnJvdGF0ZURpcmVjdGlvbiA9IGRpcmVjdGlvblxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGlzUm90YXRlQ2xvY2t3aXNlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb3RhdGVEaXJlY3Rpb24gPT09IFwiY2xvY2t3aXNlXCJcbiAgICB9XG5cbiAgICBzZXRFYWNoUm90YXRlRGVncmVlKGRlZ3JlZSkge1xuICAgICAgICB0aGlzLmVhY2hSb3RhdGVEZWdyZWUgPSBkZWdyZWVcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRFYWNoUm90YXRlRGVncmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lYWNoUm90YXRlRGVncmVlXG4gICAgfVxuXG4gICAgc2V0Um9ja1R5cGUobGFuZywgZGVzYykge1xuICAgICAgICB0aGlzLnJvY2tUeXBlW2xhbmddID0gZGVzY1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldFJvY2tUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb2NrVHlwZVxuICAgIH1cblxuICAgIHNldE93bmVyKGxhbmcsIGRlc2MpIHtcbiAgICAgICAgdGhpcy5vd25lcltsYW5nXSA9IGRlc2NcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRPd25lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3duZXJcbiAgICB9XG5cbiAgICBzZXREZXNjcmlwdGlvbihsYW5nLCBkZXNjKSB7XG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb25bbGFuZ10gPSBkZXNjXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0RGVzY3JpcHRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlc2NyaXB0aW9uXG4gICAgfVxuXG4gICAgc2V0SW1hZ2VGb3JtYXRzKGZvcm1hdHMpIHtcbiAgICAgICAgZm9ybWF0cy5mb3JFYWNoKGZvcm1hdCA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLmFzc2VydChbXCJ3ZWJwXCIsIFwianBnXCIsIFwianAyXCJdLmluY2x1ZGVzKGZvcm1hdCkpXG4gICAgICAgIH0pXG4gICAgICAgIHRoaXMuaW1hZ2VGb3JtYXRzID0gZm9ybWF0c1xuICAgIH1cblxuICAgIGdldEltYWdlRm9ybWF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VGb3JtYXRzIHx8IFtdXG4gICAgfVxufVxuIiwiZXhwb3J0IGNvbnN0IHZpZXdlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWFpbi12aWV3ZXJcIilcbmV4cG9ydCBjb25zdCB2aWV3ZXJfY3R4ID0gdmlld2VyLmdldENvbnRleHQoXCIyZFwiKVxuIiwiaW1wb3J0IHsgdmlld2VyLCB2aWV3ZXJfY3R4IH0gZnJvbSBcIi4vdmlld2VyX2NhbnZhcy5qc1wiXG5pbXBvcnQgZ2V0TWF4Vmlld2VyU2l6ZSBmcm9tIFwiLi9nZXRNYXhWaWV3ZXJTaXplLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlVmlld2VyR2VvbWV0cnkoc3RhdGUpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIGNvbnN0IHBhZGRpbmcgPSAyMCAvLyBweFxuICAgICAgICBzdGF0ZS5jYW52YXNXaWR0aCA9IGdldE1heFZpZXdlclNpemUoKSAtIHBhZGRpbmdcbiAgICAgICAgc3RhdGUuY2FudmFzSGVpZ2h0ID0gZ2V0TWF4Vmlld2VyU2l6ZSgpIC0gcGFkZGluZ1xuXG4gICAgICAgIHZpZXdlci53aWR0aCA9IHN0YXRlLmNhbnZhc1dpZHRoXG4gICAgICAgIHZpZXdlci5oZWlnaHQgPSBzdGF0ZS5jYW52YXNIZWlnaHRcbiAgICAgICAgdmlld2VyX2N0eC50cmFuc2xhdGUoc3RhdGUuY2FudmFzV2lkdGggKiAwLjUsIHN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNSlcbiAgICAgICAgcmVzKHN0YXRlKVxuICAgIH0pXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBzYW5pdGl6ZUlEKGlkKSB7XG4gICAgcmV0dXJuIGlkLnJlcGxhY2UoL1xcLy9nLCBcIl9cIikucmVwbGFjZSgvXFwuL2csIFwiXCIpXG59XG4iLCJleHBvcnQgY29uc3Qgc3RlcEJ5ID0gdW5pdCA9PiB2YWwgPT4gTWF0aC5mbG9vcih2YWwgLyB1bml0KVxuXG5leHBvcnQgY29uc3QgY3ljbGVCeSA9IHVuaXQgPT4gdmFsID0+IHtcbiAgICBjb25zdCBjeWNsZV9jb3VudCA9IE1hdGguZmxvb3IodmFsIC8gdW5pdClcbiAgICByZXR1cm4gdmFsIDwgMFxuICAgICAgICA/IHZhbCArIHVuaXRcbiAgICAgICAgOiAodW5pdCA8PSB2YWwpXG4gICAgICAgICAgICA/IHZhbCAtIHVuaXQgKiBjeWNsZV9jb3VudFxuICAgICAgICAgICAgOiB2YWxcbn1cblxuZXhwb3J0IGNvbnN0IG1pcnJvckJ5ID0gKGNlbnRlcikgPT4gdmFsID0+IHZhbCA+IGNlbnRlciA/IDIgKiBjZW50ZXIgLSB2YWwgOiB2YWxcblxuZXhwb3J0IGNvbnN0IGlzSW52ZXJzZSA9IGRlZ3JlZSA9PiAoMTgwIDw9IGRlZ3JlZSlcblxuZXhwb3J0IGNvbnN0IHJvdGF0ZVNpZ24gPSAoY2xvY2t3aXNlID0gdHJ1ZSkgPT4gY2xvY2t3aXNlID8gLTEgOiAxXG4iLCJpbXBvcnQgc2FuaXRpemVJRCBmcm9tIFwiLi9zYW5pdGl6ZUlELmpzXCJcbmltcG9ydCB7IGN5Y2xlQnksIHN0ZXBCeSB9IGZyb20gXCIuL3JvdGF0aW9uX2RlZ3JlZV9oYW5kbGVycy5qc1wiXG5cbmZ1bmN0aW9uIGdldFJvdGF0aW9uQ2VudGVyKG1ldGEpIHtcbiAgICByZXR1cm4gKG1ldGEuaGFzT3duUHJvcGVydHkoXCJyb3RhdGVfY2VudGVyXCIpKVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIFwidG9fcmlnaHRcIjogbWV0YS5yb3RhdGVfY2VudGVyWzBdLFxuICAgICAgICAgICAgXCJ0b19ib3R0b21cIjogbWV0YS5yb3RhdGVfY2VudGVyWzFdXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICBcInRvX3JpZ2h0XCI6IG1ldGEuaW1hZ2Vfd2lkdGggKiAwLjUsXG4gICAgICAgICAgICBcInRvX2JvdHRvbVwiOiBtZXRhLmltYWdlX2hlaWdodCAqIDAuNVxuICAgICAgICB9XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlUmFkaXVzKG1ldGEpIHtcbiAgICBjb25zdCBzaGlmdCA9IGdldFJvdGF0aW9uQ2VudGVyKG1ldGEpO1xuICAgIGNvbnN0IGltYWdlX2NlbnRlciA9IHtcbiAgICAgICAgXCJ4XCI6IG1ldGEuaW1hZ2Vfd2lkdGggKiAwLjUsXG4gICAgICAgIFwieVwiOiBtZXRhLmltYWdlX2hlaWdodCAqIDAuNVxuICAgIH1cbiAgICByZXR1cm4gTWF0aC5taW4oXG4gICAgICAgIGltYWdlX2NlbnRlci54IC0gTWF0aC5hYnMoaW1hZ2VfY2VudGVyLnggLSBzaGlmdC50b19yaWdodCksXG4gICAgICAgIGltYWdlX2NlbnRlci55IC0gTWF0aC5hYnMoaW1hZ2VfY2VudGVyLnkgLSBzaGlmdC50b19ib3R0b20pXG4gICAgKVxufVxuXG5mdW5jdGlvbiBtYXBNZXRhZGF0YShtZXRhKSB7XG4gICAgY29uc3Qgcm90YXRlX2RlZ3JlZV9zdGVwID0gcGFyc2VJbnQobWV0YS5yb3RhdGVfYnlfZGVncmVlKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaXNDbG9ja3dpc2U6IG1ldGEucm90YXRlX2Nsb2Nrd2lzZSxcbiAgICAgICAgbG9jYXRpb246IG1ldGEubG9jYXRpb24sXG4gICAgICAgIHJvY2tUeXBlOiBtZXRhLnJvY2tfdHlwZSxcbiAgICAgICAgb3duZXI6IG1ldGEub3duZXIsXG4gICAgICAgIGRlc2NyaXB0aW9uOiBtZXRhLmhhc093blByb3BlcnR5KFwiZGlzY3JpcHRpb25cIilcbiAgICAgICAgICAgID8gbWV0YS5kaXNjcmlwdGlvblxuICAgICAgICAgICAgOiBtZXRhLmhhc093blByb3BlcnR5KFwiZGVzY3JpcHRpb25cIilcbiAgICAgICAgICAgICAgICA/IG1ldGEuZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICByb3RhdGVfY2VudGVyOiBnZXRSb3RhdGlvbkNlbnRlcihtZXRhKSxcbiAgICAgICAgaW1hZ2VXaWR0aDogbWV0YS5pbWFnZV93aWR0aCxcbiAgICAgICAgaW1hZ2VIZWlnaHQ6IG1ldGEuaW1hZ2VfaGVpZ2h0LFxuICAgICAgICBpbWFnZVJhZGl1czogZ2V0SW1hZ2VSYWRpdXMobWV0YSksXG4gICAgICAgIGltYWdlUmFkaXVzT3JpZ2luYWw6IGdldEltYWdlUmFkaXVzKG1ldGEpLFxuICAgICAgICBzY2FsZVdpZHRoOiBtZXRhLmhhc093blByb3BlcnR5KFwic2NhbGUtcGl4ZWxcIilcbiAgICAgICAgICAgID8gcGFyc2VJbnQobWV0YVtcInNjYWxlLXBpeGVsXCJdKVxuICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgc2NhbGVUZXh0OiBtZXRhLmhhc093blByb3BlcnR5KFwic2NhbGUtdW5pdFwiKVxuICAgICAgICAgICAgPyBtZXRhW1wic2NhbGUtdW5pdFwiXVxuICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgcm90YXRlX2RlZ3JlZV9zdGVwOiByb3RhdGVfZGVncmVlX3N0ZXBcbiAgICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHVwZGF0ZVN0YXRlQnlNZXRhKHN0YXRlKSB7XG4gICAgcmV0dXJuIChjb250YWlub3JJRCwgbWV0YSkgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cbiAgICAgICAgc3RhdGUuY29udGFpbm9ySUQgPSBzYW5pdGl6ZUlEKGNvbnRhaW5vcklEKTtcblxuICAgICAgICBjb25zdCByb3RhdGVfZGVncmVlX3N0ZXAgPSBwYXJzZUludChtZXRhLnJvdGF0ZV9ieV9kZWdyZWUpXG4gICAgICAgIGNvbnN0IGN5Y2xlX2RlZ3JlZSA9IG1ldGEuaGFzT3duUHJvcGVydHkoXCJjeWNsZV9yb3RhdGVfZGVncmVlXCIpXG4gICAgICAgICAgICA/IHBhcnNlSW50KG1ldGEuY3ljbGVfcm90YXRlX2RlZ3JlZSlcbiAgICAgICAgICAgIDogOTA7XG4gICAgICAgIGNvbnN0IGltYWdlX251bWJlciA9IGN5Y2xlX2RlZ3JlZSAvIHJvdGF0ZV9kZWdyZWVfc3RlcCArIDFcbiAgICAgICAgY29uc3QgbWlycm9yX2F0ID0gKGltYWdlX251bWJlciAtIDEpXG4gICAgICAgIGNvbnN0IHRvdGFsX3N0ZXAgPSAoaW1hZ2VfbnVtYmVyIC0gMSkgKiAyXG5cbiAgICAgICAgc3RhdGUuaW1hZ2VfbnVtYmVyID0gaW1hZ2VfbnVtYmVyXG4gICAgICAgIHN0YXRlLmdldEltYWdlTnVtYmVyID0gY3ljbGVfZGVncmVlID4gMFxuICAgICAgICAgICAgPyBkZWdyZWUgPT4gY3ljbGVCeShpbWFnZV9udW1iZXIgLSAxKShcbiAgICAgICAgICAgICAgICBzdGVwQnkocm90YXRlX2RlZ3JlZV9zdGVwKShzdGF0ZS5pc0Nsb2Nrd2lzZSA/IDM2MCAtIGRlZ3JlZSA6IGRlZ3JlZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIDogZGVncmVlID0+IG1pcnJvckJ5KG1pcnJvcl9hdCkoXG4gICAgICAgICAgICAgICAgY3ljbGVCeSh0b3RhbF9zdGVwKShcbiAgICAgICAgICAgICAgICAgICAgc3RlcEJ5KHJvdGF0ZV9kZWdyZWVfc3RlcCkoZGVncmVlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcblxuICAgICAgICBzdGF0ZS5nZXRBbHBoYSA9IGRlZ3JlZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBudGggPSBjeWNsZUJ5KHRvdGFsX3N0ZXAgKiAyKShcbiAgICAgICAgICAgICAgICBzdGVwQnkocm90YXRlX2RlZ3JlZV9zdGVwKShkZWdyZWUpXG4gICAgICAgICAgICApXG4gICAgICAgICAgICByZXR1cm4gMSAtIChkZWdyZWUgLSByb3RhdGVfZGVncmVlX3N0ZXAgKiBudGgpIC8gcm90YXRlX2RlZ3JlZV9zdGVwXG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZS5vcGVuX2ltYWdlcyA9IFtdXG4gICAgICAgIHN0YXRlLmNyb3NzX2ltYWdlcyA9IFtdXG5cbiAgICAgICAgc3RhdGUucm90YXRlID0gMDtcblxuICAgICAgICBzdGF0ZSA9IE9iamVjdC5hc3NpZ24oc3RhdGUsIG1hcE1ldGFkYXRhKG1ldGEpKVxuXG4gICAgICAgIHJlcyhzdGF0ZSlcbiAgICB9KVxufVxuIiwiXG5cbmV4cG9ydCBjb25zdCBoaWRlV2VsY29tZUJvYXJkID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGJvYXJkID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN3ZWxjb21lLWNhcmRcIilcbiAgICBib2FyZC5jbGFzc0xpc3QuYWRkKFwiaW5hY3RpdmVcIik7XG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBjb25zdCBzaG93Vmlld2VyID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGNhcmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3ZpZXdlcl93cmFwcGVyXCIpXG4gICAgY2FyZC5jbGFzc0xpc3QucmVtb3ZlKFwiaW5hY3RpdmVcIilcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IHNob3dOaWNvbEJ1dHRvbiA9IHN0YXRlID0+IHtcbiAgICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2xvdy1uYXZpZ2F0aW9uXCIpXG4gICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKTtcbiAgICByZXR1cm4gc3RhdGVcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNsaXBHZW9tZXRvcnlGcm9tSW1hZ2VDZW50ZXIoc3RhdGUpIHtcblxuICAgIHJldHVybiBbXG4gICAgICAgIHN0YXRlLnJvdGF0ZV9jZW50ZXIudG9fcmlnaHQgLSBzdGF0ZS5pbWFnZVJhZGl1cyxcbiAgICAgICAgc3RhdGUucm90YXRlX2NlbnRlci50b19ib3R0b20gLSBzdGF0ZS5pbWFnZVJhZGl1cyxcbiAgICAgICAgc3RhdGUuaW1hZ2VSYWRpdXMgKiAyLFxuICAgICAgICBzdGF0ZS5pbWFnZVJhZGl1cyAqIDJcbiAgICBdXG59XG4iLCJpbXBvcnQgY2xpcEdlb21ldG9yeUZyb21JbWFnZUNlbnRlciBmcm9tIFwiLi9jbGlwR2VvbWV0cnlGcm9tSW1hZ2VDZW50ZXIuanNcIlxuaW1wb3J0IHsgdmlld2VyX2N0eCB9IGZyb20gXCIuL3ZpZXdlcl9jYW52YXMuanNcIlxuaW1wb3J0IHsgVklFV19QQURESU5HIH0gZnJvbSBcIi4vY29uZmlnL2NvbmZpZy5qc1wiXG5pbXBvcnQgeyByb3RhdGVTaWduIH0gZnJvbSBcIi4vcm90YXRpb25fZGVncmVlX2hhbmRsZXJzLmpzXCJcblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFyVmlldyhzdGF0ZSkge1xuICAgIHZpZXdlcl9jdHguY2xlYXJSZWN0KC1zdGF0ZS5jYW52YXNXaWR0aCAqIDAuNSwgLXN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNSwgc3RhdGUuY2FudmFzV2lkdGgsIHN0YXRlLmNhbnZhc0hlaWdodClcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJsb2JUb0NhbnZhcyhzdGF0ZSkge1xuXG4gICAgY29uc3QgaW1hZ2Vfc3JjcyA9IHN0YXRlLmlzQ3Jvc3NOaWNvbFxuICAgICAgICA/IHN0YXRlLmNyb3NzX2ltYWdlc1xuICAgICAgICA6IHN0YXRlLm9wZW5faW1hZ2VzXG5cbiAgICAvLyB2aWV3IHdpbmRvdyBjaXJjbGVcblxuICAgIHZpZXdlcl9jdHguc2F2ZSgpXG4gICAgdmlld2VyX2N0eC5iZWdpblBhdGgoKVxuICAgIHZpZXdlcl9jdHguYXJjKDAsIDAsIHN0YXRlLmNhbnZhc1dpZHRoIC8gMiAtIFZJRVdfUEFERElORywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKVxuICAgIHZpZXdlcl9jdHguY2xpcCgpXG5cbiAgICAvLyBEcmF3IGEgaW1hZ2VcbiAgICBjb25zdCBhbHBoYSA9IHN0YXRlLmdldEFscGhhKHN0YXRlLnJvdGF0ZSlcblxuICAgIHZpZXdlcl9jdHgucm90YXRlKFxuICAgICAgICByb3RhdGVTaWduKHN0YXRlLmlzQ2xvY2t3aXNlKSAqIChzdGF0ZS5yb3RhdGUgKyBzdGF0ZS5nZXRJbWFnZU51bWJlcihzdGF0ZS5yb3RhdGUpICogc3RhdGUucm90YXRlX2RlZ3JlZV9zdGVwKSAvIDE4MCAqIE1hdGguUElcbiAgICApXG5cbiAgICB2aWV3ZXJfY3R4Lmdsb2JhbEFscGhhID0gMVxuICAgIGNvbnN0IGltYWdlMSA9IGltYWdlX3NyY3Nbc3RhdGUuZ2V0SW1hZ2VOdW1iZXIoc3RhdGUucm90YXRlKV1cblxuICAgIHRyeSB7XG4gICAgICAgIHZpZXdlcl9jdHguZHJhd0ltYWdlKFxuICAgICAgICAgICAgaW1hZ2UxLFxuICAgICAgICAgICAgLi4uY2xpcEdlb21ldG9yeUZyb21JbWFnZUNlbnRlcihzdGF0ZSksXG4gICAgICAgICAgICAtc3RhdGUuY2FudmFzV2lkdGggLyAyLFxuICAgICAgICAgICAgLXN0YXRlLmNhbnZhc0hlaWdodCAvIDIsXG4gICAgICAgICAgICBzdGF0ZS5jYW52YXNXaWR0aCxcbiAgICAgICAgICAgIHN0YXRlLmNhbnZhc0hlaWdodFxuICAgICAgICApO1xuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgIH1cblxuICAgIHZpZXdlcl9jdHgucmVzdG9yZSgpXG5cbiAgICAvLyBEcmF3IG5leHQgaW1hZ2VcbiAgICB2aWV3ZXJfY3R4LnNhdmUoKVxuICAgIHZpZXdlcl9jdHguYmVnaW5QYXRoKClcbiAgICB2aWV3ZXJfY3R4LmFyYygwLCAwLCBzdGF0ZS5jYW52YXNXaWR0aCAvIDIgLSBWSUVXX1BBRERJTkcsIDAsIE1hdGguUEkgKiAyLCBmYWxzZSlcbiAgICB2aWV3ZXJfY3R4LmNsaXAoKVxuXG4gICAgdmlld2VyX2N0eC5yb3RhdGUoXG4gICAgICAgIHJvdGF0ZVNpZ24oc3RhdGUuaXNDbG9ja3dpc2UpICogKHN0YXRlLnJvdGF0ZSArIHN0YXRlLmdldEltYWdlTnVtYmVyKHN0YXRlLnJvdGF0ZSArIHN0YXRlLnJvdGF0ZV9kZWdyZWVfc3RlcCkgKiBzdGF0ZS5yb3RhdGVfZGVncmVlX3N0ZXApIC8gMTgwICogTWF0aC5QSVxuICAgIClcblxuICAgIHZpZXdlcl9jdHguZ2xvYmFsQWxwaGEgPSAxIC0gYWxwaGFcbiAgICBjb25zdCBpbWFnZTIgPSBpbWFnZV9zcmNzW3N0YXRlLmdldEltYWdlTnVtYmVyKHN0YXRlLnJvdGF0ZSArIHN0YXRlLnJvdGF0ZV9kZWdyZWVfc3RlcCldXG4gICAgdHJ5IHtcbiAgICAgICAgdmlld2VyX2N0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBpbWFnZTIsXG4gICAgICAgICAgICAuLi5jbGlwR2VvbWV0b3J5RnJvbUltYWdlQ2VudGVyKHN0YXRlKSxcbiAgICAgICAgICAgIC1zdGF0ZS5jYW52YXNXaWR0aCAvIDIsXG4gICAgICAgICAgICAtc3RhdGUuY2FudmFzSGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHN0YXRlLmNhbnZhc1dpZHRoLFxuICAgICAgICAgICAgc3RhdGUuY2FudmFzSGVpZ2h0KVxuICAgIH0gY2F0Y2ggKGUpIHtcblxuICAgIH1cbiAgICB2aWV3ZXJfY3R4LnJlc3RvcmUoKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZHJhd0hhaXJMaW5lKHN0YXRlKSB7XG4gICAgaWYgKCFzdGF0ZS5kcmF3SGFpckxpbmUpIHJldHVyblxuICAgIHZpZXdlcl9jdHguc3Ryb2tlU3R5bGUgPSBzdGF0ZS5pc0Nyb3NzTmljb2xcbiAgICAgICAgPyBcIndoaXRlXCJcbiAgICAgICAgOiBcImJsYWNrXCI7XG4gICAgdmlld2VyX2N0eC5nbG9iYWxBbHBoYSA9IDFcbiAgICB2aWV3ZXJfY3R4LmJlZ2luUGF0aCgpXG4gICAgdmlld2VyX2N0eC5tb3ZlVG8oMCwgLXN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNSArIFZJRVdfUEFERElORylcbiAgICB2aWV3ZXJfY3R4LmxpbmVUbygwLCBzdGF0ZS5jYW52YXNIZWlnaHQgKiAwLjUgLSBWSUVXX1BBRERJTkcpXG4gICAgdmlld2VyX2N0eC5tb3ZlVG8oLXN0YXRlLmNhbnZhc1dpZHRoICogMC41ICsgVklFV19QQURESU5HLCAwKVxuICAgIHZpZXdlcl9jdHgubGluZVRvKHN0YXRlLmNhbnZhc1dpZHRoICogMC41IC0gVklFV19QQURESU5HLCAwKVxuICAgIHZpZXdlcl9jdHguY2xvc2VQYXRoKClcbiAgICB2aWV3ZXJfY3R4LnN0cm9rZSgpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbmNvbnN0IHNjYWxlTGVuZ3RoID0gKGNhbnZhc1dpZHRoLCBpbWFnZVdpZHRoLCBzY2FsZVdpZHRoKSA9PiBjYW52YXNXaWR0aCAqIHNjYWxlV2lkdGggLyBpbWFnZVdpZHRoXG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3U2NhbGUoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlW1wic2NhbGVXaWR0aFwiXSkgcmV0dXJuO1xuICAgIGxldCBzY2FsZVBpeGVsID0gc2NhbGVMZW5ndGgoc3RhdGUuY2FudmFzV2lkdGgsIHN0YXRlLmltYWdlUmFkaXVzICogMiwgc3RhdGUuc2NhbGVXaWR0aClcbiAgICBjb25zdCBjYW52YXNXaWR0aCA9IHN0YXRlLmNhbnZhc1dpZHRoO1xuICAgIGNvbnN0IHNjYWxlQmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNzY2FsZWJhclwiKVxuXG5cbiAgICBsZXQgc2NhbGVOdW1iZXIgPSBzdGF0ZS5zY2FsZVRleHQubWF0Y2goLyhcXGQrXFwuP1xcZCopLylbMF0gKiAxXG4gICAgY29uc3Qgc2NhbGVVbml0ID0gc3RhdGUuc2NhbGVUZXh0Lm1hdGNoKC9cXEQqJC8pWzBdXG5cbiAgICB3aGlsZSAoc2NhbGVQaXhlbCA+PSBjYW52YXNXaWR0aCkge1xuICAgICAgICBzY2FsZVBpeGVsICo9IDAuNVxuICAgICAgICBzY2FsZU51bWJlciAqPSAwLjVcbiAgICB9XG4gICAgc2NhbGVCYXIuc3R5bGUud2lkdGggPSBzY2FsZVBpeGVsICsgXCJweFwiO1xuICAgIHNjYWxlQmFyLnF1ZXJ5U2VsZWN0b3IoXCJkaXY6Zmlyc3QtY2hpbGRcIikuaW5uZXJIVE1MID0gYCR7c2NhbGVOdW1iZXJ9ICR7c2NhbGVVbml0fWA7XG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRDb29yZGluYXRlT25DYW52YXMoY2FudmFzKSB7XG4gICAgcmV0dXJuIChlLCBmaW5ndXIgPSAwKSA9PiB7XG4gICAgICAgIGlmIChlIGluc3RhbmNlb2YgTW91c2VFdmVudCkge1xuICAgICAgICAgICAgcmV0dXJuIChlIGluc3RhbmNlb2YgV2hlZWxFdmVudClcbiAgICAgICAgICAgICAgICA/IFtcbiAgICAgICAgICAgICAgICAgICAgZS5kZWx0YVgsXG4gICAgICAgICAgICAgICAgICAgIGUuZGVsdGFZXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgICAgICBlLnBhZ2VYIC0gY2FudmFzLm9mZnNldExlZnQsXG4gICAgICAgICAgICAgICAgICAgIGUucGFnZVkgLSBjYW52YXMub2Zmc2V0VG9wXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICB9IGVsc2UgaWYgKGUgaW5zdGFuY2VvZiBUb3VjaEV2ZW50ICYmIGUudG91Y2hlcy5sZW5ndGggPiBmaW5ndXIpIHtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZS50b3VjaGVzW2Zpbmd1cl0ucGFnZVggLSBjYW52YXMub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICBlLnRvdWNoZXNbZmluZ3VyXS5wYWdlWSAtIGNhbnZhcy5vZmZzZXRUb3BcbiAgICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJhZGl1bkJldHdlZW4oY3gsIGN5KSB7XG4gICAgcmV0dXJuIChfeDEsIF95MSwgX3gyLCBfeTIpID0+IHtcbiAgICAgICAgY29uc3QgeDEgPSBfeDEgLSBjeFxuICAgICAgICBjb25zdCB4MiA9IF94MiAtIGN4XG4gICAgICAgIGNvbnN0IHkxID0gX3kxIC0gY3lcbiAgICAgICAgY29uc3QgeTIgPSBfeTIgLSBjeVxuXG4gICAgICAgIGNvbnN0IGNvcyA9ICh4MSAqIHgyICsgeTEgKiB5MikgLyBNYXRoLnNxcnQoKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAqIHgyICsgeTIgKiB5MikpXG4gICAgICAgIHJldHVybiBNYXRoLnNpZ24oeDEgKiB5MiAtIHgyICogeTEpICogTWF0aC5hY29zKGNvcylcbiAgICB9XG59XG4iLCJpbXBvcnQgeyB2aWV3ZXIgfSBmcm9tIFwiLi92aWV3ZXJfY2FudmFzLmpzXCJcbmltcG9ydCBnZXRDb29yZGluYXRlT25DYW52YXMgZnJvbSBcIi4vZ2V0Q29vcmRpbmF0ZU9uQ2FudmFzLmpzXCJcbmltcG9ydCByYWRpdW5CZXR3ZWVuIGZyb20gXCIuL3JhZGl1bkJldHdlZW4uanNcIlxuXG5cbmV4cG9ydCBjb25zdCBjYW52YXNDb29yZGluYXRlID0gZ2V0Q29vcmRpbmF0ZU9uQ2FudmFzKHZpZXdlcilcblxuLyoqXG4gKiBVcGRhdGUgc3RhcnQgYW5kIGVuZCBwb3NpdGlvblxuICogQHBhcmFtIHsqfSBzdGF0ZVxuICogQHBhcmFtIHsqfSBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDb29yZGluYXRlKHN0YXRlLCBlKSB7XG4gICAgc3RhdGUuZHJhZ19zdGFydCA9IHN0YXRlLmRyYWdfZW5kIHx8IHVuZGVmaW5lZFxuICAgIHN0YXRlLmRyYWdfZW5kID0gY2FudmFzQ29vcmRpbmF0ZShlKVxuXG4gICAgc3RhdGUucGluY2hfc3RhcnQgPSBzdGF0ZS5waW5jaF9lbmQgfHwgdW5kZWZpbmVkXG4gICAgc3RhdGUucGluY2hfZW5kID0gY2FudmFzQ29vcmRpbmF0ZShlLCAxKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG4vKipcbiAqIENhbGN1bGF0ZSBzbWFsbCBkaWZmZXJlbmNlIG9mIHJvdGF0aW9uLlxuICogVXBkYXRlIHRvdGFsIHJvdGF0aW9uLlxuICpcbiAqIEBwYXJhbSB7Kn0gc3RhdGVcbiAqIEBwYXJhbSB7Kn0gZVxuICovXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlUm90YXRlKHN0YXRlLCBlKSB7XG4gICAgaWYgKCFzdGF0ZS5jYW5Sb3RhdGUpIHJldHVybjtcbiAgICBpZiAoc3RhdGUuZHJhZ19zdGFydCA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICAvLyBkZWx0YSByb3RhdGUgcmFkaXVzXG4gICAgY29uc3Qgcm90YXRlX2VuZCA9IHJhZGl1bkJldHdlZW4oXG4gICAgICAgIHN0YXRlLmNhbnZhc1dpZHRoICogMC41LFxuICAgICAgICBzdGF0ZS5jYW52YXNIZWlnaHQgKiAwLjVcbiAgICApKC4uLnN0YXRlLmRyYWdfZW5kLCAuLi5zdGF0ZS5kcmFnX3N0YXJ0KVxuXG4gICAgc3RhdGUucm90YXRlICs9IHJvdGF0ZV9lbmQgLyBNYXRoLlBJICogMTgwXG4gICAgaWYgKHN0YXRlLnJvdGF0ZSA+PSAzNjApIHtcbiAgICAgICAgc3RhdGUucm90YXRlIC09IDM2MFxuICAgIH0gZWxzZSBpZiAoc3RhdGUucm90YXRlIDwgMCkge1xuICAgICAgICBzdGF0ZS5yb3RhdGUgKz0gMzYwXG4gICAgfVxuICAgIHJldHVybiBzdGF0ZVxufVxuIiwiaW1wb3J0IHsgdXBkYXRlQ29vcmRpbmF0ZSwgdXBkYXRlUm90YXRlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZV91cGRhdG9ycy5qc1wiXG5pbXBvcnQgeyBibG9iVG9DYW52YXMsIGRyYXdIYWlyTGluZSB9IGZyb20gXCIuL2RyYXdfc3RhdGVfdXBkYXRvcnMuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiByb3RhdGVJbWFnZShzdGF0ZSwgZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZUNvb3JkaW5hdGUoc3RhdGUsIGUpXG4gICAgICAgIHVwZGF0ZVJvdGF0ZShzdGF0ZSwgZSlcbiAgICAgICAgYmxvYlRvQ2FudmFzKHN0YXRlKVxuICAgICAgICBkcmF3SGFpckxpbmUoc3RhdGUpXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2FudmFzQ29vcmRpbmF0ZSB9IGZyb20gXCIuL2Nvb3JkaW5hdGVfdXBkYXRvcnMuanNcIlxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWFnbmlmeUJ5UGluY2goc3RhdGUsIGUpIHtcbiAgICBpZiAoc3RhdGUuZHJhZ19zdGFydCA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBpZiAoc3RhdGUucGluY2hfc3RhcnQgPT09IHVuZGVmaW5lZCkgcmV0dXJuXG5cbiAgICBjb25zdCB4MSA9IFsuLi5zdGF0ZS5kcmFnX3N0YXJ0XVxuICAgIGNvbnN0IHkxID0gWy4uLnN0YXRlLnBpbmNoX3N0YXJ0XVxuICAgIGNvbnN0IHgyID0gWy4uLnN0YXRlLmRyYWdfZW5kXVxuICAgIGNvbnN0IHkyID0gWy4uLnN0YXRlLnBpbmNoX2VuZF1cblxuICAgIGNvbnN0IGV4cGFuc2lvbiA9IE1hdGguc3FydCgoeDJbMF0gLSB5MlswXSkgKiogMiArICh4MlsxXSAtIHkyWzFdKSAqKiAyKSAvIE1hdGguc3FydCgoeDFbMF0gLSB5MVswXSkgKiogMiArICh4MVsxXSAtIHkxWzFdKSAqKiAyKVxuXG4gICAgY29uc3QgbmV3UmFkaXVzID0gKGV4cGFuc2lvbiA+IDIpXG4gICAgICAgID8gc3RhdGUuaW1hZ2VSYWRpdXNcbiAgICAgICAgOiBzdGF0ZS5pbWFnZVJhZGl1cyAvIGV4cGFuc2lvblxuICAgIHN0YXRlLmltYWdlUmFkaXVzID0gKG5ld1JhZGl1cykgPiBzdGF0ZS5pbWFnZVJhZGl1c09yaWdpbmFsXG4gICAgICAgID8gc3RhdGUuaW1hZ2VSYWRpdXNPcmlnaW5hbFxuICAgICAgICA6IChuZXdSYWRpdXMgPCAxMDApXG4gICAgICAgICAgICA/IDEwMFxuICAgICAgICAgICAgOiBuZXdSYWRpdXNcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZU1hZ25pZnlCeVdoZWVsKHN0YXRlLCBlKSB7XG4gICAgY29uc3Qgc2Nyb2xsZWQgPSBjYW52YXNDb29yZGluYXRlKGUpWzFdXG5cbiAgICBjb25zdCBuZXdSYWRpdXMgPSBzdGF0ZS5pbWFnZVJhZGl1cyArIHNjcm9sbGVkXG4gICAgc3RhdGUuaW1hZ2VSYWRpdXMgPSAobmV3UmFkaXVzKSA+IHN0YXRlLmltYWdlUmFkaXVzT3JpZ2luYWxcbiAgICAgICAgPyBzdGF0ZS5pbWFnZVJhZGl1c09yaWdpbmFsXG4gICAgICAgIDogKG5ld1JhZGl1cyA8IDEwMClcbiAgICAgICAgICAgID8gMTAwXG4gICAgICAgICAgICA6IG5ld1JhZGl1c1xuICAgIHJldHVybiBzdGF0ZVxufVxuIiwiaW1wb3J0IHsgdXBkYXRlQ29vcmRpbmF0ZSB9IGZyb20gXCIuL2Nvb3JkaW5hdGVfdXBkYXRvcnMuanNcIlxuaW1wb3J0IHsgdXBkYXRlTWFnbmlmeUJ5UGluY2ggfSBmcm9tIFwiLi91cGRhdGVNYWduaWZ5LmpzXCJcbmltcG9ydCB7IGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lLCBkcmF3U2NhbGUgfSBmcm9tIFwiLi9kcmF3X3N0YXRlX3VwZGF0b3JzLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGluY2hJbWFnZShzdGF0ZSwgZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZUNvb3JkaW5hdGUoc3RhdGUsIGUpXG4gICAgICAgIHVwZGF0ZU1hZ25pZnlCeVBpbmNoKHN0YXRlLCBlKVxuICAgICAgICBibG9iVG9DYW52YXMoc3RhdGUpXG4gICAgICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICAgICAgZHJhd1NjYWxlKHN0YXRlKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IGNhbnZhc0Nvb3JkaW5hdGUgfSBmcm9tIFwiLi9jb29yZGluYXRlX3VwZGF0b3JzLmpzXCJcbmltcG9ydCByb3RhdGVJbWFnZSBmcm9tIFwiLi9yb3RhdGVJbWFnZS5qc1wiXG5pbXBvcnQgcGluY2hJbWFnZSBmcm9tIFwiLi9waW5jaEltYWdlLmpzXCJcblxuZXhwb3J0IGNvbnN0IHRvdWNoU3RhcnRIYW5kbGVyID0gc3RhdGUgPT4gZSA9PiB7XG4gICAgc3RhdGUuaXNNb3VzZWRvd24gPSB0cnVlXG4gICAgc3RhdGUuZHJhZ19lbmQgPSBjYW52YXNDb29yZGluYXRlKGUpXG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xufVxuXG5leHBvcnQgY29uc3QgdG91Y2hNb3ZlSGFuZGxlciA9IHN0YXRlID0+IGUgPT4ge1xuICAgIGlmICghc3RhdGUuaXNNb3VzZWRvd24pIHJldHVyblxuICAgIGlmIChlIGluc3RhbmNlb2YgTW91c2VFdmVudCB8fCBlLnRvdWNoZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICAgICAgcm90YXRlSW1hZ2Uoc3RhdGUsIGUpXG4gICAgICAgIClcbiAgICB9IGVsc2UgaWYgKGUudG91Y2hlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgICAgIHBpbmNoSW1hZ2Uoc3RhdGUsIGUpXG4gICAgICAgIClcbiAgICB9XG59XG5cbmV4cG9ydCBjb25zdCB0b3VjaEVuZEhhbmRsZXIgPSBzdGF0ZSA9PiBlID0+IHtcbiAgICBzdGF0ZS5pc01vdXNlZG93biA9IGZhbHNlXG4gICAgc3RhdGUuZHJhZ19lbmQgPSB1bmRlZmluZWRcbiAgICBzdGF0ZS5waW5jaF9lbmQgPSB1bmRlZmluZWRcbiAgICBlLnByZXZlbnREZWZhdWx0KClcbn1cbiIsImltcG9ydCB7IHVwZGF0ZU1hZ25pZnlCeVdoZWVsIH0gZnJvbSBcIi4vdXBkYXRlTWFnbmlmeS5qc1wiXG5pbXBvcnQgeyBibG9iVG9DYW52YXMsIGRyYXdIYWlyTGluZSwgZHJhd1NjYWxlIH0gZnJvbSBcIi4vZHJhd19zdGF0ZV91cGRhdG9ycy5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHdoZWVsSW1hZ2Uoc3RhdGUsIGUpIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICB1cGRhdGVNYWduaWZ5QnlXaGVlbChzdGF0ZSwgZSlcbiAgICAgICAgYmxvYlRvQ2FudmFzKHN0YXRlKVxuICAgICAgICBkcmF3SGFpckxpbmUoc3RhdGUpXG4gICAgICAgIGRyYXdTY2FsZShzdGF0ZSlcbiAgICB9XG59XG4iLCJpbXBvcnQgd2hlZWxJbWFnZSBmcm9tIFwiLi93aGVlbEltYWdlLmpzXCJcblxuZXhwb3J0IGNvbnN0IHdoZWVsSGFuZGxlciA9IHN0YXRlID0+IGUgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXG4gICAgICAgIHdoZWVsSW1hZ2Uoc3RhdGUsIGUpXG4gICAgKVxufVxuIiwiaW1wb3J0IGluaXRTdGF0ZSBmcm9tIFwiLi9zdGF0ZS9pbml0U3RhdGUuanNcIlxuaW1wb3J0IFBhY2thZ2VNYW5pZmVzdCBmcm9tIFwiLi9wYWNrYWdlX21hbmlmZXN0LmpzXCJcbmltcG9ydCB1cGRhdGVWaWV3ZXJHZW9tZXRyeSBmcm9tIFwiLi91cGRhdGVWaWV3ZXJHZW9tZXRyeS5qc1wiXG5pbXBvcnQgdXBkYXRlU3RhdGVCeU1ldGEgZnJvbSBcIi4vdXBkYXRlU3RhdGVCeU1ldGEuanNcIlxuaW1wb3J0IHsgc2hvd1ZpZXdlciwgc2hvd05pY29sQnV0dG9uIH0gZnJvbSBcIi4vdmlld2VyX2hhbmRsZXJzLmpzXCJcbmltcG9ydCB7IHZpZXdlciB9IGZyb20gXCIuL3ZpZXdlcl9jYW52YXMuanNcIlxuaW1wb3J0IHsgY2xlYXJWaWV3LCBibG9iVG9DYW52YXMsIGRyYXdIYWlyTGluZSwgZHJhd1NjYWxlIH0gZnJvbSBcIi4vZHJhd19zdGF0ZV91cGRhdG9ycy5qc1wiXG5pbXBvcnQgeyBjYW52YXNDb29yZGluYXRlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZV91cGRhdG9ycy5qc1wiXG5pbXBvcnQgeyB0b3VjaFN0YXJ0SGFuZGxlciwgdG91Y2hFbmRIYW5kbGVyLCB0b3VjaE1vdmVIYW5kbGVyIH0gZnJvbSBcIi4vdG91Y2hFdmVudEhhbmRsZXJzLmpzXCJcbmltcG9ydCB7IHdoZWVsSGFuZGxlciB9IGZyb20gXCIuL3doZWVsRXZlbnRIYW5kbGVyLmpzXCJcblxuY29uc3QgcGFja2FnZU1hcCA9IG5ldyBQYWNrYWdlTWFuaWZlc3QoKTtcbmNvbnN0IHVwbG9hZF9zdGF0ZSA9IE9iamVjdC5hc3NpZ24oXG4gICAgaW5pdFN0YXRlKCksXG4gICAge1xuICAgICAgICBcImxvYWRJbWFnZXNcIjogW2ZhbHNlLCB0cnVlXSxcbiAgICAgICAgXCJhdXRvUm90YXRlXCI6IGZhbHNlLFxuICAgICAgICBcInZpZXdNb2RlXCI6IFwidmFsaWRhdGlvblwiLFxuICAgICAgICBcImxhbmd1YWdlXCI6IFwiamFcIixcbiAgICAgICAgXCJkZXNpcmVkSW1hZ2VTaXplXCI6IDE1MCxcbiAgICAgICAgXCJkZXNpcmVkVGh1bWJuYWlsSW1hZ2VTaXplXCI6IDEwMCxcbiAgICB9XG4pXG5cbmZ1bmN0aW9uIGJvdGhJbWFnZXNMb2FkZWQoZmxhZ3MpIHtcbiAgICByZXR1cm4gZmxhZ3MucmVkdWNlKChhY2MsIGUpID0+IGFjYyAmJiBlLCB0cnVlKVxufVxuXG5mdW5jdGlvbiBmaWxlU2VsZWN0SGFuZGVyKGUpIHtcbiAgICBmdW5jdGlvbiByZWFkKGZpbGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKVxuICAgICAgICAgICAgcmVhZGVyLnJlYWRBc0RhdGFVUkwoZmlsZSlcbiAgICAgICAgICAgIHJlYWRlci5vbmxvYWRlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzKHJlYWRlci5yZXN1bHQpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgY29uc3QgZmlsZXMgPSBlLnRhcmdldC5maWxlcztcbiAgICAgICAgUHJvbWlzZS5hbGwoXG4gICAgICAgICAgICBBcnJheS5mcm9tKGZpbGVzKVxuICAgICAgICAgICAgICAgIC5tYXAoZmlsZSA9PiByZWFkKGZpbGUpKVxuICAgICAgICApLnRoZW4ocmVzKVxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIHJlYWRJbWFnZVNpemUoc3RhdGUpIHtcbiAgICBwYWNrYWdlTWFwLnNldEltYWdlU2l6ZShzdGF0ZS5vcGVuX2ltYWdlc1swXSlcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZnVuY3Rpb24gcmVhZEltYWdlc051bWJlcihzdGF0ZSkge1xuICAgIHBhY2thZ2VNYXAuc2V0SW1hZ2VzTnVtYmVyKHN0YXRlLm9wZW5faW1hZ2VzLmxlbmd0aClcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuYXN5bmMgZnVuY3Rpb24gc2hvd0ltYWdlcyhzdGF0ZSkge1xuICAgIHJlYWRJbWFnZVNpemUoc3RhdGUpXG4gICAgcmVhZEltYWdlc051bWJlcihzdGF0ZSlcbiAgICBjb25zdCBuZXdfc3RhdGUgPSBhd2FpdCB1cGRhdGVTdGF0ZUJ5TWV0YShzdGF0ZSwgXCJ1cGxvYWRcIikocGFja2FnZU1hcC5wYWNrYWdlSUQsIHBhY2thZ2VNYXAudG9KU09OKCkpXG5cbiAgICBuZXdfc3RhdGUub3Blbl9pbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChzdGF0ZS5vcGVuX2ltYWdlX3NyY3MubWFwKGxvYWRJbWFnZUZyb21TcmMpKVxuICAgIG5ld19zdGF0ZS5jcm9zc19pbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChzdGF0ZS5jcm9zc19pbWFnZV9zcmNzLm1hcChsb2FkSW1hZ2VGcm9tU3JjKSlcblxuICAgIHJldHVybiB1cGRhdGVWaWV3KG5ld19zdGF0ZSlcbiAgICAgICAgLnRoZW4oc2hvd1ZpZXdlcilcbiAgICAgICAgLnRoZW4oc2hvd05pY29sQnV0dG9uKVxufVxuXG5mdW5jdGlvbiBsb2FkSW1hZ2VGcm9tU3JjKHNyYykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblxuICAgICAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKVxuXG4gICAgICAgIGltZy5vbmxvYWQgPSBfID0+IHtcbiAgICAgICAgICAgIHJlcyhpbWcpXG4gICAgICAgIH1cblxuICAgICAgICBpbWcuc3JjID0gc3JjXG5cbiAgICB9KVxufVxuXG5mdW5jdGlvbiBvcGVuSW1hZ2VzU2VsZWN0SGFuZGxlcihzdGF0ZSkge1xuICAgIHJldHVybiBlID0+IG5ldyBQcm9taXNlKGFzeW5jIChyZXMsIHJlaikgPT4ge1xuICAgICAgICBzdGF0ZS5vcGVuX2ltYWdlX3NyY3MgPSBhd2FpdCBmaWxlU2VsZWN0SGFuZGVyKGUpXG4gICAgICAgIHN0YXRlLmxvYWRJbWFnZXNbMF0gPSB0cnVlXG4gICAgICAgIHN0YXRlLm9wZW5faW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoc3RhdGUub3Blbl9pbWFnZV9zcmNzLm1hcChsb2FkSW1hZ2VGcm9tU3JjKSlcbiAgICAgICAgYXdhaXQgc2hvd0ltYWdlcyhzdGF0ZSlcblxuICAgICAgICByZXMoc3RhdGUpXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gY3Jvc3NJbWFnZXNTZWxlY3RIYW5kbGVyKHN0YXRlKSB7XG4gICAgcmV0dXJuIGUgPT4gbmV3IFByb21pc2UoYXN5bmMgKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHN0YXRlLmNyb3NzX2ltYWdlX3NyY3MgPSBhd2FpdCBmaWxlU2VsZWN0SGFuZGVyKGUpXG4gICAgICAgIHN0YXRlLmxvYWRJbWFnZXNbMV0gPSB0cnVlXG4gICAgICAgIHN0YXRlLmNyb3NzX2ltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKHN0YXRlLmNyb3NzX2ltYWdlX3NyY3MubWFwKGxvYWRJbWFnZUZyb21TcmMpKVxuICAgICAgICBhd2FpdCBzaG93SW1hZ2VzKHN0YXRlKVxuXG4gICAgICAgIHJlcyhzdGF0ZSlcbiAgICB9KVxufVxuXG5hc3luYyBmdW5jdGlvbiB1cGRhdGVWaWV3KHN0YXRlKSB7XG4gICAgY2xlYXJWaWV3KHN0YXRlKVxuICAgIGJsb2JUb0NhbnZhcyhzdGF0ZSlcbiAgICBkcmF3SGFpckxpbmUoc3RhdGUpXG4gICAgZHJhd1NjYWxlKHN0YXRlKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5cbmZ1bmN0aW9uIGFjdGl2YXRlRG9tKHNlbGVjdG9yKSB7XG4gICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSlcbiAgICAgICAgLmZvckVhY2goZG9tID0+IHtcbiAgICAgICAgICAgIGRvbS5jbGFzc0xpc3QucmVtb3ZlKFwiaW5hY3RpdmVcIilcbiAgICAgICAgfSlcbn1cblxuXG5mdW5jdGlvbiBiYXNlNjRUb0Jsb2IoYmFzZTY0LCBtaW1lKSB7XG4gICAgdmFyIGJpbmFyeSA9IGF0b2IoYmFzZTY0KTtcbiAgICB2YXIgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYmluYXJ5Lmxlbmd0aClcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJpbmFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICBidWZmZXJbaV0gPSBiaW5hcnkuY2hhckNvZGVBdChpKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBCbG9iKFtidWZmZXIuYnVmZmVyXSwge1xuICAgICAgICB0eXBlOiBtaW1lXG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNvbXByZXNzSW1hZ2VTcmMoc3JjLCBmb3JtYXQsIGRlc2lyZWRLQnl0ZSA9IDE1MCkge1xuICAgIGNvbnNvbGUuYXNzZXJ0KFtcImpwZWdcIiwgXCJ3ZWJwXCJdLmluY2x1ZGVzKGZvcm1hdCkpXG5cbiAgICBjb25zdCBpbWFnZSA9IG5ldyBJbWFnZSgpXG4gICAgaW1hZ2Uuc3JjID0gc3JjXG4gICAgY29uc3QgdyA9IGltYWdlLndpZHRoXG4gICAgY29uc3QgaCA9IGltYWdlLmhlaWdodFxuICAgIGNvbnN0IGN2cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjd29ya2luZ19jYW52YXNcIilcbiAgICBjdnMud2lkdGggPSB3XG4gICAgY3ZzLmhlaWdodCA9IGhcbiAgICBjb25zdCBjdHggPSBjdnMuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgdywgaClcblxuICAgIGNvbnN0IG9yaWdpbmFsQmluYXJ5ID0gY3ZzLnRvRGF0YVVSTChgaW1hZ2UvJHtmb3JtYXR9YCk7IC8v55S76LOq6JC944Go44GV44Ga44OQ44Kk44OK44Oq5YyWXG4gICAgY29uc3QgbWltZSA9IG9yaWdpbmFsQmluYXJ5Lm1hdGNoKC8oOikoW2EtelxcL10rKSg7KS8pWzJdXG5cbiAgICBjb25zdCBvcmlnaW5hbEJsb2IgPSBiYXNlNjRUb0Jsb2Iob3JpZ2luYWxCaW5hcnkuc3BsaXQoXCIsXCIpWzFdLCBtaW1lKTtcblxuICAgIGlmIChkZXNpcmVkS0J5dGUgKiAxZTMgPCBvcmlnaW5hbEJsb2JbXCJzaXplXCJdKSB7XG4gICAgICAgIGNvbnN0IGNhcGFjaXR5UmF0aW8gPSBkZXNpcmVkS0J5dGUgKiAxZTMgLyBvcmlnaW5hbEJsb2JbXCJzaXplXCJdO1xuICAgICAgICBjb25zdCBwcm9jZXNzaW5nQmluYXJ5ID0gY3ZzLnRvRGF0YVVSTChgaW1hZ2UvJHtmb3JtYXR9YCwgY2FwYWNpdHlSYXRpbyk7IC8v55S76LOq6JC944Go44GX44Gm44OQ44Kk44OK44Oq5YyWXG4gICAgICAgIHJldHVybiBiYXNlNjRUb0Jsb2IocHJvY2Vzc2luZ0JpbmFyeS5zcGxpdChcIixcIilbMV0sIG1pbWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvcmlnaW5hbEJsb2JcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHNob3dFcnJvck1lc3NhZ2UoZG9tSWQsIG1lc3NhZ2UpIHtcbiAgICBjb25zdCBtZXNzYWdlRG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihkb21JZClcbiAgICBtZXNzYWdlRG9tLmlubmVySFRNTCA9IG1lc3NhZ2VcbiAgICBtZXNzYWdlRG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKVxufVxuXG5mdW5jdGlvbiBoaWRlRXJyb3JNZXNzYWdlKGRvbUlkKSB7XG4gICAgY29uc3QgbWVzc2FnZURvbSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZG9tSWQpXG4gICAgbWVzc2FnZURvbS5jbGFzc0xpc3QuYWRkKFwiaW5hY3RpdmVcIilcbn1cblxuXG5mdW5jdGlvbiBzZW5kU2FtcGxlTGlzdEVudHJ5KGpzb25fb2JqKSB7XG4gICAgaWYgKGpzb25fb2JqW1wicGFja2FnZS1uYW1lXCJdLm1hdGNoKG5ldyBSZWdFeHAoXCJeWzAtOWEtekEtWl8tXSskXCIpKSA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQYWNrYWdlIElEIHNob3VsZCBjb250YWluIG9ubHkgbnVtYmVyLCBhbHBoYWJldCwgXywgYW5kIC0uXCIpXG4gICAgfVxuICAgIGlmIChPYmplY3Qua2V5cyhqc29uX29ialtcImxpc3QtbmFtZVwiXSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNhbXBsZSB0aXRsZSBpcyBub3Qgc2V0LlwiKVxuICAgIH1cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Rldl9zYW1wbGVfbGlzdF9lbnRyeVwiKS5pbm5lckhUTUwgPSBKU09OLnN0cmluZ2lmeShqc29uX29iaiwgbnVsbCwgMilcbn07XG5cbmZ1bmN0aW9uIGluaXRpYWxpemVPclVwZGF0ZUlucHV0KGlucHV0RG9tLCB2YWx1ZSkge1xuICAgIGlmICghaW5wdXREb20udmFsdWUpIHtcbiAgICAgICAgaW5wdXREb20udmFsdWUgPSB2YWx1ZVxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hvd1BhY2thZ2VTaXplKHN0YXRlKSB7XG4gICAgLy8gU3VtIG9wZW4gYW5kIGNyb3NzIGltYWdlcyAoY29udGFpbnMgdGh1bWJuYWlsKVxuICAgIGNvbnN0IGltYWdlc1NpemUgPSAoc3RhdGUub3Blbl9pbWFnZV9zcmNzLmxlbmd0aCAqIHN0YXRlLmRlc2lyZWRJbWFnZVNpemUgKyBzdGF0ZS5kZXNpcmVkVGh1bWJuYWlsSW1hZ2VTaXplKSAqIDJcbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI21lc3NhZ2VfcGFja2FnZV9zaXplXCIpLmlubmVySFRNTCA9IGltYWdlc1NpemVcbn1cblxuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaW5wdXRfcGFja2FnZV9pZFwiKS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0UGFja2FnZUlEKGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaW5wdXRfZGVzaXJlZF9pbWFnZV9zaXplXCIpLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZGVzaXJlZEltYWdlU2l6ZSA9IHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICBzaG93UGFja2FnZVNpemUoc3RhdGUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dF9kZXNpcmVkX3RodW1ibmFpbF9pbWFnZV9zaXplXCIpLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgc3RhdGUuZGVzaXJlZFRodW1ibmFpbEltYWdlU2l6ZSA9IHBhcnNlRmxvYXQoZS50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICBzaG93UGFja2FnZVNpemUoc3RhdGUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgY29uc3QgY2VudGVyVG9SaWdodCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjcm90YXRlX2NlbnRlcl9mcm9tX2xlZnRcIilcbiAgICBjZW50ZXJUb1JpZ2h0LmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgc3RhdGUucm90YXRlX2NlbnRlci50b19yaWdodCA9IHBhcnNlRmxvYXQoY2VudGVyVG9SaWdodC52YWx1ZSlcbiAgICAgICAgICAgIHVwZGF0ZVZpZXcoc3RhdGUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuICAgIGNvbnN0IGNlbnRlclRvQm90dG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb3RhdGVfY2VudGVyX2Zyb21fdG9wXCIpXG4gICAgY2VudGVyVG9Cb3R0b20uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5yb3RhdGVfY2VudGVyLnRvX2JvdHRvbSA9IHBhcnNlRmxvYXQoY2VudGVyVG9Cb3R0b20udmFsdWUpXG4gICAgICAgICAgICB1cGRhdGVWaWV3KHN0YXRlKVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjb3Blbl9uaWNvbF9pbWFnZXNcIikuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBvcGVuSW1hZ2VzU2VsZWN0SGFuZGxlcihzdGF0ZSkoZSkudGhlbihzdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU9yVXBkYXRlSW5wdXQoY2VudGVyVG9SaWdodCwgc3RhdGUub3Blbl9pbWFnZXNbMF0ud2lkdGggLyAyKVxuICAgICAgICAgICAgICAgIGluaXRpYWxpemVPclVwZGF0ZUlucHV0KGNlbnRlclRvQm90dG9tLCBzdGF0ZS5vcGVuX2ltYWdlc1swXS5oZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgIHNob3dQYWNrYWdlU2l6ZShzdGF0ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjcm9zc19uaWNvbF9pbWFnZXNcIikuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBjcm9zc0ltYWdlc1NlbGVjdEhhbmRsZXIoc3RhdGUpKGUpLnRoZW4oc3RhdGUgPT4ge1xuICAgICAgICAgICAgICAgIGluaXRpYWxpemVPclVwZGF0ZUlucHV0KGNlbnRlclRvUmlnaHQsIHN0YXRlLmNyb3NzX2ltYWdlc1swXS53aWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU9yVXBkYXRlSW5wdXQoY2VudGVyVG9Cb3R0b20sIHN0YXRlLmNyb3NzX2ltYWdlc1swXS5oZWlnaHQgLyAyKVxuICAgICAgICAgICAgICAgIHNob3dQYWNrYWdlU2l6ZShzdGF0ZSlcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgY29uc3Qgcm90YXRlRGlyZWN0aW9uU2VsZWN0b3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3NlbGVjdF9yb3RhdGVfZGlyZWN0aW9uXCIpXG4gICAgcm90YXRlRGlyZWN0aW9uU2VsZWN0b3IuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkaXJlY3Rpb24gPSBlLnRhcmdldC5vcHRpb25zW2UudGFyZ2V0LnNlbGVjdGVkSW5kZXhdLnZhbHVlXG4gICAgICAgICAgICBwYWNrYWdlTWFwLnNldFJvdGF0ZURpcmVjdGlvbihkaXJlY3Rpb24pXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgY29uc3QgaW5wdXRSb3RhdGlvbkludGVydmFsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dF9yb3RhdGlvbl9pbnRlcnZhbFwiKVxuICAgIGlucHV0Um90YXRpb25JbnRlcnZhbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0RWFjaFJvdGF0ZURlZ3JlZShpbnB1dFJvdGF0aW9uSW50ZXJ2YWwudmFsdWUpXG4gICAgICAgICAgICBhY3RpdmF0ZURvbShcIiNzZWxlY3RfaW1hZ2Vfd3JhcHBlclwiKVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIGNvbnN0IGlucHV0U2NhbGVVbml0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dF9zY2FsZV91bml0XCIpXG4gICAgaW5wdXRTY2FsZVVuaXQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBwYWNrYWdlTWFwLnNldFNjYWxlVW5pdChpbnB1dFNjYWxlVW5pdC52YWx1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBjb25zdCBpbnB1dFNjYWxlTGVuZ3RoID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dF9zY2FsZV9sZW5ndGhcIilcbiAgICBpbnB1dFNjYWxlTGVuZ3RoLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgcGFja2FnZU1hcC5zZXRTY2FsZVBpeGVsKGlucHV0U2NhbGVMZW5ndGgudmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgY29uc3QgaW5wdXRNYWduaWZpY2F0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dF9tYWduaWZpY2F0aW9uXCIpXG4gICAgaW5wdXRNYWduaWZpY2F0aW9uLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgcGFja2FnZU1hcC5zZXRNYWduaWZ5KGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIGNvbnN0IGlucHV0U2FtcGxlTGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0X3NhbXBsZV9sYWJlbFwiKVxuICAgIGlucHV0U2FtcGxlTGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBwYWNrYWdlTWFwLnNldFNhbXBsZUxhYmVsKGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5pbnB1dF9zYW1wbGVfbG9jYXRpb25cIikpLmZvckVhY2goZG9tID0+IHtcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgICAgcGFja2FnZU1hcC5zZXRTYW1wbGVMb2NhdGlvbihlLnRhcmdldC5kYXRhc2V0LmxhbmcsIGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICB9KVxuXG4gICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmlucHV0X3NhbXBsZV90eXBlXCIpKS5mb3JFYWNoKGRvbSA9PiB7XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0Um9ja1R5cGUoZS50YXJnZXQuZGF0YXNldC5sYW5nLCBlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgfSlcblxuICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5pbnB1dF9kZXNjcmlwdGlvblwiKSkuZm9yRWFjaChkb20gPT4ge1xuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICBwYWNrYWdlTWFwLnNldERlc2NyaXB0aW9uKGUudGFyZ2V0LmRhdGFzZXQubGFuZywgZS50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgIH0pXG5cbiAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuaW5wdXRfc2FtcGxlX3RpdGxlXCIpKVxuICAgICAgICAuZm9yRWFjaChkb20gPT4ge1xuICAgICAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcGFja2FnZU1hcC5zZXRMaXN0TmFtZShlLnRhcmdldC5kYXRhc2V0LmxhbmcsIGUudGFyZ2V0LnZhbHVlKVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKVxuICAgICAgICB9KVxuXG4gICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmlucHV0X293bmVyXCIpKS5mb3JFYWNoKGRvbSA9PiB7XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0T3duZXIoZS50YXJnZXQuZGF0YXNldC5sYW5nLCBlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgfSlcblxuICAgIGNvbnN0IHRvZ2dsZU5pY29sQnV0dG9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjaGFuZ2Vfbmljb2xcIilcbiAgICBjb25zdCB0b2dnbGVOaWNvbExhYmVsID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjaGFuZ2Vfbmljb2wgKyBsYWJlbFwiKVxuXG4gICAgY29uc3QgdG9nZ2xlTmljb2xIYW5kbGVyID0gc3RhdGUgPT4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG5cbiAgICAgICAgdG9nZ2xlTmljb2xCdXR0b24uY2hlY2tlZCA9IHN0YXRlLmlzQ3Jvc3NOaWNvbFxuICAgICAgICBzdGF0ZS5pc0Nyb3NzTmljb2wgPSAhc3RhdGUuaXNDcm9zc05pY29sO1xuXG4gICAgICAgIHJlcyhzdGF0ZSlcbiAgICB9KVxuXG4gICAgdG9nZ2xlTmljb2xCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG5cbiAgICB0b2dnbGVOaWNvbExhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHRvZ2dsZU5pY29sQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hcIixcbiAgICAgICAgZSA9PiB7IGUucHJldmVudERlZmF1bHQoKSB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuXG4gICAgdG9nZ2xlTmljb2xMYWJlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNldXBcIixcbiAgICAgICAgZSA9PiB0b2dnbGVOaWNvbEhhbmRsZXIoc3RhdGUpXG4gICAgICAgICAgICAudGhlbih1cGRhdGVWaWV3KSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB0b2dnbGVOaWNvbExhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hlbmRcIixcbiAgICAgICAgZSA9PiB0b2dnbGVOaWNvbEhhbmRsZXIoc3RhdGUpXG4gICAgICAgICAgICAudGhlbih1cGRhdGVWaWV3KVxuICAgICAgICAgICAgLnRoZW4oXyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGUuY2FuY2VsYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLm9uY29udGV4dG1lbnUgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zdCBwb3NpdGlvbl9vbl9jYW52YXMgPSBjYW52YXNDb29yZGluYXRlKGUpXG4gICAgICAgIGNvbnN0IGN1cnJlbnRfcm90YXRlX2NlbnRlciA9IE9iamVjdC52YWx1ZXMoc3RhdGUucm90YXRlX2NlbnRlcilcbiAgICAgICAgY29uc3Qgc2hpZnQgPSBbXG4gICAgICAgICAgICBwb3NpdGlvbl9vbl9jYW52YXNbMF0gLSBzdGF0ZS5jYW52YXNXaWR0aCAqIDAuNSxcbiAgICAgICAgICAgIHBvc2l0aW9uX29uX2NhbnZhc1sxXSAtIHN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNVxuICAgICAgICBdXG5cbiAgICAgICAgc3RhdGUucm90YXRlX2NlbnRlci50b19yaWdodCArPSBwYXJzZUludChzaGlmdFswXSAqIHN0YXRlLmltYWdlUmFkaXVzIC8gc3RhdGUuY2FudmFzV2lkdGggKiAyKVxuICAgICAgICBzdGF0ZS5yb3RhdGVfY2VudGVyLnRvX2JvdHRvbSArPSBwYXJzZUludChzaGlmdFsxXSAqIHN0YXRlLmltYWdlUmFkaXVzIC8gc3RhdGUuY2FudmFzV2lkdGggKiAyKVxuXG4gICAgICAgIHBhY2thZ2VNYXAuc2V0Um90YXRlQ2VudGVyKFxuICAgICAgICAgICAgc3RhdGUucm90YXRlX2NlbnRlci50b19yaWdodCxcbiAgICAgICAgICAgIHN0YXRlLnJvdGF0ZV9jZW50ZXIudG9fYm90dG9tXG4gICAgICAgIClcblxuICAgICAgICBjZW50ZXJUb1JpZ2h0LnZhbHVlID0gc3RhdGUucm90YXRlX2NlbnRlci50b19yaWdodFxuICAgICAgICBjZW50ZXJUb0JvdHRvbS52YWx1ZSA9IHN0YXRlLnJvdGF0ZV9jZW50ZXIudG9fYm90dG9tXG5cbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgIHVwZGF0ZVZpZXcoc3RhdGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZWRvd25cIixcbiAgICAgICAgdG91Y2hTdGFydEhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImRyYWdzdGFydFwiLFxuICAgICAgICBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiZHJhZ1wiLFxuICAgICAgICBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiZHJhZ2VuZFwiLFxuICAgICAgICBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hzdGFydFwiLFxuICAgICAgICB0b3VjaFN0YXJ0SGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2Vtb3ZlXCIsXG4gICAgICAgIHRvdWNoTW92ZUhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcInRvdWNobW92ZVwiLFxuICAgICAgICB0b3VjaE1vdmVIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZXVwXCIsXG4gICAgICAgIHRvdWNoRW5kSGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2hlbmRcIixcbiAgICAgICAgdG91Y2hFbmRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ3aGVlbFwiLFxuICAgICAgICB3aGVlbEhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjY3JlYXRlX3BhY2thZ2VfYnV0dG9uXCIpLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2xpY2tcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgICAgIGFzeW5jIGZ1bmN0aW9uIG1ha2VaaXAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGlzdEVudHJ5ID0gcGFja2FnZU1hcC5nZXRTYW1wbGVMaXN0RW50cnkoKVxuICAgICAgICAgICAgICAgIHNlbmRTYW1wbGVMaXN0RW50cnkobGlzdEVudHJ5KVxuXG4gICAgICAgICAgICAgICAgY29uc3QgemlwID0gbmV3IEpTWmlwKCk7XG4gICAgICAgICAgICAgICAgY29uc3QganBnWmlwID0gbmV3IEpTWmlwKClcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWJwWmlwID0gbmV3IEpTWmlwKClcblxuICAgICAgICAgICAgICAgIGlmIChzdGF0ZS5vcGVuX2ltYWdlX3NyY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIG9wZW4gTmljb2wgaW1hZ2VzIGFyZSBzZWxlY3RlZC5cIilcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLmNyb3NzX2ltYWdlX3NyY3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNyb3NzZWQgTmljb2wgaW1hZ2VzIGFyZSBzZWxlY3RlZC5cIilcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBUaHVtYm5haWxzXG4gICAgICAgICAgICAgICAgemlwLmZpbGUoXCJvMS5qcGdcIiwgY29tcHJlc3NJbWFnZVNyYyhzdGF0ZS5vcGVuX2ltYWdlX3NyY3NbMF0sIFwianBlZ1wiLCBzdGF0ZS5kZXNpcmVkVGh1bWJuYWlsSW1hZ2VTaXplKSlcbiAgICAgICAgICAgICAgICB6aXAuZmlsZShcImMxLmpwZ1wiLCBjb21wcmVzc0ltYWdlU3JjKHN0YXRlLmNyb3NzX2ltYWdlX3NyY3NbMF0sIFwianBlZ1wiLCBzdGF0ZS5kZXNpcmVkVGh1bWJuYWlsSW1hZ2VTaXplKSlcblxuICAgICAgICAgICAgICAgIC8vIEltYWdlIHNldHNcbiAgICAgICAgICAgICAgICBwYWNrYWdlTWFwLnNldEltYWdlRm9ybWF0cyhbXCJ3ZWJwXCIsIFwianBnXCJdKVxuICAgICAgICAgICAgICAgIHN0YXRlLm9wZW5faW1hZ2Vfc3Jjcy5mb3JFYWNoKChzcmMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2VicFppcC5maWxlKGBvJHtpICsgMX0ud2VicGAsIGNvbXByZXNzSW1hZ2VTcmMoc3JjLCBcIndlYnBcIiwgc3RhdGUuZGVzaXJlZEltYWdlU2l6ZSkpXG4gICAgICAgICAgICAgICAgICAgIGpwZ1ppcC5maWxlKGBvJHtpICsgMX0uanBnYCwgY29tcHJlc3NJbWFnZVNyYyhzcmMsIFwianBlZ1wiLCBzdGF0ZS5kZXNpcmVkSW1hZ2VTaXplKSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIHN0YXRlLmNyb3NzX2ltYWdlX3NyY3MuZm9yRWFjaCgoc3JjLCBpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHdlYnBaaXAuZmlsZShgYyR7aSArIDF9LndlYnBgLCBjb21wcmVzc0ltYWdlU3JjKHNyYywgXCJ3ZWJwXCIsIHN0YXRlLmRlc2lyZWRJbWFnZVNpemUpKVxuICAgICAgICAgICAgICAgICAgICBqcGdaaXAuZmlsZShgYyR7aSArIDF9LmpwZ2AsIGNvbXByZXNzSW1hZ2VTcmMoc3JjLCBcImpwZWdcIiwgc3RhdGUuZGVzaXJlZEltYWdlU2l6ZSkpXG4gICAgICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgICAgIGNvbnN0IG1ldGEgPSBuZXcgQmxvYihbSlNPTi5zdHJpbmdpZnkocGFja2FnZU1hcC50b0pTT04oKSwgbnVsbCwgMildLCB7IFwidHlwZVwiOiBcInRleHQvanNvblwiIH0pO1xuICAgICAgICAgICAgICAgIHppcC5maWxlKFwibWFuaWZlc3QuanNvblwiLCBtZXRhKVxuICAgICAgICAgICAgICAgIHppcC5maWxlKFwid2VicC56aXBcIiwgYXdhaXQgd2VicFppcC5nZW5lcmF0ZUFzeW5jKHsgdHlwZTogXCJibG9iXCIgfSkpXG4gICAgICAgICAgICAgICAgemlwLmZpbGUoXCJqcGcuemlwXCIsIGF3YWl0IGpwZ1ppcC5nZW5lcmF0ZUFzeW5jKHsgdHlwZTogXCJibG9iXCIgfSkpXG4gICAgICAgICAgICAgICAgY29uc3QgemlwQ29udGVudCA9IGF3YWl0IHppcC5nZW5lcmF0ZUFzeW5jKHsgdHlwZTogXCJibG9iXCIgfSlcblxuICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3dvcmtpbmdfYW5jaG9yXCIpXG4gICAgICAgICAgICAgICAgYS5kb3dubG9hZCA9IGAke3BhY2thZ2VNYXAuZ2V0UGFja2FnZUlEKCl9LnppcGBcbiAgICAgICAgICAgICAgICBhLmhyZWYgPSB3aW5kb3cuVVJMLmNyZWF0ZU9iamVjdFVSTCh6aXBDb250ZW50KVxuICAgICAgICAgICAgICAgIGEuY2xpY2soKVxuXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYWtlWmlwKClcbiAgICAgICAgICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhpZGVFcnJvck1lc3NhZ2UoXCIjZXJyb3JfbWFrZV9wYWNrYWdlXCIpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHNob3dFcnJvck1lc3NhZ2UoXCIjZXJyb3JfbWFrZV9wYWNrYWdlXCIsIGUpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB1cGRhdGVWaWV3ZXJHZW9tZXRyeShzdGF0ZSlcbn0pKHVwbG9hZF9zdGF0ZSlcbiJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9OQTtBQUNBOzs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2RBO0FBQ0E7QUFDQTs7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDL0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///0\n')}]);