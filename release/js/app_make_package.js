!function(g){var I={};function n(t){if(I[t])return I[t].exports;var e=I[t]={i:t,l:!1,exports:{}};return g[t].call(e.exports,e,e.exports,n),e.l=!0,e.exports}n.m=g,n.c=I,n.d=function(g,I,t){n.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:t})},n.r=function(g){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(g,"__esModule",{value:!0})},n.t=function(g,I){if(1&I&&(g=n(g)),8&I)return g;if(4&I&&"object"==typeof g&&g&&g.__esModule)return g;var t=Object.create(null);if(n.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:g}),2&I&&"string"!=typeof g)for(var e in g)n.d(t,e,function(I){return g[I]}.bind(null,e));return t},n.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return n.d(I,"a",I),I},n.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},n.p="",n(n.s=0)}([function(module,__webpack_exports__,__webpack_require__){"use strict";eval('// ESM COMPAT FLAG\n__webpack_require__.r(__webpack_exports__);\n\n// CONCATENATED MODULE: ./src/js/getMaxViewerSize.js\nfunction getMaxViewerSize() {\n    const topBarSpaceHeight = 200 // px\n    const width = window.innerWidth\n    const height = window.innerHeight - topBarSpaceHeight\n    return width < height ? width : height\n}\n\n// CONCATENATED MODULE: ./src/js/remote_repo/static/filter_by_category.js\nclass SampleFilter {\n    constructor(queries = []) {\n        this.queries = new Set(queries.map(this.listToQuery))\n    }\n\n    add(query) {\n        this.queries.add(this.listToQuery(query))\n    }\n\n    addMany(queries) {\n        queries.forEach(v => {\n            this.queries.add(this.listToQuery(v))\n        })\n    }\n\n    remove(value) {\n        this.queries.delete(this.listToQuery(value))\n    }\n\n    removeMany(values) {\n        values.forEach(v => {\n            this.queries.delete(this.listToQuery(v))\n        })\n    }\n\n    reset(queries) {\n        this.queries = new Set(queries.map(this.listToQuery))\n    }\n\n    list() {\n        return this.queries\n    }\n\n    listToQuery(path) {\n        return path.reduce((acc, e) => {\n            if (acc === "") return e\n            return acc + "::" + e\n        }, "")\n    }\n\n    filter(sampleList) {\n        if (this.queries.size === 0) return sampleList\n\n        const queries = [...this.queries].map(v => v.split("::"))\n        return sampleList.filter(sample => {\n            if (!sample.hasOwnProperty("category")) return false\n            const superset = new Set(sample.category)\n            for (let query of queries) {\n                if (isSubset(query, superset)) return true\n            }\n        })\n    }\n}\n\n\n/**\n *\n * @param {Set} set\n * @param {Set} superset\n */\nfunction isSubset(set, superset) {\n    if (set.size == 0) {\n        return true\n    }\n    for (let elem of set) {\n        if (!superset.has(elem)) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// CONCATENATED MODULE: ./src/js/local_storage/NativeLocalStorage.js\nclass NativeLocalStorage {\n    constructor() {\n        this.db = window.localStorage\n    }\n\n    put(key, value) {\n        this.db.setItem(key, value);\n    }\n\n    get(key) {\n        const value = this.db.getItem(key)\n        return (value == null)\n            ? undefined\n            : value\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/local_storage/DummyLocalStorage.js\nclass DummyLocalStorage {\n    constructor() {\n        this.db = {}\n    }\n\n    put(key, value) {\n        this.db[key] = value;\n    }\n\n    get(key) {\n        return (this.db.hasOwnProperty("key"))\n            ? this.db[key]\n            : undefined\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/config/config.js\n/**\n * TODO split these config as different objects\n *\n * - Package list endpoint\n * - Package CDN endpoint\n * - Cache DB version name\n * - Cache DB table name\n */\n\n\n\nclass Config {\n    constructor() {\n        this.endpoint = compileEnv == "production"\n            ? "https://d3uqzv7l1ih05d.cloudfront.net/" // Endpoint should be URL or\n            : "../../example_image_package_root/"      // relative path from deployed index.html\n\n        this.indexedDBName = "db_v3"\n        this.storageName = "files"\n    }\n\n    getSampleListURL() {\n        return this.endpoint + "rock_list.json"\n    }\n\n    getSampleCategoryURL() {\n        return this.endpoint + "category.json"\n    }\n\n    getImageDataPath(packageName) {\n        return this.endpoint + "packages/" + packageName + "/"\n    }\n\n    getDBName() {\n        return this.indexedDBName;\n    }\n\n    getStorageName() {\n        return this.storageName\n    }\n}\n\n\nconst compileEnv = "production"\n\nconsole.info("config.js: compileEnv: ", compileEnv)\n\nconst staticSettings = new Config()\n\nconst VIEW_PADDING = 0 // px\n\nconst cacheStorage = window.localStorage\n    ? new NativeLocalStorage()\n    : new DummyLocalStorage()\n\n// CONCATENATED MODULE: ./src/js/state/ui_state.js\n\n\n\nfunction overrideLanguageByLocalStorage(systemLanguage) {\n    const langInLocalStorage = cacheStorage.get("language")\n    const lang = (langInLocalStorage !== undefined)\n        ? langInLocalStorage\n        : systemLanguage;\n    document.querySelector("option[value=" + lang + "]").selected = true\n    return lang\n}\n\nfunction getSystemLanguage() {\n    const code = (window.navigator.languages && window.navigator.languages[0]) ||\n        window.navigator.language ||\n        window.navigator.userLanguage ||\n        window.navigator.browserLanguage;\n\n    const lang = code.match("ja") ? "ja" : "en";\n\n    return lang\n}\n\nconst uiState = {\n    "sampleFilter": new SampleFilter(),\n    "storedKeys": [],\n    "language": overrideLanguageByLocalStorage(getSystemLanguage()),\n}\n// CONCATENATED MODULE: ./src/js/state/viewer_state.js\n\n\nconst viewerState = {\n    "containorID": "",\n    "imageNumber": 1,\n    "canvasWidth": getMaxViewerSize() <= 500\n        ? getMaxViewerSize()\n        : 500,\n    "canvasHeight": getMaxViewerSize() <= 500\n        ? getMaxViewerSize()\n        : 500,\n    "imageRadius": 0,\n    "open_image_srcs": [],\n    "open_images": [],\n    "cross_image_srcs": [],\n    "cross_images": [],\n    "rotate": 0,\n    "rotate_axis_translate": [],\n    "isClockwise": true,\n    "isCrossNicol": false,\n    "drawHairLine": true,\n    "canRotate": true,\n}\n// CONCATENATED MODULE: ./src/js/state/initState.js\n\n\n\n\nfunction initState() {\n    return {\n        "isMousedown": false,\n        "drag_start": [0, 0],\n        "drag_end": [0, 0],\n        "uiState": uiState,\n        ...viewerState // TODO viewerState should be independent\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/package_manifest.js\nclass PackageManifest {\n    constructor() {\n        this.packageID = null\n        this.listName = {}\n        this.location = {}\n        this.owner = {}\n        this.rockType = {}\n        this.description = {}\n        this.geoSystem = ""\n        this.geoPosition = [null, null]\n        this.rotateCenter = [undefined, undefined]\n        this.rotateDirection = "clockwise"\n        this.imageSize = { "width": 0, "height": 0 }\n    }\n\n    toJSON() {\n        return {\n            "package-id": this.getPackageID(),\n            "list-name": this.getListName(),\n            "image_width": this.getImageWidth(),\n            "image_height": this.getImageHeight(),\n            "rotate_center": this.getRotateCenter(),\n            "cycle_rotate_degree": this.getRotateSectionDegree(),\n            "rotate_clockwise": this.isRotateClockwise(),\n            "rotate_by_degree": this.getEachRotateDegree(),\n            "location": this.getSampleLocation(),\n            "owner": this.getOwner(),\n            "rock_type": this.getRockType(),\n            "description": this.getDescription(),\n            "scale-unit": this.getScaleUnit(),\n            "scale-pixel": this.getScalePixel(),\n            "magnify": this.getMagnify(),\n            "sample_label": this.getSampleLabel(),\n            "geographic-coordinate": this.getGeoLocation(),\n            "image_formats": this.getImageFormats()\n        }\n    }\n\n    getSampleListEntry() {\n        return {\n            "package-name": this.getPackageID(),\n            "list-name": this.getListName()\n        }\n    }\n\n    setPackageID(id) {\n        this.packageID = id\n        return this\n    }\n\n    getPackageID() {\n        return this.packageID || ""\n    }\n\n    setListName(lang, s) {\n        this.listName[lang] = s;\n        return this;\n    }\n\n    getListName() {\n        return this.listName;\n    }\n\n    setSampleLocation(lang, desc) {\n        this.location[lang] = desc;\n        return this\n    }\n\n    getSampleLocation() {\n        return this.location;\n    }\n\n    setLocation(system, v1, v2) {\n        this.geoSystem = system,\n            this.geoPosition = [v1, v2]\n        return this\n    }\n\n    getGeoLocation() {\n        return {\n            "system": this.geoSystem,\n            "position": {\n                "latitude": this.geoPosition[0],\n                "longitude": this.geoPosition[1]\n            }\n        }\n    }\n\n    setMagnify(magnificationValue) {\n        this.magnify = magnificationValue\n        return this\n    }\n\n    getMagnify() {\n        return this.magnify\n    }\n\n    setScaleUnit(scaleUnit) {\n        this.scaleUnit = scaleUnit;\n        return this\n    }\n\n    getScaleUnit() {\n        return this.scaleUnit\n    }\n\n    setScalePixel(scaleLengthAsPixel) {\n        this.scalePixel = scaleLengthAsPixel\n        return this\n    }\n\n    getScalePixel() {\n        return this.scalePixel\n    }\n\n    setSampleLabel(s) {\n        this.sampleLabel = s\n    }\n\n    getSampleLabel() {\n        return this.sampleLabel || ""\n    }\n\n    setImageSize(img) {\n        this.imageSize = {\n            "width": img.width,\n            "height": img.height\n        }\n        return this\n    }\n\n    getImageWidth() {\n        return this.imageSize.width\n    }\n\n    getImageHeight() {\n        return this.imageSize.height\n    }\n\n    setRotateCenter(fromLeft, fromTop) {\n        this.rotateCenter = [fromLeft, fromTop]\n        return this\n    }\n\n    getRotateCenter() {\n        return [\n            this.rotateCenter[0] === undefined\n                ? this.getImageWidth() * 0.5\n                : this.rotateCenter[0],\n            this.rotateCenter[1] === undefined\n                ? this.getImageHeight() * 0.5\n                : this.rotateCenter[1]\n        ]\n    }\n\n    setImagesNumber(value) {\n        this.imagesNumber = value\n        return this\n    }\n\n    getImagesNumber() {\n        return this.imagesNumber\n    }\n\n    getRotateSectionDegree() {\n        return this.getEachRotateDegree() * (this.getImagesNumber() - 1)\n    }\n\n    setRotateDirection(direction) {\n        this.rotateDirection = direction\n        return this\n    }\n\n    isRotateClockwise() {\n        return this.rotateDirection === "clockwise"\n    }\n\n    setEachRotateDegree(degree) {\n        this.eachRotateDegree = degree\n        return this\n    }\n\n    getEachRotateDegree() {\n        return this.eachRotateDegree\n    }\n\n    setRockType(lang, desc) {\n        this.rockType[lang] = desc\n        return this\n    }\n\n    getRockType() {\n        return this.rockType\n    }\n\n    setOwner(lang, desc) {\n        this.owner[lang] = desc\n        return this\n    }\n\n    getOwner() {\n        return this.owner\n    }\n\n    setDescription(lang, desc) {\n        this.description[lang] = desc\n        return this\n    }\n\n    getDescription() {\n        return this.description\n    }\n\n    setImageFormats(formats) {\n        formats.forEach(format => {\n            console.assert(["webp", "jpg", "jp2"].includes(format))\n        })\n        this.imageFormats = formats\n    }\n\n    getImageFormats() {\n        return this.imageFormats || []\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/viewer_canvas.js\nconst viewer = document.querySelector("#main-viewer")\nconst viewer_ctx = viewer.getContext("2d")\n\n// CONCATENATED MODULE: ./src/js/updateViewerGeometry.js\n\n\n\nfunction updateViewerGeometry(state) {\n    return new Promise((res, rej) => {\n        const padding = 20 // px\n        state.canvasWidth = getMaxViewerSize() - padding\n        state.canvasHeight = getMaxViewerSize() - padding\n\n        viewer.width = state.canvasWidth\n        viewer.height = state.canvasHeight\n        viewer_ctx.translate(state.canvasWidth * 0.5, state.canvasHeight * 0.5)\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/sanitizeID.js\nfunction sanitizeID(id) {\n    return id.replace(/\\//g, "_").replace(/\\./g, "")\n}\n\n// CONCATENATED MODULE: ./src/js/rotation_degree_handlers.js\nconst stepBy = unit => val => Math.floor(val / unit)\n\nconst cycleBy = unit => val => {\n    const cycle_count = Math.floor(val / unit)\n    return val < 0\n        ? val + unit\n        : (unit <= val)\n            ? val - unit * cycle_count\n            : val\n}\n\nconst rotation_degree_handlers_mirrorBy = (center) => val => val > center ? 2 * center - val : val\n\nconst isInverse = degree => (180 <= degree)\n\nconst rotateSign = (clockwise = true) => clockwise ? -1 : 1\n\n// CONCATENATED MODULE: ./src/js/updateStateByMeta.js\n\n\n\nfunction getRotationCenter(meta) {\n    return (meta.hasOwnProperty("rotate_center"))\n        ? {\n            "to_right": meta.rotate_center[0],\n            "to_bottom": meta.rotate_center[1]\n        }\n        : {\n            "to_right": meta.image_width * 0.5,\n            "to_bottom": meta.image_height * 0.5\n        }\n}\n\nfunction getImageRadius(meta) {\n    const shift = getRotationCenter(meta);\n    const image_center = {\n        "x": meta.image_width * 0.5,\n        "y": meta.image_height * 0.5\n    }\n    return Math.min(\n        image_center.x - Math.abs(image_center.x - shift.to_right),\n        image_center.y - Math.abs(image_center.y - shift.to_bottom)\n    )\n}\n\nfunction mapMetadata(meta) {\n    const rotate_degree_step = parseInt(meta.rotate_by_degree)\n\n    return {\n        isClockwise: meta.rotate_clockwise,\n        location: meta.location,\n        rockType: meta.rock_type,\n        owner: meta.owner,\n        description: meta.hasOwnProperty("discription")\n            ? meta.discription\n            : meta.hasOwnProperty("description")\n                ? meta.description\n                : {},\n        rotate_center: getRotationCenter(meta),\n        imageWidth: meta.image_width,\n        imageHeight: meta.image_height,\n        imageRadius: getImageRadius(meta),\n        imageRadiusOriginal: getImageRadius(meta),\n        scaleWidth: meta.hasOwnProperty("scale-pixel")\n            ? parseInt(meta["scale-pixel"])\n            : false,\n        scaleText: meta.hasOwnProperty("scale-unit")\n            ? meta["scale-unit"]\n            : false,\n        rotate_degree_step: rotate_degree_step\n    }\n}\n\nfunction updateStateByMeta(state) {\n    return (containorID, meta) => new Promise((res, rej) => {\n\n        state.containorID = sanitizeID(containorID);\n\n        const rotate_degree_step = parseInt(meta.rotate_by_degree)\n        const cycle_degree = meta.hasOwnProperty("cycle_rotate_degree")\n            ? parseInt(meta.cycle_rotate_degree)\n            : 90;\n        const image_number = cycle_degree / rotate_degree_step + 1\n        const mirror_at = (image_number - 1)\n        const total_step = (image_number - 1) * 2\n\n        state.image_number = image_number\n        state.getImageNumber = cycle_degree > 0\n            ? degree => cycleBy(image_number - 1)(\n                stepBy(rotate_degree_step)(state.isClockwise ? 360 - degree : degree)\n            )\n            : degree => mirrorBy(mirror_at)(\n                cycleBy(total_step)(\n                    stepBy(rotate_degree_step)(degree)\n                )\n            )\n\n        state.getAlpha = degree => {\n            const nth = cycleBy(total_step * 2)(\n                stepBy(rotate_degree_step)(degree)\n            )\n            return 1 - (degree - rotate_degree_step * nth) / rotate_degree_step\n        }\n\n        state.open_images = []\n        state.cross_images = []\n\n        state.rotate = 0;\n\n        state = Object.assign(state, mapMetadata(meta))\n\n        res(state)\n    })\n}\n\n// CONCATENATED MODULE: ./src/js/viewer_handlers.js\n\n\nconst hideWelcomeBoard = state => {\n    const board = document.querySelector("#welcome-card")\n    board.classList.add("inactive");\n    return state\n}\n\nconst showViewer = state => {\n    const card = document.querySelector("#viewer_wrapper")\n    card.classList.remove("inactive")\n    return state\n}\n\nconst showNicolButton = state => {\n    const button = document.querySelector("#low-navigation")\n    button.classList.remove("inactive");\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/clipGeometryFromImageCenter.js\nfunction clipGeometoryFromImageCenter(state) {\n\n    return [\n        state.rotate_center.to_right - state.imageRadius,\n        state.rotate_center.to_bottom - state.imageRadius,\n        state.imageRadius * 2,\n        state.imageRadius * 2\n    ]\n}\n\n// CONCATENATED MODULE: ./src/js/draw_state_updators.js\n\n\n\n\n\nfunction clearView(state) {\n    viewer_ctx.clearRect(-state.canvasWidth * 0.5, -state.canvasHeight * 0.5, state.canvasWidth, state.canvasHeight)\n    return state\n}\n\nfunction blobToCanvas(state) {\n\n    const image_srcs = state.isCrossNicol\n        ? state.cross_images\n        : state.open_images\n\n    // view window circle\n\n    viewer_ctx.save()\n    viewer_ctx.beginPath()\n    viewer_ctx.arc(0, 0, state.canvasWidth / 2 - VIEW_PADDING, 0, Math.PI * 2, false)\n    viewer_ctx.clip()\n\n    // Draw a image\n    const alpha = state.getAlpha(state.rotate)\n\n    viewer_ctx.rotate(\n        rotateSign(state.isClockwise) * (state.rotate + state.getImageNumber(state.rotate) * state.rotate_degree_step) / 180 * Math.PI\n    )\n\n    viewer_ctx.globalAlpha = 1\n    const image1 = image_srcs[state.getImageNumber(state.rotate)]\n\n    try {\n        viewer_ctx.drawImage(\n            image1,\n            ...clipGeometoryFromImageCenter(state),\n            -state.canvasWidth / 2,\n            -state.canvasHeight / 2,\n            state.canvasWidth,\n            state.canvasHeight\n        );\n    } catch (e) {\n\n    }\n\n    viewer_ctx.restore()\n\n    // Draw next image\n    viewer_ctx.save()\n    viewer_ctx.beginPath()\n    viewer_ctx.arc(0, 0, state.canvasWidth / 2 - VIEW_PADDING, 0, Math.PI * 2, false)\n    viewer_ctx.clip()\n\n    viewer_ctx.rotate(\n        rotateSign(state.isClockwise) * (state.rotate + state.getImageNumber(state.rotate + state.rotate_degree_step) * state.rotate_degree_step) / 180 * Math.PI\n    )\n\n    viewer_ctx.globalAlpha = 1 - alpha\n    const image2 = image_srcs[state.getImageNumber(state.rotate + state.rotate_degree_step)]\n    try {\n        viewer_ctx.drawImage(\n            image2,\n            ...clipGeometoryFromImageCenter(state),\n            -state.canvasWidth / 2,\n            -state.canvasHeight / 2,\n            state.canvasWidth,\n            state.canvasHeight)\n    } catch (e) {\n\n    }\n    viewer_ctx.restore()\n    return state\n}\n\nfunction drawHairLine(state) {\n    if (!state.drawHairLine) return\n    viewer_ctx.strokeStyle = state.isCrossNicol\n        ? "white"\n        : "black";\n    viewer_ctx.globalAlpha = 1\n    viewer_ctx.beginPath()\n    viewer_ctx.moveTo(0, -state.canvasHeight * 0.5 + VIEW_PADDING)\n    viewer_ctx.lineTo(0, state.canvasHeight * 0.5 - VIEW_PADDING)\n    viewer_ctx.moveTo(-state.canvasWidth * 0.5 + VIEW_PADDING, 0)\n    viewer_ctx.lineTo(state.canvasWidth * 0.5 - VIEW_PADDING, 0)\n    viewer_ctx.closePath()\n    viewer_ctx.stroke()\n    return state\n}\n\nconst scaleLength = (canvasWidth, imageWidth, scaleWidth) => canvasWidth * scaleWidth / imageWidth\n\nfunction drawScale(state) {\n    if (!state["scaleWidth"]) return;\n    let scalePixel = scaleLength(state.canvasWidth, state.imageRadius * 2, state.scaleWidth)\n    const canvasWidth = state.canvasWidth;\n    const scaleBar = document.querySelector("#scalebar")\n\n\n    let scaleNumber = state.scaleText.match(/(\\d+\\.?\\d*)/)[0] * 1\n    const scaleUnit = state.scaleText.match(/\\D*$/)[0]\n\n    while (scalePixel >= canvasWidth) {\n        scalePixel *= 0.5\n        scaleNumber *= 0.5\n    }\n    scaleBar.style.width = scalePixel + "px";\n    scaleBar.querySelector("div:first-child").innerHTML = `${scaleNumber} ${scaleUnit}`;\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/getCoordinateOnCanvas.js\nfunction getCoordinateOnCanvas(canvas) {\n    return (e, fingur = 0) => {\n        if (e instanceof MouseEvent) {\n            return (e instanceof WheelEvent)\n                ? [\n                    e.deltaX,\n                    e.deltaY\n                ]\n                : [\n                    e.pageX - canvas.offsetLeft,\n                    e.pageY - canvas.offsetTop\n                ]\n        } else if (e instanceof TouchEvent && e.touches.length > fingur) {\n            return [\n                e.touches[fingur].pageX - canvas.offsetLeft,\n                e.touches[fingur].pageY - canvas.offsetTop\n            ]\n        }\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/radiunBetween.js\nfunction radiunBetween(cx, cy) {\n    return (_x1, _y1, _x2, _y2) => {\n        const x1 = _x1 - cx\n        const x2 = _x2 - cx\n        const y1 = _y1 - cy\n        const y2 = _y2 - cy\n\n        const cos = (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))\n        return Math.sign(x1 * y2 - x2 * y1) * Math.acos(cos)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/coordinate_updators.js\n\n\n\n\n\nconst canvasCoordinate = getCoordinateOnCanvas(viewer)\n\n/**\n * Update start and end position\n * @param {*} state\n * @param {*} e\n */\nfunction updateCoordinate(state, e) {\n    state.drag_start = state.drag_end || undefined\n    state.drag_end = canvasCoordinate(e)\n\n    state.pinch_start = state.pinch_end || undefined\n    state.pinch_end = canvasCoordinate(e, 1)\n    return state\n}\n\n/**\n * Calculate small difference of rotation.\n * Update total rotation.\n *\n * @param {*} state\n * @param {*} e\n */\nfunction updateRotate(state, e) {\n    if (!state.canRotate) return;\n    if (state.drag_start === undefined) return\n    // delta rotate radius\n    const rotate_end = radiunBetween(\n        state.canvasWidth * 0.5,\n        state.canvasHeight * 0.5\n    )(...state.drag_end, ...state.drag_start)\n\n    state.rotate += rotate_end / Math.PI * 180\n    if (state.rotate >= 360) {\n        state.rotate -= 360\n    } else if (state.rotate < 0) {\n        state.rotate += 360\n    }\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/rotateImage.js\n\n\n\nfunction rotateImage(state, e) {\n    return () => {\n        updateCoordinate(state, e)\n        updateRotate(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/updateMagnify.js\n\n\nfunction updateMagnifyByPinch(state, e) {\n    if (state.drag_start === undefined) return\n    if (state.pinch_start === undefined) return\n\n    const x1 = [...state.drag_start]\n    const y1 = [...state.pinch_start]\n    const x2 = [...state.drag_end]\n    const y2 = [...state.pinch_end]\n\n    const expansion = Math.sqrt((x2[0] - y2[0]) ** 2 + (x2[1] - y2[1]) ** 2) / Math.sqrt((x1[0] - y1[0]) ** 2 + (x1[1] - y1[1]) ** 2)\n\n    const newRadius = (expansion > 2)\n        ? state.imageRadius\n        : state.imageRadius / expansion\n    state.imageRadius = (newRadius) > state.imageRadiusOriginal\n        ? state.imageRadiusOriginal\n        : (newRadius < 100)\n            ? 100\n            : newRadius\n    return state\n}\n\nfunction updateMagnifyByWheel(state, e) {\n    const scrolled = canvasCoordinate(e)[1]\n\n    const newRadius = state.imageRadius + scrolled\n    state.imageRadius = (newRadius) > state.imageRadiusOriginal\n        ? state.imageRadiusOriginal\n        : (newRadius < 100)\n            ? 100\n            : newRadius\n    return state\n}\n\n// CONCATENATED MODULE: ./src/js/pinchImage.js\n\n\n\n\nfunction pinchImage(state, e) {\n    return () => {\n        updateCoordinate(state, e)\n        updateMagnifyByPinch(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n        drawScale(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/touchEventHandlers.js\n\n\n\n\nconst touchStartHandler = state => e => {\n    state.isMousedown = true\n    state.drag_end = canvasCoordinate(e)\n    e.preventDefault();\n}\n\nconst touchMoveHandler = state => e => {\n    if (!state.isMousedown) return\n    if (e instanceof MouseEvent || e.touches.length === 1) {\n        e.preventDefault();\n        requestAnimationFrame(\n            rotateImage(state, e)\n        )\n    } else if (e.touches.length === 2) {\n        e.preventDefault()\n        requestAnimationFrame(\n            pinchImage(state, e)\n        )\n    }\n}\n\nconst touchEndHandler = state => e => {\n    state.isMousedown = false\n    state.drag_end = undefined\n    state.pinch_end = undefined\n    e.preventDefault()\n}\n\n// CONCATENATED MODULE: ./src/js/wheelImage.js\n\n\n\nfunction wheelImage(state, e) {\n    return () => {\n        updateMagnifyByWheel(state, e)\n        blobToCanvas(state)\n        drawHairLine(state)\n        drawScale(state)\n    }\n}\n\n// CONCATENATED MODULE: ./src/js/wheelEventHandler.js\n\n\nconst wheelHandler = state => e => {\n    e.preventDefault();\n    requestAnimationFrame(\n        wheelImage(state, e)\n    )\n}\n\n// CONCATENATED MODULE: ./src/js/index_make_package.js\n\n\n\n\n\n\n\n\n\n\n\nconst packageMap = new PackageManifest();\nconst upload_state = Object.assign(\n    initState(),\n    {\n        "loadImages": [false, true],\n        "autoRotate": false,\n        "viewMode": "validation",\n        "language": "ja",\n        "desiredImageSize": 150,\n        "desiredThumbnailImageSize": 100,\n    }\n)\n\nfunction bothImagesLoaded(flags) {\n    return flags.reduce((acc, e) => acc && e, true)\n}\n\nfunction fileSelectHander(e) {\n    function read(file) {\n        return new Promise((res, rej) => {\n            const reader = new FileReader()\n            reader.readAsDataURL(file)\n            reader.onloadend = function () {\n                res(reader.result)\n            };\n        })\n    }\n\n    return new Promise((res, rej) => {\n        const files = e.target.files;\n        Promise.all(\n            Array.from(files)\n                .map(file => read(file))\n        ).then(res)\n    })\n}\n\nfunction readImageSize(state) {\n    packageMap.setImageSize(state.open_images[0])\n    return state\n}\n\nfunction readImagesNumber(state) {\n    packageMap.setImagesNumber(state.open_images.length)\n    return state\n}\n\nasync function showImages(state) {\n    readImageSize(state)\n    readImagesNumber(state)\n    const new_state = await updateStateByMeta(state, "upload")(packageMap.packageID, packageMap.toJSON())\n\n    new_state.open_images = await Promise.all(state.open_image_srcs.map(loadImageFromSrc))\n    new_state.cross_images = await Promise.all(state.cross_image_srcs.map(loadImageFromSrc))\n\n    return updateView(new_state)\n        .then(showViewer)\n        .then(showNicolButton)\n}\n\nfunction loadImageFromSrc(src) {\n    return new Promise((res, rej) => {\n\n        const img = new Image()\n\n        img.onload = _ => {\n            res(img)\n        }\n\n        img.src = src\n\n    })\n}\n\nfunction openImagesSelectHandler(state) {\n    return e => new Promise(async (res, rej) => {\n        state.open_image_srcs = await fileSelectHander(e)\n        state.loadImages[0] = true\n        state.open_images = await Promise.all(state.open_image_srcs.map(loadImageFromSrc))\n        await showImages(state)\n\n        res(state)\n    })\n}\n\nfunction crossImagesSelectHandler(state) {\n    return e => new Promise(async (res, rej) => {\n        state.cross_image_srcs = await fileSelectHander(e)\n        state.loadImages[1] = true\n        state.cross_images = await Promise.all(state.cross_image_srcs.map(loadImageFromSrc))\n        await showImages(state)\n\n        res(state)\n    })\n}\n\nasync function updateView(state) {\n    clearView(state)\n    blobToCanvas(state)\n    drawHairLine(state)\n    drawScale(state)\n    return state\n}\n\n\nfunction activateDom(selector) {\n    Array.from(document.querySelectorAll(selector))\n        .forEach(dom => {\n            dom.classList.remove("inactive")\n        })\n}\n\n\nfunction base64ToBlob(base64, mime) {\n    var binary = atob(base64);\n    var buffer = new Uint8Array(binary.length)\n    for (var i = 0; i < binary.length; i++) {\n        buffer[i] = binary.charCodeAt(i);\n    }\n    return new Blob([buffer.buffer], {\n        type: mime\n    });\n}\n\nfunction compressImageSrc(src, format, desiredKByte = 150) {\n    console.assert(["jpeg", "webp"].includes(format))\n\n    const image = new Image()\n    image.src = src\n    const w = image.width\n    const h = image.height\n    const cvs = document.querySelector("#working_canvas")\n    cvs.width = w\n    cvs.height = h\n    const ctx = cvs.getContext("2d")\n    ctx.drawImage(image, 0, 0, w, h)\n\n    const originalBinary = cvs.toDataURL(`image/${format}`); //画質落とさずバイナリ化\n    const mime = originalBinary.match(/(:)([a-z\\/]+)(;)/)[2]\n\n    const originalBlob = base64ToBlob(originalBinary.split(",")[1], mime);\n\n    if (desiredKByte * 1e3 < originalBlob["size"]) {\n        const capacityRatio = desiredKByte * 1e3 / originalBlob["size"];\n        const processingBinary = cvs.toDataURL(`image/${format}`, capacityRatio); //画質落としてバイナリ化\n        return base64ToBlob(processingBinary.split(",")[1], mime);\n    } else {\n        return originalBlob\n    }\n}\n\nfunction showErrorMessage(domId, message) {\n    const messageDom = document.querySelector(domId)\n    messageDom.innerHTML = message\n    messageDom.classList.remove("inactive")\n}\n\nfunction hideErrorMessage(domId) {\n    const messageDom = document.querySelector(domId)\n    messageDom.classList.add("inactive")\n}\n\n\nfunction sendSampleListEntry(json_obj) {\n    if (json_obj["package-name"].match(new RegExp("^[0-9a-zA-Z_-]+$")) === null) {\n        throw new Error("Package ID should contain only number, alphabet, _, and -.")\n    }\n    if (Object.keys(json_obj["list-name"]).length === 0) {\n        throw new Error("Sample title is not set.")\n    }\n    document.querySelector("#dev_sample_list_entry").innerHTML = JSON.stringify(json_obj, null, 2)\n};\n\nfunction initializeOrUpdateInput(inputDom, value) {\n    if (!inputDom.value) {\n        inputDom.value = value\n    }\n}\n\nfunction showPackageSize(state) {\n    // Sum open and cross images (contains thumbnail)\n    const imagesSize = (state.open_image_srcs.length * state.desiredImageSize + state.desiredThumbnailImageSize) * 2\n    document.querySelector("#message_package_size").innerHTML = imagesSize\n}\n\n(function (state) {\n    document.querySelector("#input_package_id").addEventListener(\n        "change",\n        e => {\n            packageMap.setPackageID(e.target.value)\n        },\n        false\n    )\n\n    document.querySelector("#input_desired_image_size").addEventListener(\n        "change",\n        e => {\n            state.desiredImageSize = parseFloat(e.target.value)\n            showPackageSize(state)\n        },\n        false\n    )\n\n    document.querySelector("#input_desired_thumbnail_image_size").addEventListener(\n        "change",\n        e => {\n            state.desiredThumbnailImageSize = parseFloat(e.target.value)\n            showPackageSize(state)\n        },\n        false\n    )\n\n    const centerToRight = document.querySelector("#rotate_center_from_left")\n    centerToRight.addEventListener(\n        "change",\n        e => {\n            state.rotate_center.to_right = parseFloat(centerToRight.value)\n            updateView(state)\n        },\n        false\n    )\n    const centerToBottom = document.querySelector("#rotate_center_from_top")\n    centerToBottom.addEventListener(\n        "change",\n        e => {\n            state.rotate_center.to_bottom = parseFloat(centerToBottom.value)\n            updateView(state)\n        },\n        false\n    )\n\n    document.querySelector("#open_nicol_images").addEventListener(\n        "change",\n        e => {\n            openImagesSelectHandler(state)(e).then(state => {\n                initializeOrUpdateInput(centerToRight, state.open_images[0].width / 2)\n                initializeOrUpdateInput(centerToBottom, state.open_images[0].height / 2)\n                showPackageSize(state)\n            })\n        },\n        false\n    )\n\n    document.querySelector("#cross_nicol_images").addEventListener(\n        "change",\n        e => {\n            crossImagesSelectHandler(state)(e).then(state => {\n                initializeOrUpdateInput(centerToRight, state.cross_images[0].width / 2)\n                initializeOrUpdateInput(centerToBottom, state.cross_images[0].height / 2)\n                showPackageSize(state)\n            })\n        },\n        false\n    )\n\n    const rotateDirectionSelector = document.querySelector("#select_rotate_direction")\n    rotateDirectionSelector.addEventListener(\n        "change",\n        e => {\n            const direction = e.target.options[e.target.selectedIndex].value\n            packageMap.setRotateDirection(direction)\n        },\n        false\n    )\n\n    const inputRotationInterval = document.querySelector("#input_rotation_interval")\n    inputRotationInterval.addEventListener(\n        "change",\n        e => {\n            packageMap.setEachRotateDegree(inputRotationInterval.value)\n            activateDom("#select_image_wrapper")\n        },\n        false\n    )\n\n    const inputScaleUnit = document.querySelector("#input_scale_unit")\n    inputScaleUnit.addEventListener(\n        "change",\n        e => {\n            packageMap.setScaleUnit(inputScaleUnit.value)\n        },\n        false\n    )\n\n    const inputScaleLength = document.querySelector("#input_scale_length")\n    inputScaleLength.addEventListener(\n        "change",\n        e => {\n            packageMap.setScalePixel(inputScaleLength.value)\n        },\n        false\n    )\n\n    const inputMagnification = document.querySelector("#input_magnification")\n    inputMagnification.addEventListener(\n        "change",\n        e => {\n            packageMap.setMagnify(e.target.value)\n        },\n        false\n    )\n\n    const inputSampleLabel = document.querySelector("#input_sample_label")\n    inputSampleLabel.addEventListener(\n        "change",\n        e => {\n            packageMap.setSampleLabel(e.target.value)\n        },\n        false\n    )\n\n    Array.from(document.querySelectorAll(".input_sample_location")).forEach(dom => {\n        dom.addEventListener(\n            "change",\n            e => {\n                packageMap.setSampleLocation(e.target.dataset.lang, e.target.value)\n            },\n            false\n        )\n    })\n\n    Array.from(document.querySelectorAll(".input_sample_type")).forEach(dom => {\n        dom.addEventListener(\n            "change",\n            e => {\n                packageMap.setRockType(e.target.dataset.lang, e.target.value)\n            },\n            false\n        )\n    })\n\n    Array.from(document.querySelectorAll(".input_description")).forEach(dom => {\n        dom.addEventListener(\n            "change",\n            e => {\n                packageMap.setDescription(e.target.dataset.lang, e.target.value)\n            },\n            false\n        )\n    })\n\n    Array.from(document.querySelectorAll(".input_sample_title"))\n        .forEach(dom => {\n            dom.addEventListener(\n                "change",\n                e => {\n                    packageMap.setListName(e.target.dataset.lang, e.target.value)\n\n                }\n            )\n        })\n\n    Array.from(document.querySelectorAll(".input_owner")).forEach(dom => {\n        dom.addEventListener(\n            "change",\n            e => {\n                packageMap.setOwner(e.target.dataset.lang, e.target.value)\n            },\n            false\n        )\n    })\n\n    const toggleNicolButton = document.querySelector("#change_nicol")\n    const toggleNicolLabel = document.querySelector("#change_nicol + label")\n\n    const toggleNicolHandler = state => new Promise((res, rej) => {\n\n        toggleNicolButton.checked = state.isCrossNicol\n        state.isCrossNicol = !state.isCrossNicol;\n\n        res(state)\n    })\n\n    toggleNicolButton.addEventListener(\n        "click",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n    toggleNicolLabel.addEventListener(\n        "touch",\n        e => { e.preventDefault() },\n        false\n    )\n\n    toggleNicolButton.addEventListener(\n        "touch",\n        e => { e.preventDefault() },\n        false\n    )\n\n\n    toggleNicolLabel.addEventListener(\n        "mouseup",\n        e => toggleNicolHandler(state)\n            .then(updateView),\n        false\n    )\n\n    toggleNicolLabel.addEventListener(\n        "touchend",\n        e => toggleNicolHandler(state)\n            .then(updateView)\n            .then(_ => {\n                if (e.cancelable) {\n                    e.preventDefault();\n                }\n            }),\n        false\n    )\n\n    viewer.oncontextmenu = function (e) {\n        const position_on_canvas = canvasCoordinate(e)\n        const current_rotate_center = Object.values(state.rotate_center)\n        const shift = [\n            position_on_canvas[0] - state.canvasWidth * 0.5,\n            position_on_canvas[1] - state.canvasHeight * 0.5\n        ]\n\n        state.rotate_center.to_right += parseInt(shift[0] * state.imageRadius / state.canvasWidth * 2)\n        state.rotate_center.to_bottom += parseInt(shift[1] * state.imageRadius / state.canvasWidth * 2)\n\n        packageMap.setRotateCenter(\n            state.rotate_center.to_right,\n            state.rotate_center.to_bottom\n        )\n\n        centerToRight.value = state.rotate_center.to_right\n        centerToBottom.value = state.rotate_center.to_bottom\n\n        e.preventDefault()\n        updateView(state)\n        return false;\n    }\n\n    viewer.addEventListener(\n        "mousedown",\n        touchStartHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "dragstart",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "drag",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "dragend",\n        e => { e.preventDefault() },\n        false\n    )\n\n    viewer.addEventListener(\n        "touchstart",\n        touchStartHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "mousemove",\n        touchMoveHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "touchmove",\n        touchMoveHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "mouseup",\n        touchEndHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "touchend",\n        touchEndHandler(state),\n        false\n    )\n\n    viewer.addEventListener(\n        "wheel",\n        wheelHandler(state),\n        false\n    )\n\n    document.querySelector("#create_package_button").addEventListener(\n        "click",\n        e => {\n            e.preventDefault()\n            async function makeZip() {\n                const listEntry = packageMap.getSampleListEntry()\n                sendSampleListEntry(listEntry)\n\n                const zip = new JSZip();\n                const jpgZip = new JSZip()\n                const webpZip = new JSZip()\n\n                if (state.open_image_srcs.length === 0) {\n                    throw new Error("No open Nicol images are selected.")\n                }\n                if (state.cross_image_srcs.length === 0) {\n                    throw new Error("No crossed Nicol images are selected.")\n                }\n\n                // Thumbnails\n                zip.file("o1.jpg", compressImageSrc(state.open_image_srcs[0], "jpeg", state.desiredThumbnailImageSize))\n                zip.file("c1.jpg", compressImageSrc(state.cross_image_srcs[0], "jpeg", state.desiredThumbnailImageSize))\n\n                // Image sets\n                packageMap.setImageFormats(["webp", "jpg"])\n                state.open_image_srcs.forEach((src, i) => {\n                    webpZip.file(`o${i + 1}.webp`, compressImageSrc(src, "webp", state.desiredImageSize))\n                    jpgZip.file(`o${i + 1}.jpg`, compressImageSrc(src, "jpeg", state.desiredImageSize))\n                })\n                state.cross_image_srcs.forEach((src, i) => {\n                    webpZip.file(`c${i + 1}.webp`, compressImageSrc(src, "webp", state.desiredImageSize))\n                    jpgZip.file(`c${i + 1}.jpg`, compressImageSrc(src, "jpeg", state.desiredImageSize))\n                })\n\n                const meta = new Blob([JSON.stringify(packageMap.toJSON(), null, 2)], { "type": "text/json" });\n                zip.file("manifest.json", meta)\n                zip.file("webp.zip", await webpZip.generateAsync({ type: "blob" }))\n                zip.file("jpg.zip", await jpgZip.generateAsync({ type: "blob" }))\n                const zipContent = await zip.generateAsync({ type: "blob" })\n\n                const a = document.querySelector("#working_anchor")\n                a.download = `${packageMap.getPackageID()}.zip`\n                a.href = window.URL.createObjectURL(zipContent)\n                a.click()\n\n            }\n            makeZip()\n                .then(() => {\n                    hideErrorMessage("#error_make_package")\n                })\n                .catch(e => {\n                    showErrorMessage("#error_make_package", e)\n                })\n        },\n        false\n    )\n\n    updateViewerGeometry(state)\n})(upload_state)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiMC5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9qcy9nZXRNYXhWaWV3ZXJTaXplLmpzP2MwMzkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JlbW90ZV9yZXBvL3N0YXRpYy9maWx0ZXJfYnlfY2F0ZWdvcnkuanM/NjEzMCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9jYWxfc3RvcmFnZS9OYXRpdmVMb2NhbFN0b3JhZ2UuanM/YTlmYSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvbG9jYWxfc3RvcmFnZS9EdW1teUxvY2FsU3RvcmFnZS5qcz9kNjc0Iiwid2VicGFjazovLy8uL3NyYy9qcy9jb25maWcvY29uZmlnLmpzPzAwMmQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N0YXRlL3VpX3N0YXRlLmpzP2I2M2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3N0YXRlL3ZpZXdlcl9zdGF0ZS5qcz84YWJhIiwid2VicGFjazovLy8uL3NyYy9qcy9zdGF0ZS9pbml0U3RhdGUuanM/ZGI0ZCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcGFja2FnZV9tYW5pZmVzdC5qcz9hNGIwIiwid2VicGFjazovLy8uL3NyYy9qcy92aWV3ZXJfY2FudmFzLmpzPzAxZjIiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3VwZGF0ZVZpZXdlckdlb21ldHJ5LmpzPzM2Y2MiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3Nhbml0aXplSUQuanM/ZDc3ZiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcm90YXRpb25fZGVncmVlX2hhbmRsZXJzLmpzP2NhNmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3VwZGF0ZVN0YXRlQnlNZXRhLmpzPzNhMjkiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3ZpZXdlcl9oYW5kbGVycy5qcz80YTllIiwid2VicGFjazovLy8uL3NyYy9qcy9jbGlwR2VvbWV0cnlGcm9tSW1hZ2VDZW50ZXIuanM/ZmM5NSIsIndlYnBhY2s6Ly8vLi9zcmMvanMvZHJhd19zdGF0ZV91cGRhdG9ycy5qcz9jYmJkIiwid2VicGFjazovLy8uL3NyYy9qcy9nZXRDb29yZGluYXRlT25DYW52YXMuanM/NmM0NCIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcmFkaXVuQmV0d2Vlbi5qcz9hZjBmIiwid2VicGFjazovLy8uL3NyYy9qcy9jb29yZGluYXRlX3VwZGF0b3JzLmpzPzgzMjEiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3JvdGF0ZUltYWdlLmpzP2JmNTQiLCJ3ZWJwYWNrOi8vLy4vc3JjL2pzL3VwZGF0ZU1hZ25pZnkuanM/N2Q5NiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvcGluY2hJbWFnZS5qcz9mZGNiIiwid2VicGFjazovLy8uL3NyYy9qcy90b3VjaEV2ZW50SGFuZGxlcnMuanM/NDBkNiIsIndlYnBhY2s6Ly8vLi9zcmMvanMvd2hlZWxJbWFnZS5qcz8yNzk2Iiwid2VicGFjazovLy8uL3NyYy9qcy93aGVlbEV2ZW50SGFuZGxlci5qcz82MGYyIiwid2VicGFjazovLy8uL3NyYy9qcy9pbmRleF9tYWtlX3BhY2thZ2UuanM/ODhkOCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBnZXRNYXhWaWV3ZXJTaXplKCkge1xuICAgIGNvbnN0IHRvcEJhclNwYWNlSGVpZ2h0ID0gMjAwIC8vIHB4XG4gICAgY29uc3Qgd2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIGNvbnN0IGhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIHRvcEJhclNwYWNlSGVpZ2h0XG4gICAgcmV0dXJuIHdpZHRoIDwgaGVpZ2h0ID8gd2lkdGggOiBoZWlnaHRcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFNhbXBsZUZpbHRlciB7XG4gICAgY29uc3RydWN0b3IocXVlcmllcyA9IFtdKSB7XG4gICAgICAgIHRoaXMucXVlcmllcyA9IG5ldyBTZXQocXVlcmllcy5tYXAodGhpcy5saXN0VG9RdWVyeSkpXG4gICAgfVxuXG4gICAgYWRkKHF1ZXJ5KSB7XG4gICAgICAgIHRoaXMucXVlcmllcy5hZGQodGhpcy5saXN0VG9RdWVyeShxdWVyeSkpXG4gICAgfVxuXG4gICAgYWRkTWFueShxdWVyaWVzKSB7XG4gICAgICAgIHF1ZXJpZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5hZGQodGhpcy5saXN0VG9RdWVyeSh2KSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZW1vdmUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5xdWVyaWVzLmRlbGV0ZSh0aGlzLmxpc3RUb1F1ZXJ5KHZhbHVlKSlcbiAgICB9XG5cbiAgICByZW1vdmVNYW55KHZhbHVlcykge1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCh2ID0+IHtcbiAgICAgICAgICAgIHRoaXMucXVlcmllcy5kZWxldGUodGhpcy5saXN0VG9RdWVyeSh2KSlcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICByZXNldChxdWVyaWVzKSB7XG4gICAgICAgIHRoaXMucXVlcmllcyA9IG5ldyBTZXQocXVlcmllcy5tYXAodGhpcy5saXN0VG9RdWVyeSkpXG4gICAgfVxuXG4gICAgbGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucXVlcmllc1xuICAgIH1cblxuICAgIGxpc3RUb1F1ZXJ5KHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGgucmVkdWNlKChhY2MsIGUpID0+IHtcbiAgICAgICAgICAgIGlmIChhY2MgPT09IFwiXCIpIHJldHVybiBlXG4gICAgICAgICAgICByZXR1cm4gYWNjICsgXCI6OlwiICsgZVxuICAgICAgICB9LCBcIlwiKVxuICAgIH1cblxuICAgIGZpbHRlcihzYW1wbGVMaXN0KSB7XG4gICAgICAgIGlmICh0aGlzLnF1ZXJpZXMuc2l6ZSA9PT0gMCkgcmV0dXJuIHNhbXBsZUxpc3RcblxuICAgICAgICBjb25zdCBxdWVyaWVzID0gWy4uLnRoaXMucXVlcmllc10ubWFwKHYgPT4gdi5zcGxpdChcIjo6XCIpKVxuICAgICAgICByZXR1cm4gc2FtcGxlTGlzdC5maWx0ZXIoc2FtcGxlID0+IHtcbiAgICAgICAgICAgIGlmICghc2FtcGxlLmhhc093blByb3BlcnR5KFwiY2F0ZWdvcnlcIikpIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgY29uc3Qgc3VwZXJzZXQgPSBuZXcgU2V0KHNhbXBsZS5jYXRlZ29yeSlcbiAgICAgICAgICAgIGZvciAobGV0IHF1ZXJ5IG9mIHF1ZXJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNTdWJzZXQocXVlcnksIHN1cGVyc2V0KSkgcmV0dXJuIHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59XG5cblxuLyoqXG4gKlxuICogQHBhcmFtIHtTZXR9IHNldFxuICogQHBhcmFtIHtTZXR9IHN1cGVyc2V0XG4gKi9cbmZ1bmN0aW9uIGlzU3Vic2V0KHNldCwgc3VwZXJzZXQpIHtcbiAgICBpZiAoc2V0LnNpemUgPT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgICBmb3IgKGxldCBlbGVtIG9mIHNldCkge1xuICAgICAgICBpZiAoIXN1cGVyc2V0LmhhcyhlbGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgTmF0aXZlTG9jYWxTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5kYiA9IHdpbmRvdy5sb2NhbFN0b3JhZ2VcbiAgICB9XG5cbiAgICBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRiLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgZ2V0KGtleSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuZGIuZ2V0SXRlbShrZXkpXG4gICAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICA6IHZhbHVlXG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgY2xhc3MgRHVtbXlMb2NhbFN0b3JhZ2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmRiID0ge31cbiAgICB9XG5cbiAgICBwdXQoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLmRiW2tleV0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHJldHVybiAodGhpcy5kYi5oYXNPd25Qcm9wZXJ0eShcImtleVwiKSlcbiAgICAgICAgICAgID8gdGhpcy5kYltrZXldXG4gICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgIH1cbn1cbiIsIi8qKlxuICogVE9ETyBzcGxpdCB0aGVzZSBjb25maWcgYXMgZGlmZmVyZW50IG9iamVjdHNcbiAqXG4gKiAtIFBhY2thZ2UgbGlzdCBlbmRwb2ludFxuICogLSBQYWNrYWdlIENETiBlbmRwb2ludFxuICogLSBDYWNoZSBEQiB2ZXJzaW9uIG5hbWVcbiAqIC0gQ2FjaGUgREIgdGFibGUgbmFtZVxuICovXG5pbXBvcnQgTmF0aXZlTG9jYWxTdG9yYWdlIGZyb20gXCIuLi9sb2NhbF9zdG9yYWdlL05hdGl2ZUxvY2FsU3RvcmFnZS5qc1wiO1xuaW1wb3J0IER1bW15TG9jYWxTdG9yYWdlIGZyb20gXCIuLi9sb2NhbF9zdG9yYWdlL0R1bW15TG9jYWxTdG9yYWdlLmpzXCI7XG5cbmNsYXNzIENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZW5kcG9pbnQgPSBjb21waWxlRW52ID09IFwicHJvZHVjdGlvblwiXG4gICAgICAgICAgICA/IFwiaHR0cHM6Ly9kM3VxenY3bDFpaDA1ZC5jbG91ZGZyb250Lm5ldC9cIiAvLyBFbmRwb2ludCBzaG91bGQgYmUgVVJMIG9yXG4gICAgICAgICAgICA6IFwiLi4vLi4vZXhhbXBsZV9pbWFnZV9wYWNrYWdlX3Jvb3QvXCIgICAgICAvLyByZWxhdGl2ZSBwYXRoIGZyb20gZGVwbG95ZWQgaW5kZXguaHRtbFxuXG4gICAgICAgIHRoaXMuaW5kZXhlZERCTmFtZSA9IFwiZGJfdjNcIlxuICAgICAgICB0aGlzLnN0b3JhZ2VOYW1lID0gXCJmaWxlc1wiXG4gICAgfVxuXG4gICAgZ2V0U2FtcGxlTGlzdFVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kcG9pbnQgKyBcInJvY2tfbGlzdC5qc29uXCJcbiAgICB9XG5cbiAgICBnZXRTYW1wbGVDYXRlZ29yeVVSTCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kcG9pbnQgKyBcImNhdGVnb3J5Lmpzb25cIlxuICAgIH1cblxuICAgIGdldEltYWdlRGF0YVBhdGgocGFja2FnZU5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kcG9pbnQgKyBcInBhY2thZ2VzL1wiICsgcGFja2FnZU5hbWUgKyBcIi9cIlxuICAgIH1cblxuICAgIGdldERCTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW5kZXhlZERCTmFtZTtcbiAgICB9XG5cbiAgICBnZXRTdG9yYWdlTmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZU5hbWVcbiAgICB9XG59XG5cblxuY29uc3QgY29tcGlsZUVudiA9IHByb2Nlc3MuZW52Lk5PREVfRU5WXG5cbmNvbnNvbGUuaW5mbyhcImNvbmZpZy5qczogY29tcGlsZUVudjogXCIsIGNvbXBpbGVFbnYpXG5cbmV4cG9ydCBjb25zdCBzdGF0aWNTZXR0aW5ncyA9IG5ldyBDb25maWcoKVxuXG5leHBvcnQgY29uc3QgVklFV19QQURESU5HID0gMCAvLyBweFxuXG5leHBvcnQgY29uc3QgY2FjaGVTdG9yYWdlID0gd2luZG93LmxvY2FsU3RvcmFnZVxuICAgID8gbmV3IE5hdGl2ZUxvY2FsU3RvcmFnZSgpXG4gICAgOiBuZXcgRHVtbXlMb2NhbFN0b3JhZ2UoKVxuIiwiaW1wb3J0IFNhbXBsZUZpbHRlciBmcm9tIFwiLi4vcmVtb3RlX3JlcG8vc3RhdGljL2ZpbHRlcl9ieV9jYXRlZ29yeS5qc1wiXG5pbXBvcnQgeyBjYWNoZVN0b3JhZ2UgfSBmcm9tIFwiLi4vY29uZmlnL2NvbmZpZy5qc1wiXG5cbmZ1bmN0aW9uIG92ZXJyaWRlTGFuZ3VhZ2VCeUxvY2FsU3RvcmFnZShzeXN0ZW1MYW5ndWFnZSkge1xuICAgIGNvbnN0IGxhbmdJbkxvY2FsU3RvcmFnZSA9IGNhY2hlU3RvcmFnZS5nZXQoXCJsYW5ndWFnZVwiKVxuICAgIGNvbnN0IGxhbmcgPSAobGFuZ0luTG9jYWxTdG9yYWdlICE9PSB1bmRlZmluZWQpXG4gICAgICAgID8gbGFuZ0luTG9jYWxTdG9yYWdlXG4gICAgICAgIDogc3lzdGVtTGFuZ3VhZ2U7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIm9wdGlvblt2YWx1ZT1cIiArIGxhbmcgKyBcIl1cIikuc2VsZWN0ZWQgPSB0cnVlXG4gICAgcmV0dXJuIGxhbmdcbn1cblxuZnVuY3Rpb24gZ2V0U3lzdGVtTGFuZ3VhZ2UoKSB7XG4gICAgY29uc3QgY29kZSA9ICh3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlcyAmJiB3aW5kb3cubmF2aWdhdG9yLmxhbmd1YWdlc1swXSkgfHxcbiAgICAgICAgd2luZG93Lm5hdmlnYXRvci5sYW5ndWFnZSB8fFxuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLnVzZXJMYW5ndWFnZSB8fFxuICAgICAgICB3aW5kb3cubmF2aWdhdG9yLmJyb3dzZXJMYW5ndWFnZTtcblxuICAgIGNvbnN0IGxhbmcgPSBjb2RlLm1hdGNoKFwiamFcIikgPyBcImphXCIgOiBcImVuXCI7XG5cbiAgICByZXR1cm4gbGFuZ1xufVxuXG5leHBvcnQgY29uc3QgdWlTdGF0ZSA9IHtcbiAgICBcInNhbXBsZUZpbHRlclwiOiBuZXcgU2FtcGxlRmlsdGVyKCksXG4gICAgXCJzdG9yZWRLZXlzXCI6IFtdLFxuICAgIFwibGFuZ3VhZ2VcIjogb3ZlcnJpZGVMYW5ndWFnZUJ5TG9jYWxTdG9yYWdlKGdldFN5c3RlbUxhbmd1YWdlKCkpLFxufSIsImltcG9ydCBnZXRNYXhWaWV3ZXJTaXplIGZyb20gXCIuLi9nZXRNYXhWaWV3ZXJTaXplLmpzXCJcblxuZXhwb3J0IGNvbnN0IHZpZXdlclN0YXRlID0ge1xuICAgIFwiY29udGFpbm9ySURcIjogXCJcIixcbiAgICBcImltYWdlTnVtYmVyXCI6IDEsXG4gICAgXCJjYW52YXNXaWR0aFwiOiBnZXRNYXhWaWV3ZXJTaXplKCkgPD0gNTAwXG4gICAgICAgID8gZ2V0TWF4Vmlld2VyU2l6ZSgpXG4gICAgICAgIDogNTAwLFxuICAgIFwiY2FudmFzSGVpZ2h0XCI6IGdldE1heFZpZXdlclNpemUoKSA8PSA1MDBcbiAgICAgICAgPyBnZXRNYXhWaWV3ZXJTaXplKClcbiAgICAgICAgOiA1MDAsXG4gICAgXCJpbWFnZVJhZGl1c1wiOiAwLFxuICAgIFwib3Blbl9pbWFnZV9zcmNzXCI6IFtdLFxuICAgIFwib3Blbl9pbWFnZXNcIjogW10sXG4gICAgXCJjcm9zc19pbWFnZV9zcmNzXCI6IFtdLFxuICAgIFwiY3Jvc3NfaW1hZ2VzXCI6IFtdLFxuICAgIFwicm90YXRlXCI6IDAsXG4gICAgXCJyb3RhdGVfYXhpc190cmFuc2xhdGVcIjogW10sXG4gICAgXCJpc0Nsb2Nrd2lzZVwiOiB0cnVlLFxuICAgIFwiaXNDcm9zc05pY29sXCI6IGZhbHNlLFxuICAgIFwiZHJhd0hhaXJMaW5lXCI6IHRydWUsXG4gICAgXCJjYW5Sb3RhdGVcIjogdHJ1ZSxcbn0iLCJpbXBvcnQgZ2V0TWF4Vmlld2VyU2l6ZSBmcm9tIFwiLi4vZ2V0TWF4Vmlld2VyU2l6ZS5qc1wiXG5pbXBvcnQgeyB1aVN0YXRlIH0gZnJvbSBcIi4vdWlfc3RhdGUuanNcIlxuaW1wb3J0IHsgdmlld2VyU3RhdGUgfSBmcm9tIFwiLi92aWV3ZXJfc3RhdGUuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbml0U3RhdGUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgXCJpc01vdXNlZG93blwiOiBmYWxzZSxcbiAgICAgICAgXCJkcmFnX3N0YXJ0XCI6IFswLCAwXSxcbiAgICAgICAgXCJkcmFnX2VuZFwiOiBbMCwgMF0sXG4gICAgICAgIFwidWlTdGF0ZVwiOiB1aVN0YXRlLFxuICAgICAgICAuLi52aWV3ZXJTdGF0ZSAvLyBUT0RPIHZpZXdlclN0YXRlIHNob3VsZCBiZSBpbmRlcGVuZGVudFxuICAgIH1cbn1cbiIsImV4cG9ydCBkZWZhdWx0IGNsYXNzIFBhY2thZ2VNYW5pZmVzdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMucGFja2FnZUlEID0gbnVsbFxuICAgICAgICB0aGlzLmxpc3ROYW1lID0ge31cbiAgICAgICAgdGhpcy5sb2NhdGlvbiA9IHt9XG4gICAgICAgIHRoaXMub3duZXIgPSB7fVxuICAgICAgICB0aGlzLnJvY2tUeXBlID0ge31cbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IHt9XG4gICAgICAgIHRoaXMuZ2VvU3lzdGVtID0gXCJcIlxuICAgICAgICB0aGlzLmdlb1Bvc2l0aW9uID0gW251bGwsIG51bGxdXG4gICAgICAgIHRoaXMucm90YXRlQ2VudGVyID0gW3VuZGVmaW5lZCwgdW5kZWZpbmVkXVxuICAgICAgICB0aGlzLnJvdGF0ZURpcmVjdGlvbiA9IFwiY2xvY2t3aXNlXCJcbiAgICAgICAgdGhpcy5pbWFnZVNpemUgPSB7IFwid2lkdGhcIjogMCwgXCJoZWlnaHRcIjogMCB9XG4gICAgfVxuXG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJwYWNrYWdlLWlkXCI6IHRoaXMuZ2V0UGFja2FnZUlEKCksXG4gICAgICAgICAgICBcImxpc3QtbmFtZVwiOiB0aGlzLmdldExpc3ROYW1lKCksXG4gICAgICAgICAgICBcImltYWdlX3dpZHRoXCI6IHRoaXMuZ2V0SW1hZ2VXaWR0aCgpLFxuICAgICAgICAgICAgXCJpbWFnZV9oZWlnaHRcIjogdGhpcy5nZXRJbWFnZUhlaWdodCgpLFxuICAgICAgICAgICAgXCJyb3RhdGVfY2VudGVyXCI6IHRoaXMuZ2V0Um90YXRlQ2VudGVyKCksXG4gICAgICAgICAgICBcImN5Y2xlX3JvdGF0ZV9kZWdyZWVcIjogdGhpcy5nZXRSb3RhdGVTZWN0aW9uRGVncmVlKCksXG4gICAgICAgICAgICBcInJvdGF0ZV9jbG9ja3dpc2VcIjogdGhpcy5pc1JvdGF0ZUNsb2Nrd2lzZSgpLFxuICAgICAgICAgICAgXCJyb3RhdGVfYnlfZGVncmVlXCI6IHRoaXMuZ2V0RWFjaFJvdGF0ZURlZ3JlZSgpLFxuICAgICAgICAgICAgXCJsb2NhdGlvblwiOiB0aGlzLmdldFNhbXBsZUxvY2F0aW9uKCksXG4gICAgICAgICAgICBcIm93bmVyXCI6IHRoaXMuZ2V0T3duZXIoKSxcbiAgICAgICAgICAgIFwicm9ja190eXBlXCI6IHRoaXMuZ2V0Um9ja1R5cGUoKSxcbiAgICAgICAgICAgIFwiZGVzY3JpcHRpb25cIjogdGhpcy5nZXREZXNjcmlwdGlvbigpLFxuICAgICAgICAgICAgXCJzY2FsZS11bml0XCI6IHRoaXMuZ2V0U2NhbGVVbml0KCksXG4gICAgICAgICAgICBcInNjYWxlLXBpeGVsXCI6IHRoaXMuZ2V0U2NhbGVQaXhlbCgpLFxuICAgICAgICAgICAgXCJtYWduaWZ5XCI6IHRoaXMuZ2V0TWFnbmlmeSgpLFxuICAgICAgICAgICAgXCJzYW1wbGVfbGFiZWxcIjogdGhpcy5nZXRTYW1wbGVMYWJlbCgpLFxuICAgICAgICAgICAgXCJnZW9ncmFwaGljLWNvb3JkaW5hdGVcIjogdGhpcy5nZXRHZW9Mb2NhdGlvbigpLFxuICAgICAgICAgICAgXCJpbWFnZV9mb3JtYXRzXCI6IHRoaXMuZ2V0SW1hZ2VGb3JtYXRzKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldFNhbXBsZUxpc3RFbnRyeSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFwicGFja2FnZS1uYW1lXCI6IHRoaXMuZ2V0UGFja2FnZUlEKCksXG4gICAgICAgICAgICBcImxpc3QtbmFtZVwiOiB0aGlzLmdldExpc3ROYW1lKClcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFBhY2thZ2VJRChpZCkge1xuICAgICAgICB0aGlzLnBhY2thZ2VJRCA9IGlkXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0UGFja2FnZUlEKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYWNrYWdlSUQgfHwgXCJcIlxuICAgIH1cblxuICAgIHNldExpc3ROYW1lKGxhbmcsIHMpIHtcbiAgICAgICAgdGhpcy5saXN0TmFtZVtsYW5nXSA9IHM7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGdldExpc3ROYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5saXN0TmFtZTtcbiAgICB9XG5cbiAgICBzZXRTYW1wbGVMb2NhdGlvbihsYW5nLCBkZXNjKSB7XG4gICAgICAgIHRoaXMubG9jYXRpb25bbGFuZ10gPSBkZXNjO1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldFNhbXBsZUxvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5sb2NhdGlvbjtcbiAgICB9XG5cbiAgICBzZXRMb2NhdGlvbihzeXN0ZW0sIHYxLCB2Mikge1xuICAgICAgICB0aGlzLmdlb1N5c3RlbSA9IHN5c3RlbSxcbiAgICAgICAgICAgIHRoaXMuZ2VvUG9zaXRpb24gPSBbdjEsIHYyXVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldEdlb0xvY2F0aW9uKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgXCJzeXN0ZW1cIjogdGhpcy5nZW9TeXN0ZW0sXG4gICAgICAgICAgICBcInBvc2l0aW9uXCI6IHtcbiAgICAgICAgICAgICAgICBcImxhdGl0dWRlXCI6IHRoaXMuZ2VvUG9zaXRpb25bMF0sXG4gICAgICAgICAgICAgICAgXCJsb25naXR1ZGVcIjogdGhpcy5nZW9Qb3NpdGlvblsxXVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgc2V0TWFnbmlmeShtYWduaWZpY2F0aW9uVmFsdWUpIHtcbiAgICAgICAgdGhpcy5tYWduaWZ5ID0gbWFnbmlmaWNhdGlvblZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0TWFnbmlmeSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWFnbmlmeVxuICAgIH1cblxuICAgIHNldFNjYWxlVW5pdChzY2FsZVVuaXQpIHtcbiAgICAgICAgdGhpcy5zY2FsZVVuaXQgPSBzY2FsZVVuaXQ7XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0U2NhbGVVbml0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVVuaXRcbiAgICB9XG5cbiAgICBzZXRTY2FsZVBpeGVsKHNjYWxlTGVuZ3RoQXNQaXhlbCkge1xuICAgICAgICB0aGlzLnNjYWxlUGl4ZWwgPSBzY2FsZUxlbmd0aEFzUGl4ZWxcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRTY2FsZVBpeGVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2FsZVBpeGVsXG4gICAgfVxuXG4gICAgc2V0U2FtcGxlTGFiZWwocykge1xuICAgICAgICB0aGlzLnNhbXBsZUxhYmVsID0gc1xuICAgIH1cblxuICAgIGdldFNhbXBsZUxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zYW1wbGVMYWJlbCB8fCBcIlwiXG4gICAgfVxuXG4gICAgc2V0SW1hZ2VTaXplKGltZykge1xuICAgICAgICB0aGlzLmltYWdlU2l6ZSA9IHtcbiAgICAgICAgICAgIFwid2lkdGhcIjogaW1nLndpZHRoLFxuICAgICAgICAgICAgXCJoZWlnaHRcIjogaW1nLmhlaWdodFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0SW1hZ2VXaWR0aCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VTaXplLndpZHRoXG4gICAgfVxuXG4gICAgZ2V0SW1hZ2VIZWlnaHQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlU2l6ZS5oZWlnaHRcbiAgICB9XG5cbiAgICBzZXRSb3RhdGVDZW50ZXIoZnJvbUxlZnQsIGZyb21Ub3ApIHtcbiAgICAgICAgdGhpcy5yb3RhdGVDZW50ZXIgPSBbZnJvbUxlZnQsIGZyb21Ub3BdXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0Um90YXRlQ2VudGVyKCkge1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgdGhpcy5yb3RhdGVDZW50ZXJbMF0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRJbWFnZVdpZHRoKCkgKiAwLjVcbiAgICAgICAgICAgICAgICA6IHRoaXMucm90YXRlQ2VudGVyWzBdLFxuICAgICAgICAgICAgdGhpcy5yb3RhdGVDZW50ZXJbMV0gPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gdGhpcy5nZXRJbWFnZUhlaWdodCgpICogMC41XG4gICAgICAgICAgICAgICAgOiB0aGlzLnJvdGF0ZUNlbnRlclsxXVxuICAgICAgICBdXG4gICAgfVxuXG4gICAgc2V0SW1hZ2VzTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuaW1hZ2VzTnVtYmVyID0gdmFsdWVcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXRJbWFnZXNOdW1iZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmltYWdlc051bWJlclxuICAgIH1cblxuICAgIGdldFJvdGF0ZVNlY3Rpb25EZWdyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEVhY2hSb3RhdGVEZWdyZWUoKSAqICh0aGlzLmdldEltYWdlc051bWJlcigpIC0gMSlcbiAgICB9XG5cbiAgICBzZXRSb3RhdGVEaXJlY3Rpb24oZGlyZWN0aW9uKSB7XG4gICAgICAgIHRoaXMucm90YXRlRGlyZWN0aW9uID0gZGlyZWN0aW9uXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgaXNSb3RhdGVDbG9ja3dpc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdGF0ZURpcmVjdGlvbiA9PT0gXCJjbG9ja3dpc2VcIlxuICAgIH1cblxuICAgIHNldEVhY2hSb3RhdGVEZWdyZWUoZGVncmVlKSB7XG4gICAgICAgIHRoaXMuZWFjaFJvdGF0ZURlZ3JlZSA9IGRlZ3JlZVxuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldEVhY2hSb3RhdGVEZWdyZWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVhY2hSb3RhdGVEZWdyZWVcbiAgICB9XG5cbiAgICBzZXRSb2NrVHlwZShsYW5nLCBkZXNjKSB7XG4gICAgICAgIHRoaXMucm9ja1R5cGVbbGFuZ10gPSBkZXNjXG4gICAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgZ2V0Um9ja1R5cGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvY2tUeXBlXG4gICAgfVxuXG4gICAgc2V0T3duZXIobGFuZywgZGVzYykge1xuICAgICAgICB0aGlzLm93bmVyW2xhbmddID0gZGVzY1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIGdldE93bmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5vd25lclxuICAgIH1cblxuICAgIHNldERlc2NyaXB0aW9uKGxhbmcsIGRlc2MpIHtcbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbltsYW5nXSA9IGRlc2NcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICB9XG5cbiAgICBnZXREZXNjcmlwdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVzY3JpcHRpb25cbiAgICB9XG5cbiAgICBzZXRJbWFnZUZvcm1hdHMoZm9ybWF0cykge1xuICAgICAgICBmb3JtYXRzLmZvckVhY2goZm9ybWF0ID0+IHtcbiAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KFtcIndlYnBcIiwgXCJqcGdcIiwgXCJqcDJcIl0uaW5jbHVkZXMoZm9ybWF0KSlcbiAgICAgICAgfSlcbiAgICAgICAgdGhpcy5pbWFnZUZvcm1hdHMgPSBmb3JtYXRzXG4gICAgfVxuXG4gICAgZ2V0SW1hZ2VGb3JtYXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pbWFnZUZvcm1hdHMgfHwgW11cbiAgICB9XG59XG4iLCJleHBvcnQgY29uc3Qgdmlld2VyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNtYWluLXZpZXdlclwiKVxuZXhwb3J0IGNvbnN0IHZpZXdlcl9jdHggPSB2aWV3ZXIuZ2V0Q29udGV4dChcIjJkXCIpXG4iLCJpbXBvcnQgeyB2aWV3ZXIsIHZpZXdlcl9jdHggfSBmcm9tIFwiLi92aWV3ZXJfY2FudmFzLmpzXCJcbmltcG9ydCBnZXRNYXhWaWV3ZXJTaXplIGZyb20gXCIuL2dldE1heFZpZXdlclNpemUuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiB1cGRhdGVWaWV3ZXJHZW9tZXRyeShzdGF0ZSkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgY29uc3QgcGFkZGluZyA9IDIwIC8vIHB4XG4gICAgICAgIHN0YXRlLmNhbnZhc1dpZHRoID0gZ2V0TWF4Vmlld2VyU2l6ZSgpIC0gcGFkZGluZ1xuICAgICAgICBzdGF0ZS5jYW52YXNIZWlnaHQgPSBnZXRNYXhWaWV3ZXJTaXplKCkgLSBwYWRkaW5nXG5cbiAgICAgICAgdmlld2VyLndpZHRoID0gc3RhdGUuY2FudmFzV2lkdGhcbiAgICAgICAgdmlld2VyLmhlaWdodCA9IHN0YXRlLmNhbnZhc0hlaWdodFxuICAgICAgICB2aWV3ZXJfY3R4LnRyYW5zbGF0ZShzdGF0ZS5jYW52YXNXaWR0aCAqIDAuNSwgc3RhdGUuY2FudmFzSGVpZ2h0ICogMC41KVxuICAgICAgICByZXMoc3RhdGUpXG4gICAgfSlcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHNhbml0aXplSUQoaWQpIHtcbiAgICByZXR1cm4gaWQucmVwbGFjZSgvXFwvL2csIFwiX1wiKS5yZXBsYWNlKC9cXC4vZywgXCJcIilcbn1cbiIsImV4cG9ydCBjb25zdCBzdGVwQnkgPSB1bml0ID0+IHZhbCA9PiBNYXRoLmZsb29yKHZhbCAvIHVuaXQpXG5cbmV4cG9ydCBjb25zdCBjeWNsZUJ5ID0gdW5pdCA9PiB2YWwgPT4ge1xuICAgIGNvbnN0IGN5Y2xlX2NvdW50ID0gTWF0aC5mbG9vcih2YWwgLyB1bml0KVxuICAgIHJldHVybiB2YWwgPCAwXG4gICAgICAgID8gdmFsICsgdW5pdFxuICAgICAgICA6ICh1bml0IDw9IHZhbClcbiAgICAgICAgICAgID8gdmFsIC0gdW5pdCAqIGN5Y2xlX2NvdW50XG4gICAgICAgICAgICA6IHZhbFxufVxuXG5leHBvcnQgY29uc3QgbWlycm9yQnkgPSAoY2VudGVyKSA9PiB2YWwgPT4gdmFsID4gY2VudGVyID8gMiAqIGNlbnRlciAtIHZhbCA6IHZhbFxuXG5leHBvcnQgY29uc3QgaXNJbnZlcnNlID0gZGVncmVlID0+ICgxODAgPD0gZGVncmVlKVxuXG5leHBvcnQgY29uc3Qgcm90YXRlU2lnbiA9IChjbG9ja3dpc2UgPSB0cnVlKSA9PiBjbG9ja3dpc2UgPyAtMSA6IDFcbiIsImltcG9ydCBzYW5pdGl6ZUlEIGZyb20gXCIuL3Nhbml0aXplSUQuanNcIlxuaW1wb3J0IHsgY3ljbGVCeSwgc3RlcEJ5IH0gZnJvbSBcIi4vcm90YXRpb25fZGVncmVlX2hhbmRsZXJzLmpzXCJcblxuZnVuY3Rpb24gZ2V0Um90YXRpb25DZW50ZXIobWV0YSkge1xuICAgIHJldHVybiAobWV0YS5oYXNPd25Qcm9wZXJ0eShcInJvdGF0ZV9jZW50ZXJcIikpXG4gICAgICAgID8ge1xuICAgICAgICAgICAgXCJ0b19yaWdodFwiOiBtZXRhLnJvdGF0ZV9jZW50ZXJbMF0sXG4gICAgICAgICAgICBcInRvX2JvdHRvbVwiOiBtZXRhLnJvdGF0ZV9jZW50ZXJbMV1cbiAgICAgICAgfVxuICAgICAgICA6IHtcbiAgICAgICAgICAgIFwidG9fcmlnaHRcIjogbWV0YS5pbWFnZV93aWR0aCAqIDAuNSxcbiAgICAgICAgICAgIFwidG9fYm90dG9tXCI6IG1ldGEuaW1hZ2VfaGVpZ2h0ICogMC41XG4gICAgICAgIH1cbn1cblxuZnVuY3Rpb24gZ2V0SW1hZ2VSYWRpdXMobWV0YSkge1xuICAgIGNvbnN0IHNoaWZ0ID0gZ2V0Um90YXRpb25DZW50ZXIobWV0YSk7XG4gICAgY29uc3QgaW1hZ2VfY2VudGVyID0ge1xuICAgICAgICBcInhcIjogbWV0YS5pbWFnZV93aWR0aCAqIDAuNSxcbiAgICAgICAgXCJ5XCI6IG1ldGEuaW1hZ2VfaGVpZ2h0ICogMC41XG4gICAgfVxuICAgIHJldHVybiBNYXRoLm1pbihcbiAgICAgICAgaW1hZ2VfY2VudGVyLnggLSBNYXRoLmFicyhpbWFnZV9jZW50ZXIueCAtIHNoaWZ0LnRvX3JpZ2h0KSxcbiAgICAgICAgaW1hZ2VfY2VudGVyLnkgLSBNYXRoLmFicyhpbWFnZV9jZW50ZXIueSAtIHNoaWZ0LnRvX2JvdHRvbSlcbiAgICApXG59XG5cbmZ1bmN0aW9uIG1hcE1ldGFkYXRhKG1ldGEpIHtcbiAgICBjb25zdCByb3RhdGVfZGVncmVlX3N0ZXAgPSBwYXJzZUludChtZXRhLnJvdGF0ZV9ieV9kZWdyZWUpXG5cbiAgICByZXR1cm4ge1xuICAgICAgICBpc0Nsb2Nrd2lzZTogbWV0YS5yb3RhdGVfY2xvY2t3aXNlLFxuICAgICAgICBsb2NhdGlvbjogbWV0YS5sb2NhdGlvbixcbiAgICAgICAgcm9ja1R5cGU6IG1ldGEucm9ja190eXBlLFxuICAgICAgICBvd25lcjogbWV0YS5vd25lcixcbiAgICAgICAgZGVzY3JpcHRpb246IG1ldGEuaGFzT3duUHJvcGVydHkoXCJkaXNjcmlwdGlvblwiKVxuICAgICAgICAgICAgPyBtZXRhLmRpc2NyaXB0aW9uXG4gICAgICAgICAgICA6IG1ldGEuaGFzT3duUHJvcGVydHkoXCJkZXNjcmlwdGlvblwiKVxuICAgICAgICAgICAgICAgID8gbWV0YS5kZXNjcmlwdGlvblxuICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgIHJvdGF0ZV9jZW50ZXI6IGdldFJvdGF0aW9uQ2VudGVyKG1ldGEpLFxuICAgICAgICBpbWFnZVdpZHRoOiBtZXRhLmltYWdlX3dpZHRoLFxuICAgICAgICBpbWFnZUhlaWdodDogbWV0YS5pbWFnZV9oZWlnaHQsXG4gICAgICAgIGltYWdlUmFkaXVzOiBnZXRJbWFnZVJhZGl1cyhtZXRhKSxcbiAgICAgICAgaW1hZ2VSYWRpdXNPcmlnaW5hbDogZ2V0SW1hZ2VSYWRpdXMobWV0YSksXG4gICAgICAgIHNjYWxlV2lkdGg6IG1ldGEuaGFzT3duUHJvcGVydHkoXCJzY2FsZS1waXhlbFwiKVxuICAgICAgICAgICAgPyBwYXJzZUludChtZXRhW1wic2NhbGUtcGl4ZWxcIl0pXG4gICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICBzY2FsZVRleHQ6IG1ldGEuaGFzT3duUHJvcGVydHkoXCJzY2FsZS11bml0XCIpXG4gICAgICAgICAgICA/IG1ldGFbXCJzY2FsZS11bml0XCJdXG4gICAgICAgICAgICA6IGZhbHNlLFxuICAgICAgICByb3RhdGVfZGVncmVlX3N0ZXA6IHJvdGF0ZV9kZWdyZWVfc3RlcFxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdXBkYXRlU3RhdGVCeU1ldGEoc3RhdGUpIHtcbiAgICByZXR1cm4gKGNvbnRhaW5vcklELCBtZXRhKSA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblxuICAgICAgICBzdGF0ZS5jb250YWlub3JJRCA9IHNhbml0aXplSUQoY29udGFpbm9ySUQpO1xuXG4gICAgICAgIGNvbnN0IHJvdGF0ZV9kZWdyZWVfc3RlcCA9IHBhcnNlSW50KG1ldGEucm90YXRlX2J5X2RlZ3JlZSlcbiAgICAgICAgY29uc3QgY3ljbGVfZGVncmVlID0gbWV0YS5oYXNPd25Qcm9wZXJ0eShcImN5Y2xlX3JvdGF0ZV9kZWdyZWVcIilcbiAgICAgICAgICAgID8gcGFyc2VJbnQobWV0YS5jeWNsZV9yb3RhdGVfZGVncmVlKVxuICAgICAgICAgICAgOiA5MDtcbiAgICAgICAgY29uc3QgaW1hZ2VfbnVtYmVyID0gY3ljbGVfZGVncmVlIC8gcm90YXRlX2RlZ3JlZV9zdGVwICsgMVxuICAgICAgICBjb25zdCBtaXJyb3JfYXQgPSAoaW1hZ2VfbnVtYmVyIC0gMSlcbiAgICAgICAgY29uc3QgdG90YWxfc3RlcCA9IChpbWFnZV9udW1iZXIgLSAxKSAqIDJcblxuICAgICAgICBzdGF0ZS5pbWFnZV9udW1iZXIgPSBpbWFnZV9udW1iZXJcbiAgICAgICAgc3RhdGUuZ2V0SW1hZ2VOdW1iZXIgPSBjeWNsZV9kZWdyZWUgPiAwXG4gICAgICAgICAgICA/IGRlZ3JlZSA9PiBjeWNsZUJ5KGltYWdlX251bWJlciAtIDEpKFxuICAgICAgICAgICAgICAgIHN0ZXBCeShyb3RhdGVfZGVncmVlX3N0ZXApKHN0YXRlLmlzQ2xvY2t3aXNlID8gMzYwIC0gZGVncmVlIDogZGVncmVlKVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgOiBkZWdyZWUgPT4gbWlycm9yQnkobWlycm9yX2F0KShcbiAgICAgICAgICAgICAgICBjeWNsZUJ5KHRvdGFsX3N0ZXApKFxuICAgICAgICAgICAgICAgICAgICBzdGVwQnkocm90YXRlX2RlZ3JlZV9zdGVwKShkZWdyZWUpXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKVxuXG4gICAgICAgIHN0YXRlLmdldEFscGhhID0gZGVncmVlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG50aCA9IGN5Y2xlQnkodG90YWxfc3RlcCAqIDIpKFxuICAgICAgICAgICAgICAgIHN0ZXBCeShyb3RhdGVfZGVncmVlX3N0ZXApKGRlZ3JlZSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIHJldHVybiAxIC0gKGRlZ3JlZSAtIHJvdGF0ZV9kZWdyZWVfc3RlcCAqIG50aCkgLyByb3RhdGVfZGVncmVlX3N0ZXBcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXRlLm9wZW5faW1hZ2VzID0gW11cbiAgICAgICAgc3RhdGUuY3Jvc3NfaW1hZ2VzID0gW11cblxuICAgICAgICBzdGF0ZS5yb3RhdGUgPSAwO1xuXG4gICAgICAgIHN0YXRlID0gT2JqZWN0LmFzc2lnbihzdGF0ZSwgbWFwTWV0YWRhdGEobWV0YSkpXG5cbiAgICAgICAgcmVzKHN0YXRlKVxuICAgIH0pXG59XG4iLCJcblxuZXhwb3J0IGNvbnN0IGhpZGVXZWxjb21lQm9hcmQgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgYm9hcmQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3dlbGNvbWUtY2FyZFwiKVxuICAgIGJvYXJkLmNsYXNzTGlzdC5hZGQoXCJpbmFjdGl2ZVwiKTtcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuZXhwb3J0IGNvbnN0IHNob3dWaWV3ZXIgPSBzdGF0ZSA9PiB7XG4gICAgY29uc3QgY2FyZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjdmlld2VyX3dyYXBwZXJcIilcbiAgICBjYXJkLmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgY29uc3Qgc2hvd05pY29sQnV0dG9uID0gc3RhdGUgPT4ge1xuICAgIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbG93LW5hdmlnYXRpb25cIilcbiAgICBidXR0b24uY2xhc3NMaXN0LnJlbW92ZShcImluYWN0aXZlXCIpO1xuICAgIHJldHVybiBzdGF0ZVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY2xpcEdlb21ldG9yeUZyb21JbWFnZUNlbnRlcihzdGF0ZSkge1xuXG4gICAgcmV0dXJuIFtcbiAgICAgICAgc3RhdGUucm90YXRlX2NlbnRlci50b19yaWdodCAtIHN0YXRlLmltYWdlUmFkaXVzLFxuICAgICAgICBzdGF0ZS5yb3RhdGVfY2VudGVyLnRvX2JvdHRvbSAtIHN0YXRlLmltYWdlUmFkaXVzLFxuICAgICAgICBzdGF0ZS5pbWFnZVJhZGl1cyAqIDIsXG4gICAgICAgIHN0YXRlLmltYWdlUmFkaXVzICogMlxuICAgIF1cbn1cbiIsImltcG9ydCBjbGlwR2VvbWV0b3J5RnJvbUltYWdlQ2VudGVyIGZyb20gXCIuL2NsaXBHZW9tZXRyeUZyb21JbWFnZUNlbnRlci5qc1wiXG5pbXBvcnQgeyB2aWV3ZXJfY3R4IH0gZnJvbSBcIi4vdmlld2VyX2NhbnZhcy5qc1wiXG5pbXBvcnQgeyBWSUVXX1BBRERJTkcgfSBmcm9tIFwiLi9jb25maWcvY29uZmlnLmpzXCJcbmltcG9ydCB7IHJvdGF0ZVNpZ24gfSBmcm9tIFwiLi9yb3RhdGlvbl9kZWdyZWVfaGFuZGxlcnMuanNcIlxuXG5leHBvcnQgZnVuY3Rpb24gY2xlYXJWaWV3KHN0YXRlKSB7XG4gICAgdmlld2VyX2N0eC5jbGVhclJlY3QoLXN0YXRlLmNhbnZhc1dpZHRoICogMC41LCAtc3RhdGUuY2FudmFzSGVpZ2h0ICogMC41LCBzdGF0ZS5jYW52YXNXaWR0aCwgc3RhdGUuY2FudmFzSGVpZ2h0KVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gYmxvYlRvQ2FudmFzKHN0YXRlKSB7XG5cbiAgICBjb25zdCBpbWFnZV9zcmNzID0gc3RhdGUuaXNDcm9zc05pY29sXG4gICAgICAgID8gc3RhdGUuY3Jvc3NfaW1hZ2VzXG4gICAgICAgIDogc3RhdGUub3Blbl9pbWFnZXNcblxuICAgIC8vIHZpZXcgd2luZG93IGNpcmNsZVxuXG4gICAgdmlld2VyX2N0eC5zYXZlKClcbiAgICB2aWV3ZXJfY3R4LmJlZ2luUGF0aCgpXG4gICAgdmlld2VyX2N0eC5hcmMoMCwgMCwgc3RhdGUuY2FudmFzV2lkdGggLyAyIC0gVklFV19QQURESU5HLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpXG4gICAgdmlld2VyX2N0eC5jbGlwKClcblxuICAgIC8vIERyYXcgYSBpbWFnZVxuICAgIGNvbnN0IGFscGhhID0gc3RhdGUuZ2V0QWxwaGEoc3RhdGUucm90YXRlKVxuXG4gICAgdmlld2VyX2N0eC5yb3RhdGUoXG4gICAgICAgIHJvdGF0ZVNpZ24oc3RhdGUuaXNDbG9ja3dpc2UpICogKHN0YXRlLnJvdGF0ZSArIHN0YXRlLmdldEltYWdlTnVtYmVyKHN0YXRlLnJvdGF0ZSkgKiBzdGF0ZS5yb3RhdGVfZGVncmVlX3N0ZXApIC8gMTgwICogTWF0aC5QSVxuICAgIClcblxuICAgIHZpZXdlcl9jdHguZ2xvYmFsQWxwaGEgPSAxXG4gICAgY29uc3QgaW1hZ2UxID0gaW1hZ2Vfc3Jjc1tzdGF0ZS5nZXRJbWFnZU51bWJlcihzdGF0ZS5yb3RhdGUpXVxuXG4gICAgdHJ5IHtcbiAgICAgICAgdmlld2VyX2N0eC5kcmF3SW1hZ2UoXG4gICAgICAgICAgICBpbWFnZTEsXG4gICAgICAgICAgICAuLi5jbGlwR2VvbWV0b3J5RnJvbUltYWdlQ2VudGVyKHN0YXRlKSxcbiAgICAgICAgICAgIC1zdGF0ZS5jYW52YXNXaWR0aCAvIDIsXG4gICAgICAgICAgICAtc3RhdGUuY2FudmFzSGVpZ2h0IC8gMixcbiAgICAgICAgICAgIHN0YXRlLmNhbnZhc1dpZHRoLFxuICAgICAgICAgICAgc3RhdGUuY2FudmFzSGVpZ2h0XG4gICAgICAgICk7XG4gICAgfSBjYXRjaCAoZSkge1xuXG4gICAgfVxuXG4gICAgdmlld2VyX2N0eC5yZXN0b3JlKClcblxuICAgIC8vIERyYXcgbmV4dCBpbWFnZVxuICAgIHZpZXdlcl9jdHguc2F2ZSgpXG4gICAgdmlld2VyX2N0eC5iZWdpblBhdGgoKVxuICAgIHZpZXdlcl9jdHguYXJjKDAsIDAsIHN0YXRlLmNhbnZhc1dpZHRoIC8gMiAtIFZJRVdfUEFERElORywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKVxuICAgIHZpZXdlcl9jdHguY2xpcCgpXG5cbiAgICB2aWV3ZXJfY3R4LnJvdGF0ZShcbiAgICAgICAgcm90YXRlU2lnbihzdGF0ZS5pc0Nsb2Nrd2lzZSkgKiAoc3RhdGUucm90YXRlICsgc3RhdGUuZ2V0SW1hZ2VOdW1iZXIoc3RhdGUucm90YXRlICsgc3RhdGUucm90YXRlX2RlZ3JlZV9zdGVwKSAqIHN0YXRlLnJvdGF0ZV9kZWdyZWVfc3RlcCkgLyAxODAgKiBNYXRoLlBJXG4gICAgKVxuXG4gICAgdmlld2VyX2N0eC5nbG9iYWxBbHBoYSA9IDEgLSBhbHBoYVxuICAgIGNvbnN0IGltYWdlMiA9IGltYWdlX3NyY3Nbc3RhdGUuZ2V0SW1hZ2VOdW1iZXIoc3RhdGUucm90YXRlICsgc3RhdGUucm90YXRlX2RlZ3JlZV9zdGVwKV1cbiAgICB0cnkge1xuICAgICAgICB2aWV3ZXJfY3R4LmRyYXdJbWFnZShcbiAgICAgICAgICAgIGltYWdlMixcbiAgICAgICAgICAgIC4uLmNsaXBHZW9tZXRvcnlGcm9tSW1hZ2VDZW50ZXIoc3RhdGUpLFxuICAgICAgICAgICAgLXN0YXRlLmNhbnZhc1dpZHRoIC8gMixcbiAgICAgICAgICAgIC1zdGF0ZS5jYW52YXNIZWlnaHQgLyAyLFxuICAgICAgICAgICAgc3RhdGUuY2FudmFzV2lkdGgsXG4gICAgICAgICAgICBzdGF0ZS5jYW52YXNIZWlnaHQpXG4gICAgfSBjYXRjaCAoZSkge1xuXG4gICAgfVxuICAgIHZpZXdlcl9jdHgucmVzdG9yZSgpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkcmF3SGFpckxpbmUoc3RhdGUpIHtcbiAgICBpZiAoIXN0YXRlLmRyYXdIYWlyTGluZSkgcmV0dXJuXG4gICAgdmlld2VyX2N0eC5zdHJva2VTdHlsZSA9IHN0YXRlLmlzQ3Jvc3NOaWNvbFxuICAgICAgICA/IFwid2hpdGVcIlxuICAgICAgICA6IFwiYmxhY2tcIjtcbiAgICB2aWV3ZXJfY3R4Lmdsb2JhbEFscGhhID0gMVxuICAgIHZpZXdlcl9jdHguYmVnaW5QYXRoKClcbiAgICB2aWV3ZXJfY3R4Lm1vdmVUbygwLCAtc3RhdGUuY2FudmFzSGVpZ2h0ICogMC41ICsgVklFV19QQURESU5HKVxuICAgIHZpZXdlcl9jdHgubGluZVRvKDAsIHN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNSAtIFZJRVdfUEFERElORylcbiAgICB2aWV3ZXJfY3R4Lm1vdmVUbygtc3RhdGUuY2FudmFzV2lkdGggKiAwLjUgKyBWSUVXX1BBRERJTkcsIDApXG4gICAgdmlld2VyX2N0eC5saW5lVG8oc3RhdGUuY2FudmFzV2lkdGggKiAwLjUgLSBWSUVXX1BBRERJTkcsIDApXG4gICAgdmlld2VyX2N0eC5jbG9zZVBhdGgoKVxuICAgIHZpZXdlcl9jdHguc3Ryb2tlKClcbiAgICByZXR1cm4gc3RhdGVcbn1cblxuY29uc3Qgc2NhbGVMZW5ndGggPSAoY2FudmFzV2lkdGgsIGltYWdlV2lkdGgsIHNjYWxlV2lkdGgpID0+IGNhbnZhc1dpZHRoICogc2NhbGVXaWR0aCAvIGltYWdlV2lkdGhcblxuZXhwb3J0IGZ1bmN0aW9uIGRyYXdTY2FsZShzdGF0ZSkge1xuICAgIGlmICghc3RhdGVbXCJzY2FsZVdpZHRoXCJdKSByZXR1cm47XG4gICAgbGV0IHNjYWxlUGl4ZWwgPSBzY2FsZUxlbmd0aChzdGF0ZS5jYW52YXNXaWR0aCwgc3RhdGUuaW1hZ2VSYWRpdXMgKiAyLCBzdGF0ZS5zY2FsZVdpZHRoKVxuICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gc3RhdGUuY2FudmFzV2lkdGg7XG4gICAgY29uc3Qgc2NhbGVCYXIgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3NjYWxlYmFyXCIpXG5cblxuICAgIGxldCBzY2FsZU51bWJlciA9IHN0YXRlLnNjYWxlVGV4dC5tYXRjaCgvKFxcZCtcXC4/XFxkKikvKVswXSAqIDFcbiAgICBjb25zdCBzY2FsZVVuaXQgPSBzdGF0ZS5zY2FsZVRleHQubWF0Y2goL1xcRCokLylbMF1cblxuICAgIHdoaWxlIChzY2FsZVBpeGVsID49IGNhbnZhc1dpZHRoKSB7XG4gICAgICAgIHNjYWxlUGl4ZWwgKj0gMC41XG4gICAgICAgIHNjYWxlTnVtYmVyICo9IDAuNVxuICAgIH1cbiAgICBzY2FsZUJhci5zdHlsZS53aWR0aCA9IHNjYWxlUGl4ZWwgKyBcInB4XCI7XG4gICAgc2NhbGVCYXIucXVlcnlTZWxlY3RvcihcImRpdjpmaXJzdC1jaGlsZFwiKS5pbm5lckhUTUwgPSBgJHtzY2FsZU51bWJlcn0gJHtzY2FsZVVuaXR9YDtcbiAgICByZXR1cm4gc3RhdGVcbn1cbiIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGdldENvb3JkaW5hdGVPbkNhbnZhcyhjYW52YXMpIHtcbiAgICByZXR1cm4gKGUsIGZpbmd1ciA9IDApID0+IHtcbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gKGUgaW5zdGFuY2VvZiBXaGVlbEV2ZW50KVxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICBlLmRlbHRhWCxcbiAgICAgICAgICAgICAgICAgICAgZS5kZWx0YVlcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiBbXG4gICAgICAgICAgICAgICAgICAgIGUucGFnZVggLSBjYW52YXMub2Zmc2V0TGVmdCxcbiAgICAgICAgICAgICAgICAgICAgZS5wYWdlWSAtIGNhbnZhcy5vZmZzZXRUb3BcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgIH0gZWxzZSBpZiAoZSBpbnN0YW5jZW9mIFRvdWNoRXZlbnQgJiYgZS50b3VjaGVzLmxlbmd0aCA+IGZpbmd1cikge1xuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICBlLnRvdWNoZXNbZmluZ3VyXS5wYWdlWCAtIGNhbnZhcy5vZmZzZXRMZWZ0LFxuICAgICAgICAgICAgICAgIGUudG91Y2hlc1tmaW5ndXJdLnBhZ2VZIC0gY2FudmFzLm9mZnNldFRvcFxuICAgICAgICAgICAgXVxuICAgICAgICB9XG4gICAgfVxufVxuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcmFkaXVuQmV0d2VlbihjeCwgY3kpIHtcbiAgICByZXR1cm4gKF94MSwgX3kxLCBfeDIsIF95MikgPT4ge1xuICAgICAgICBjb25zdCB4MSA9IF94MSAtIGN4XG4gICAgICAgIGNvbnN0IHgyID0gX3gyIC0gY3hcbiAgICAgICAgY29uc3QgeTEgPSBfeTEgLSBjeVxuICAgICAgICBjb25zdCB5MiA9IF95MiAtIGN5XG5cbiAgICAgICAgY29uc3QgY29zID0gKHgxICogeDIgKyB5MSAqIHkyKSAvIE1hdGguc3FydCgoeDEgKiB4MSArIHkxICogeTEpICogKHgyICogeDIgKyB5MiAqIHkyKSlcbiAgICAgICAgcmV0dXJuIE1hdGguc2lnbih4MSAqIHkyIC0geDIgKiB5MSkgKiBNYXRoLmFjb3MoY29zKVxuICAgIH1cbn1cbiIsImltcG9ydCB7IHZpZXdlciB9IGZyb20gXCIuL3ZpZXdlcl9jYW52YXMuanNcIlxuaW1wb3J0IGdldENvb3JkaW5hdGVPbkNhbnZhcyBmcm9tIFwiLi9nZXRDb29yZGluYXRlT25DYW52YXMuanNcIlxuaW1wb3J0IHJhZGl1bkJldHdlZW4gZnJvbSBcIi4vcmFkaXVuQmV0d2Vlbi5qc1wiXG5cblxuZXhwb3J0IGNvbnN0IGNhbnZhc0Nvb3JkaW5hdGUgPSBnZXRDb29yZGluYXRlT25DYW52YXModmlld2VyKVxuXG4vKipcbiAqIFVwZGF0ZSBzdGFydCBhbmQgZW5kIHBvc2l0aW9uXG4gKiBAcGFyYW0geyp9IHN0YXRlXG4gKiBAcGFyYW0geyp9IGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUNvb3JkaW5hdGUoc3RhdGUsIGUpIHtcbiAgICBzdGF0ZS5kcmFnX3N0YXJ0ID0gc3RhdGUuZHJhZ19lbmQgfHwgdW5kZWZpbmVkXG4gICAgc3RhdGUuZHJhZ19lbmQgPSBjYW52YXNDb29yZGluYXRlKGUpXG5cbiAgICBzdGF0ZS5waW5jaF9zdGFydCA9IHN0YXRlLnBpbmNoX2VuZCB8fCB1bmRlZmluZWRcbiAgICBzdGF0ZS5waW5jaF9lbmQgPSBjYW52YXNDb29yZGluYXRlKGUsIDEpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cbi8qKlxuICogQ2FsY3VsYXRlIHNtYWxsIGRpZmZlcmVuY2Ugb2Ygcm90YXRpb24uXG4gKiBVcGRhdGUgdG90YWwgcm90YXRpb24uXG4gKlxuICogQHBhcmFtIHsqfSBzdGF0ZVxuICogQHBhcmFtIHsqfSBlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVSb3RhdGUoc3RhdGUsIGUpIHtcbiAgICBpZiAoIXN0YXRlLmNhblJvdGF0ZSkgcmV0dXJuO1xuICAgIGlmIChzdGF0ZS5kcmFnX3N0YXJ0ID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIC8vIGRlbHRhIHJvdGF0ZSByYWRpdXNcbiAgICBjb25zdCByb3RhdGVfZW5kID0gcmFkaXVuQmV0d2VlbihcbiAgICAgICAgc3RhdGUuY2FudmFzV2lkdGggKiAwLjUsXG4gICAgICAgIHN0YXRlLmNhbnZhc0hlaWdodCAqIDAuNVxuICAgICkoLi4uc3RhdGUuZHJhZ19lbmQsIC4uLnN0YXRlLmRyYWdfc3RhcnQpXG5cbiAgICBzdGF0ZS5yb3RhdGUgKz0gcm90YXRlX2VuZCAvIE1hdGguUEkgKiAxODBcbiAgICBpZiAoc3RhdGUucm90YXRlID49IDM2MCkge1xuICAgICAgICBzdGF0ZS5yb3RhdGUgLT0gMzYwXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5yb3RhdGUgPCAwKSB7XG4gICAgICAgIHN0YXRlLnJvdGF0ZSArPSAzNjBcbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJpbXBvcnQgeyB1cGRhdGVDb29yZGluYXRlLCB1cGRhdGVSb3RhdGUgfSBmcm9tIFwiLi9jb29yZGluYXRlX3VwZGF0b3JzLmpzXCJcbmltcG9ydCB7IGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lIH0gZnJvbSBcIi4vZHJhd19zdGF0ZV91cGRhdG9ycy5qc1wiXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJvdGF0ZUltYWdlKHN0YXRlLCBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShzdGF0ZSwgZSlcbiAgICAgICAgdXBkYXRlUm90YXRlKHN0YXRlLCBlKVxuICAgICAgICBibG9iVG9DYW52YXMoc3RhdGUpXG4gICAgICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBjYW52YXNDb29yZGluYXRlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZV91cGRhdG9ycy5qc1wiXG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVNYWduaWZ5QnlQaW5jaChzdGF0ZSwgZSkge1xuICAgIGlmIChzdGF0ZS5kcmFnX3N0YXJ0ID09PSB1bmRlZmluZWQpIHJldHVyblxuICAgIGlmIChzdGF0ZS5waW5jaF9zdGFydCA9PT0gdW5kZWZpbmVkKSByZXR1cm5cblxuICAgIGNvbnN0IHgxID0gWy4uLnN0YXRlLmRyYWdfc3RhcnRdXG4gICAgY29uc3QgeTEgPSBbLi4uc3RhdGUucGluY2hfc3RhcnRdXG4gICAgY29uc3QgeDIgPSBbLi4uc3RhdGUuZHJhZ19lbmRdXG4gICAgY29uc3QgeTIgPSBbLi4uc3RhdGUucGluY2hfZW5kXVxuXG4gICAgY29uc3QgZXhwYW5zaW9uID0gTWF0aC5zcXJ0KCh4MlswXSAtIHkyWzBdKSAqKiAyICsgKHgyWzFdIC0geTJbMV0pICoqIDIpIC8gTWF0aC5zcXJ0KCh4MVswXSAtIHkxWzBdKSAqKiAyICsgKHgxWzFdIC0geTFbMV0pICoqIDIpXG5cbiAgICBjb25zdCBuZXdSYWRpdXMgPSAoZXhwYW5zaW9uID4gMilcbiAgICAgICAgPyBzdGF0ZS5pbWFnZVJhZGl1c1xuICAgICAgICA6IHN0YXRlLmltYWdlUmFkaXVzIC8gZXhwYW5zaW9uXG4gICAgc3RhdGUuaW1hZ2VSYWRpdXMgPSAobmV3UmFkaXVzKSA+IHN0YXRlLmltYWdlUmFkaXVzT3JpZ2luYWxcbiAgICAgICAgPyBzdGF0ZS5pbWFnZVJhZGl1c09yaWdpbmFsXG4gICAgICAgIDogKG5ld1JhZGl1cyA8IDEwMClcbiAgICAgICAgICAgID8gMTAwXG4gICAgICAgICAgICA6IG5ld1JhZGl1c1xuICAgIHJldHVybiBzdGF0ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gdXBkYXRlTWFnbmlmeUJ5V2hlZWwoc3RhdGUsIGUpIHtcbiAgICBjb25zdCBzY3JvbGxlZCA9IGNhbnZhc0Nvb3JkaW5hdGUoZSlbMV1cblxuICAgIGNvbnN0IG5ld1JhZGl1cyA9IHN0YXRlLmltYWdlUmFkaXVzICsgc2Nyb2xsZWRcbiAgICBzdGF0ZS5pbWFnZVJhZGl1cyA9IChuZXdSYWRpdXMpID4gc3RhdGUuaW1hZ2VSYWRpdXNPcmlnaW5hbFxuICAgICAgICA/IHN0YXRlLmltYWdlUmFkaXVzT3JpZ2luYWxcbiAgICAgICAgOiAobmV3UmFkaXVzIDwgMTAwKVxuICAgICAgICAgICAgPyAxMDBcbiAgICAgICAgICAgIDogbmV3UmFkaXVzXG4gICAgcmV0dXJuIHN0YXRlXG59XG4iLCJpbXBvcnQgeyB1cGRhdGVDb29yZGluYXRlIH0gZnJvbSBcIi4vY29vcmRpbmF0ZV91cGRhdG9ycy5qc1wiXG5pbXBvcnQgeyB1cGRhdGVNYWduaWZ5QnlQaW5jaCB9IGZyb20gXCIuL3VwZGF0ZU1hZ25pZnkuanNcIlxuaW1wb3J0IHsgYmxvYlRvQ2FudmFzLCBkcmF3SGFpckxpbmUsIGRyYXdTY2FsZSB9IGZyb20gXCIuL2RyYXdfc3RhdGVfdXBkYXRvcnMuanNcIlxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBwaW5jaEltYWdlKHN0YXRlLCBlKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgdXBkYXRlQ29vcmRpbmF0ZShzdGF0ZSwgZSlcbiAgICAgICAgdXBkYXRlTWFnbmlmeUJ5UGluY2goc3RhdGUsIGUpXG4gICAgICAgIGJsb2JUb0NhbnZhcyhzdGF0ZSlcbiAgICAgICAgZHJhd0hhaXJMaW5lKHN0YXRlKVxuICAgICAgICBkcmF3U2NhbGUoc3RhdGUpXG4gICAgfVxufVxuIiwiaW1wb3J0IHsgY2FudmFzQ29vcmRpbmF0ZSB9IGZyb20gXCIuL2Nvb3JkaW5hdGVfdXBkYXRvcnMuanNcIlxuaW1wb3J0IHJvdGF0ZUltYWdlIGZyb20gXCIuL3JvdGF0ZUltYWdlLmpzXCJcbmltcG9ydCBwaW5jaEltYWdlIGZyb20gXCIuL3BpbmNoSW1hZ2UuanNcIlxuXG5leHBvcnQgY29uc3QgdG91Y2hTdGFydEhhbmRsZXIgPSBzdGF0ZSA9PiBlID0+IHtcbiAgICBzdGF0ZS5pc01vdXNlZG93biA9IHRydWVcbiAgICBzdGF0ZS5kcmFnX2VuZCA9IGNhbnZhc0Nvb3JkaW5hdGUoZSlcbiAgICBlLnByZXZlbnREZWZhdWx0KCk7XG59XG5cbmV4cG9ydCBjb25zdCB0b3VjaE1vdmVIYW5kbGVyID0gc3RhdGUgPT4gZSA9PiB7XG4gICAgaWYgKCFzdGF0ZS5pc01vdXNlZG93bikgcmV0dXJuXG4gICAgaWYgKGUgaW5zdGFuY2VvZiBNb3VzZUV2ZW50IHx8IGUudG91Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXG4gICAgICAgICAgICByb3RhdGVJbWFnZShzdGF0ZSwgZSlcbiAgICAgICAgKVxuICAgIH0gZWxzZSBpZiAoZS50b3VjaGVzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgcmVxdWVzdEFuaW1hdGlvbkZyYW1lKFxuICAgICAgICAgICAgcGluY2hJbWFnZShzdGF0ZSwgZSlcbiAgICAgICAgKVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IHRvdWNoRW5kSGFuZGxlciA9IHN0YXRlID0+IGUgPT4ge1xuICAgIHN0YXRlLmlzTW91c2Vkb3duID0gZmFsc2VcbiAgICBzdGF0ZS5kcmFnX2VuZCA9IHVuZGVmaW5lZFxuICAgIHN0YXRlLnBpbmNoX2VuZCA9IHVuZGVmaW5lZFxuICAgIGUucHJldmVudERlZmF1bHQoKVxufVxuIiwiaW1wb3J0IHsgdXBkYXRlTWFnbmlmeUJ5V2hlZWwgfSBmcm9tIFwiLi91cGRhdGVNYWduaWZ5LmpzXCJcbmltcG9ydCB7IGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lLCBkcmF3U2NhbGUgfSBmcm9tIFwiLi9kcmF3X3N0YXRlX3VwZGF0b3JzLmpzXCJcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gd2hlZWxJbWFnZShzdGF0ZSwgZSkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIHVwZGF0ZU1hZ25pZnlCeVdoZWVsKHN0YXRlLCBlKVxuICAgICAgICBibG9iVG9DYW52YXMoc3RhdGUpXG4gICAgICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICAgICAgZHJhd1NjYWxlKHN0YXRlKVxuICAgIH1cbn1cbiIsImltcG9ydCB3aGVlbEltYWdlIGZyb20gXCIuL3doZWVsSW1hZ2UuanNcIlxuXG5leHBvcnQgY29uc3Qgd2hlZWxIYW5kbGVyID0gc3RhdGUgPT4gZSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICAgd2hlZWxJbWFnZShzdGF0ZSwgZSlcbiAgICApXG59XG4iLCJpbXBvcnQgaW5pdFN0YXRlIGZyb20gXCIuL3N0YXRlL2luaXRTdGF0ZS5qc1wiXG5pbXBvcnQgUGFja2FnZU1hbmlmZXN0IGZyb20gXCIuL3BhY2thZ2VfbWFuaWZlc3QuanNcIlxuaW1wb3J0IHVwZGF0ZVZpZXdlckdlb21ldHJ5IGZyb20gXCIuL3VwZGF0ZVZpZXdlckdlb21ldHJ5LmpzXCJcbmltcG9ydCB1cGRhdGVTdGF0ZUJ5TWV0YSBmcm9tIFwiLi91cGRhdGVTdGF0ZUJ5TWV0YS5qc1wiXG5pbXBvcnQgeyBzaG93Vmlld2VyLCBzaG93Tmljb2xCdXR0b24gfSBmcm9tIFwiLi92aWV3ZXJfaGFuZGxlcnMuanNcIlxuaW1wb3J0IHsgdmlld2VyIH0gZnJvbSBcIi4vdmlld2VyX2NhbnZhcy5qc1wiXG5pbXBvcnQgeyBjbGVhclZpZXcsIGJsb2JUb0NhbnZhcywgZHJhd0hhaXJMaW5lLCBkcmF3U2NhbGUgfSBmcm9tIFwiLi9kcmF3X3N0YXRlX3VwZGF0b3JzLmpzXCJcbmltcG9ydCB7IGNhbnZhc0Nvb3JkaW5hdGUgfSBmcm9tIFwiLi9jb29yZGluYXRlX3VwZGF0b3JzLmpzXCJcbmltcG9ydCB7IHRvdWNoU3RhcnRIYW5kbGVyLCB0b3VjaEVuZEhhbmRsZXIsIHRvdWNoTW92ZUhhbmRsZXIgfSBmcm9tIFwiLi90b3VjaEV2ZW50SGFuZGxlcnMuanNcIlxuaW1wb3J0IHsgd2hlZWxIYW5kbGVyIH0gZnJvbSBcIi4vd2hlZWxFdmVudEhhbmRsZXIuanNcIlxuXG5jb25zdCBwYWNrYWdlTWFwID0gbmV3IFBhY2thZ2VNYW5pZmVzdCgpO1xuY29uc3QgdXBsb2FkX3N0YXRlID0gT2JqZWN0LmFzc2lnbihcbiAgICBpbml0U3RhdGUoKSxcbiAgICB7XG4gICAgICAgIFwibG9hZEltYWdlc1wiOiBbZmFsc2UsIHRydWVdLFxuICAgICAgICBcImF1dG9Sb3RhdGVcIjogZmFsc2UsXG4gICAgICAgIFwidmlld01vZGVcIjogXCJ2YWxpZGF0aW9uXCIsXG4gICAgICAgIFwibGFuZ3VhZ2VcIjogXCJqYVwiLFxuICAgICAgICBcImRlc2lyZWRJbWFnZVNpemVcIjogMTUwLFxuICAgICAgICBcImRlc2lyZWRUaHVtYm5haWxJbWFnZVNpemVcIjogMTAwLFxuICAgIH1cbilcblxuZnVuY3Rpb24gYm90aEltYWdlc0xvYWRlZChmbGFncykge1xuICAgIHJldHVybiBmbGFncy5yZWR1Y2UoKGFjYywgZSkgPT4gYWNjICYmIGUsIHRydWUpXG59XG5cbmZ1bmN0aW9uIGZpbGVTZWxlY3RIYW5kZXIoZSkge1xuICAgIGZ1bmN0aW9uIHJlYWQoZmlsZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgICAgICBjb25zdCByZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpXG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChmaWxlKVxuICAgICAgICAgICAgcmVhZGVyLm9ubG9hZGVuZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICByZXMocmVhZGVyLnJlc3VsdClcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICBjb25zdCBmaWxlcyA9IGUudGFyZ2V0LmZpbGVzO1xuICAgICAgICBQcm9taXNlLmFsbChcbiAgICAgICAgICAgIEFycmF5LmZyb20oZmlsZXMpXG4gICAgICAgICAgICAgICAgLm1hcChmaWxlID0+IHJlYWQoZmlsZSkpXG4gICAgICAgICkudGhlbihyZXMpXG4gICAgfSlcbn1cblxuZnVuY3Rpb24gcmVhZEltYWdlU2l6ZShzdGF0ZSkge1xuICAgIHBhY2thZ2VNYXAuc2V0SW1hZ2VTaXplKHN0YXRlLm9wZW5faW1hZ2VzWzBdKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5mdW5jdGlvbiByZWFkSW1hZ2VzTnVtYmVyKHN0YXRlKSB7XG4gICAgcGFja2FnZU1hcC5zZXRJbWFnZXNOdW1iZXIoc3RhdGUub3Blbl9pbWFnZXMubGVuZ3RoKVxuICAgIHJldHVybiBzdGF0ZVxufVxuXG5hc3luYyBmdW5jdGlvbiBzaG93SW1hZ2VzKHN0YXRlKSB7XG4gICAgcmVhZEltYWdlU2l6ZShzdGF0ZSlcbiAgICByZWFkSW1hZ2VzTnVtYmVyKHN0YXRlKVxuICAgIGNvbnN0IG5ld19zdGF0ZSA9IGF3YWl0IHVwZGF0ZVN0YXRlQnlNZXRhKHN0YXRlLCBcInVwbG9hZFwiKShwYWNrYWdlTWFwLnBhY2thZ2VJRCwgcGFja2FnZU1hcC50b0pTT04oKSlcblxuICAgIG5ld19zdGF0ZS5vcGVuX2ltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKHN0YXRlLm9wZW5faW1hZ2Vfc3Jjcy5tYXAobG9hZEltYWdlRnJvbVNyYykpXG4gICAgbmV3X3N0YXRlLmNyb3NzX2ltYWdlcyA9IGF3YWl0IFByb21pc2UuYWxsKHN0YXRlLmNyb3NzX2ltYWdlX3NyY3MubWFwKGxvYWRJbWFnZUZyb21TcmMpKVxuXG4gICAgcmV0dXJuIHVwZGF0ZVZpZXcobmV3X3N0YXRlKVxuICAgICAgICAudGhlbihzaG93Vmlld2VyKVxuICAgICAgICAudGhlbihzaG93Tmljb2xCdXR0b24pXG59XG5cbmZ1bmN0aW9uIGxvYWRJbWFnZUZyb21TcmMoc3JjKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuXG4gICAgICAgIGNvbnN0IGltZyA9IG5ldyBJbWFnZSgpXG5cbiAgICAgICAgaW1nLm9ubG9hZCA9IF8gPT4ge1xuICAgICAgICAgICAgcmVzKGltZylcbiAgICAgICAgfVxuXG4gICAgICAgIGltZy5zcmMgPSBzcmNcblxuICAgIH0pXG59XG5cbmZ1bmN0aW9uIG9wZW5JbWFnZXNTZWxlY3RIYW5kbGVyKHN0YXRlKSB7XG4gICAgcmV0dXJuIGUgPT4gbmV3IFByb21pc2UoYXN5bmMgKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHN0YXRlLm9wZW5faW1hZ2Vfc3JjcyA9IGF3YWl0IGZpbGVTZWxlY3RIYW5kZXIoZSlcbiAgICAgICAgc3RhdGUubG9hZEltYWdlc1swXSA9IHRydWVcbiAgICAgICAgc3RhdGUub3Blbl9pbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChzdGF0ZS5vcGVuX2ltYWdlX3NyY3MubWFwKGxvYWRJbWFnZUZyb21TcmMpKVxuICAgICAgICBhd2FpdCBzaG93SW1hZ2VzKHN0YXRlKVxuXG4gICAgICAgIHJlcyhzdGF0ZSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBjcm9zc0ltYWdlc1NlbGVjdEhhbmRsZXIoc3RhdGUpIHtcbiAgICByZXR1cm4gZSA9PiBuZXcgUHJvbWlzZShhc3luYyAocmVzLCByZWopID0+IHtcbiAgICAgICAgc3RhdGUuY3Jvc3NfaW1hZ2Vfc3JjcyA9IGF3YWl0IGZpbGVTZWxlY3RIYW5kZXIoZSlcbiAgICAgICAgc3RhdGUubG9hZEltYWdlc1sxXSA9IHRydWVcbiAgICAgICAgc3RhdGUuY3Jvc3NfaW1hZ2VzID0gYXdhaXQgUHJvbWlzZS5hbGwoc3RhdGUuY3Jvc3NfaW1hZ2Vfc3Jjcy5tYXAobG9hZEltYWdlRnJvbVNyYykpXG4gICAgICAgIGF3YWl0IHNob3dJbWFnZXMoc3RhdGUpXG5cbiAgICAgICAgcmVzKHN0YXRlKVxuICAgIH0pXG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVZpZXcoc3RhdGUpIHtcbiAgICBjbGVhclZpZXcoc3RhdGUpXG4gICAgYmxvYlRvQ2FudmFzKHN0YXRlKVxuICAgIGRyYXdIYWlyTGluZShzdGF0ZSlcbiAgICBkcmF3U2NhbGUoc3RhdGUpXG4gICAgcmV0dXJuIHN0YXRlXG59XG5cblxuZnVuY3Rpb24gYWN0aXZhdGVEb20oc2VsZWN0b3IpIHtcbiAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpKVxuICAgICAgICAuZm9yRWFjaChkb20gPT4ge1xuICAgICAgICAgICAgZG9tLmNsYXNzTGlzdC5yZW1vdmUoXCJpbmFjdGl2ZVwiKVxuICAgICAgICB9KVxufVxuXG5cbmZ1bmN0aW9uIGJhc2U2NFRvQmxvYihiYXNlNjQsIG1pbWUpIHtcbiAgICB2YXIgYmluYXJ5ID0gYXRvYihiYXNlNjQpO1xuICAgIHZhciBidWZmZXIgPSBuZXcgVWludDhBcnJheShiaW5hcnkubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmluYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGJ1ZmZlcltpXSA9IGJpbmFyeS5jaGFyQ29kZUF0KGkpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEJsb2IoW2J1ZmZlci5idWZmZXJdLCB7XG4gICAgICAgIHR5cGU6IG1pbWVcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gY29tcHJlc3NJbWFnZVNyYyhzcmMsIGZvcm1hdCwgZGVzaXJlZEtCeXRlID0gMTUwKSB7XG4gICAgY29uc29sZS5hc3NlcnQoW1wianBlZ1wiLCBcIndlYnBcIl0uaW5jbHVkZXMoZm9ybWF0KSlcblxuICAgIGNvbnN0IGltYWdlID0gbmV3IEltYWdlKClcbiAgICBpbWFnZS5zcmMgPSBzcmNcbiAgICBjb25zdCB3ID0gaW1hZ2Uud2lkdGhcbiAgICBjb25zdCBoID0gaW1hZ2UuaGVpZ2h0XG4gICAgY29uc3QgY3ZzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiN3b3JraW5nX2NhbnZhc1wiKVxuICAgIGN2cy53aWR0aCA9IHdcbiAgICBjdnMuaGVpZ2h0ID0gaFxuICAgIGNvbnN0IGN0eCA9IGN2cy5nZXRDb250ZXh0KFwiMmRcIilcbiAgICBjdHguZHJhd0ltYWdlKGltYWdlLCAwLCAwLCB3LCBoKVxuXG4gICAgY29uc3Qgb3JpZ2luYWxCaW5hcnkgPSBjdnMudG9EYXRhVVJMKGBpbWFnZS8ke2Zvcm1hdH1gKTsgLy/nlLvos6rokL3jgajjgZXjgZrjg5DjgqTjg4rjg6rljJZcbiAgICBjb25zdCBtaW1lID0gb3JpZ2luYWxCaW5hcnkubWF0Y2goLyg6KShbYS16XFwvXSspKDspLylbMl1cblxuICAgIGNvbnN0IG9yaWdpbmFsQmxvYiA9IGJhc2U2NFRvQmxvYihvcmlnaW5hbEJpbmFyeS5zcGxpdChcIixcIilbMV0sIG1pbWUpO1xuXG4gICAgaWYgKGRlc2lyZWRLQnl0ZSAqIDFlMyA8IG9yaWdpbmFsQmxvYltcInNpemVcIl0pIHtcbiAgICAgICAgY29uc3QgY2FwYWNpdHlSYXRpbyA9IGRlc2lyZWRLQnl0ZSAqIDFlMyAvIG9yaWdpbmFsQmxvYltcInNpemVcIl07XG4gICAgICAgIGNvbnN0IHByb2Nlc3NpbmdCaW5hcnkgPSBjdnMudG9EYXRhVVJMKGBpbWFnZS8ke2Zvcm1hdH1gLCBjYXBhY2l0eVJhdGlvKTsgLy/nlLvos6rokL3jgajjgZfjgabjg5DjgqTjg4rjg6rljJZcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQmxvYihwcm9jZXNzaW5nQmluYXJ5LnNwbGl0KFwiLFwiKVsxXSwgbWltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG9yaWdpbmFsQmxvYlxuICAgIH1cbn1cblxuZnVuY3Rpb24gc2hvd0Vycm9yTWVzc2FnZShkb21JZCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IG1lc3NhZ2VEb20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGRvbUlkKVxuICAgIG1lc3NhZ2VEb20uaW5uZXJIVE1MID0gbWVzc2FnZVxuICAgIG1lc3NhZ2VEb20uY2xhc3NMaXN0LnJlbW92ZShcImluYWN0aXZlXCIpXG59XG5cbmZ1bmN0aW9uIGhpZGVFcnJvck1lc3NhZ2UoZG9tSWQpIHtcbiAgICBjb25zdCBtZXNzYWdlRG9tID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihkb21JZClcbiAgICBtZXNzYWdlRG9tLmNsYXNzTGlzdC5hZGQoXCJpbmFjdGl2ZVwiKVxufVxuXG5cbmZ1bmN0aW9uIHNlbmRTYW1wbGVMaXN0RW50cnkoanNvbl9vYmopIHtcbiAgICBpZiAoanNvbl9vYmpbXCJwYWNrYWdlLW5hbWVcIl0ubWF0Y2gobmV3IFJlZ0V4cChcIl5bMC05YS16QS1aXy1dKyRcIikpID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhY2thZ2UgSUQgc2hvdWxkIGNvbnRhaW4gb25seSBudW1iZXIsIGFscGhhYmV0LCBfLCBhbmQgLS5cIilcbiAgICB9XG4gICAgaWYgKE9iamVjdC5rZXlzKGpzb25fb2JqW1wibGlzdC1uYW1lXCJdKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2FtcGxlIHRpdGxlIGlzIG5vdCBzZXQuXCIpXG4gICAgfVxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjZGV2X3NhbXBsZV9saXN0X2VudHJ5XCIpLmlubmVySFRNTCA9IEpTT04uc3RyaW5naWZ5KGpzb25fb2JqLCBudWxsLCAyKVxufTtcblxuZnVuY3Rpb24gaW5pdGlhbGl6ZU9yVXBkYXRlSW5wdXQoaW5wdXREb20sIHZhbHVlKSB7XG4gICAgaWYgKCFpbnB1dERvbS52YWx1ZSkge1xuICAgICAgICBpbnB1dERvbS52YWx1ZSA9IHZhbHVlXG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaG93UGFja2FnZVNpemUoc3RhdGUpIHtcbiAgICAvLyBTdW0gb3BlbiBhbmQgY3Jvc3MgaW1hZ2VzIChjb250YWlucyB0aHVtYm5haWwpXG4gICAgY29uc3QgaW1hZ2VzU2l6ZSA9IChzdGF0ZS5vcGVuX2ltYWdlX3NyY3MubGVuZ3RoICogc3RhdGUuZGVzaXJlZEltYWdlU2l6ZSArIHN0YXRlLmRlc2lyZWRUaHVtYm5haWxJbWFnZVNpemUpICogMlxuICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjbWVzc2FnZV9wYWNrYWdlX3NpemVcIikuaW5uZXJIVE1MID0gaW1hZ2VzU2l6ZVxufVxuXG4oZnVuY3Rpb24gKHN0YXRlKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dF9wYWNrYWdlX2lkXCIpLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgcGFja2FnZU1hcC5zZXRQYWNrYWdlSUQoZS50YXJnZXQudmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNpbnB1dF9kZXNpcmVkX2ltYWdlX3NpemVcIikuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5kZXNpcmVkSW1hZ2VTaXplID0gcGFyc2VGbG9hdChlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIHNob3dQYWNrYWdlU2l6ZShzdGF0ZSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0X2Rlc2lyZWRfdGh1bWJuYWlsX2ltYWdlX3NpemVcIikuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5kZXNpcmVkVGh1bWJuYWlsSW1hZ2VTaXplID0gcGFyc2VGbG9hdChlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIHNob3dQYWNrYWdlU2l6ZShzdGF0ZSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBjb25zdCBjZW50ZXJUb1JpZ2h0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNyb3RhdGVfY2VudGVyX2Zyb21fbGVmdFwiKVxuICAgIGNlbnRlclRvUmlnaHQuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBzdGF0ZS5yb3RhdGVfY2VudGVyLnRvX3JpZ2h0ID0gcGFyc2VGbG9hdChjZW50ZXJUb1JpZ2h0LnZhbHVlKVxuICAgICAgICAgICAgdXBkYXRlVmlldyhzdGF0ZSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG4gICAgY29uc3QgY2VudGVyVG9Cb3R0b20gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI3JvdGF0ZV9jZW50ZXJfZnJvbV90b3BcIilcbiAgICBjZW50ZXJUb0JvdHRvbS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIHN0YXRlLnJvdGF0ZV9jZW50ZXIudG9fYm90dG9tID0gcGFyc2VGbG9hdChjZW50ZXJUb0JvdHRvbS52YWx1ZSlcbiAgICAgICAgICAgIHVwZGF0ZVZpZXcoc3RhdGUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNvcGVuX25pY29sX2ltYWdlc1wiKS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIG9wZW5JbWFnZXNTZWxlY3RIYW5kbGVyKHN0YXRlKShlKS50aGVuKHN0YXRlID0+IHtcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplT3JVcGRhdGVJbnB1dChjZW50ZXJUb1JpZ2h0LCBzdGF0ZS5vcGVuX2ltYWdlc1swXS53aWR0aCAvIDIpXG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU9yVXBkYXRlSW5wdXQoY2VudGVyVG9Cb3R0b20sIHN0YXRlLm9wZW5faW1hZ2VzWzBdLmhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgc2hvd1BhY2thZ2VTaXplKHN0YXRlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2Nyb3NzX25pY29sX2ltYWdlc1wiKS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIGNyb3NzSW1hZ2VzU2VsZWN0SGFuZGxlcihzdGF0ZSkoZSkudGhlbihzdGF0ZSA9PiB7XG4gICAgICAgICAgICAgICAgaW5pdGlhbGl6ZU9yVXBkYXRlSW5wdXQoY2VudGVyVG9SaWdodCwgc3RhdGUuY3Jvc3NfaW1hZ2VzWzBdLndpZHRoIC8gMilcbiAgICAgICAgICAgICAgICBpbml0aWFsaXplT3JVcGRhdGVJbnB1dChjZW50ZXJUb0JvdHRvbSwgc3RhdGUuY3Jvc3NfaW1hZ2VzWzBdLmhlaWdodCAvIDIpXG4gICAgICAgICAgICAgICAgc2hvd1BhY2thZ2VTaXplKHN0YXRlKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBjb25zdCByb3RhdGVEaXJlY3Rpb25TZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjc2VsZWN0X3JvdGF0ZV9kaXJlY3Rpb25cIilcbiAgICByb3RhdGVEaXJlY3Rpb25TZWxlY3Rvci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGUudGFyZ2V0Lm9wdGlvbnNbZS50YXJnZXQuc2VsZWN0ZWRJbmRleF0udmFsdWVcbiAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0Um90YXRlRGlyZWN0aW9uKGRpcmVjdGlvbilcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBjb25zdCBpbnB1dFJvdGF0aW9uSW50ZXJ2YWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0X3JvdGF0aW9uX2ludGVydmFsXCIpXG4gICAgaW5wdXRSb3RhdGlvbkludGVydmFsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgcGFja2FnZU1hcC5zZXRFYWNoUm90YXRlRGVncmVlKGlucHV0Um90YXRpb25JbnRlcnZhbC52YWx1ZSlcbiAgICAgICAgICAgIGFjdGl2YXRlRG9tKFwiI3NlbGVjdF9pbWFnZV93cmFwcGVyXCIpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgY29uc3QgaW5wdXRTY2FsZVVuaXQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0X3NjYWxlX3VuaXRcIilcbiAgICBpbnB1dFNjYWxlVW5pdC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0U2NhbGVVbml0KGlucHV0U2NhbGVVbml0LnZhbHVlKVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIGNvbnN0IGlucHV0U2NhbGVMZW5ndGggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0X3NjYWxlX2xlbmd0aFwiKVxuICAgIGlucHV0U2NhbGVMZW5ndGguYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBwYWNrYWdlTWFwLnNldFNjYWxlUGl4ZWwoaW5wdXRTY2FsZUxlbmd0aC52YWx1ZSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICBjb25zdCBpbnB1dE1hZ25pZmljYXRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2lucHV0X21hZ25pZmljYXRpb25cIilcbiAgICBpbnB1dE1hZ25pZmljYXRpb24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICBwYWNrYWdlTWFwLnNldE1hZ25pZnkoZS50YXJnZXQudmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgY29uc3QgaW5wdXRTYW1wbGVMYWJlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjaW5wdXRfc2FtcGxlX2xhYmVsXCIpXG4gICAgaW5wdXRTYW1wbGVMYWJlbC5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0U2FtcGxlTGFiZWwoZS50YXJnZXQudmFsdWUpXG4gICAgICAgIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmlucHV0X3NhbXBsZV9sb2NhdGlvblwiKSkuZm9yRWFjaChkb20gPT4ge1xuICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgIFwiY2hhbmdlXCIsXG4gICAgICAgICAgICBlID0+IHtcbiAgICAgICAgICAgICAgICBwYWNrYWdlTWFwLnNldFNhbXBsZUxvY2F0aW9uKGUudGFyZ2V0LmRhdGFzZXQubGFuZywgZS50YXJnZXQudmFsdWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZmFsc2VcbiAgICAgICAgKVxuICAgIH0pXG5cbiAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuaW5wdXRfc2FtcGxlX3R5cGVcIikpLmZvckVhY2goZG9tID0+IHtcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgICAgcGFja2FnZU1hcC5zZXRSb2NrVHlwZShlLnRhcmdldC5kYXRhc2V0LmxhbmcsIGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICB9KVxuXG4gICAgQXJyYXkuZnJvbShkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKFwiLmlucHV0X2Rlc2NyaXB0aW9uXCIpKS5mb3JFYWNoKGRvbSA9PiB7XG4gICAgICAgIGRvbS5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICAgICAgXCJjaGFuZ2VcIixcbiAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0RGVzY3JpcHRpb24oZS50YXJnZXQuZGF0YXNldC5sYW5nLCBlLnRhcmdldC52YWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmYWxzZVxuICAgICAgICApXG4gICAgfSlcblxuICAgIEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5pbnB1dF9zYW1wbGVfdGl0bGVcIikpXG4gICAgICAgIC5mb3JFYWNoKGRvbSA9PiB7XG4gICAgICAgICAgICBkb20uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICAgICAgICAgIGUgPT4ge1xuICAgICAgICAgICAgICAgICAgICBwYWNrYWdlTWFwLnNldExpc3ROYW1lKGUudGFyZ2V0LmRhdGFzZXQubGFuZywgZS50YXJnZXQudmFsdWUpXG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApXG4gICAgICAgIH0pXG5cbiAgICBBcnJheS5mcm9tKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoXCIuaW5wdXRfb3duZXJcIikpLmZvckVhY2goZG9tID0+IHtcbiAgICAgICAgZG9tLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgICAgICBcImNoYW5nZVwiLFxuICAgICAgICAgICAgZSA9PiB7XG4gICAgICAgICAgICAgICAgcGFja2FnZU1hcC5zZXRPd25lcihlLnRhcmdldC5kYXRhc2V0LmxhbmcsIGUudGFyZ2V0LnZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZhbHNlXG4gICAgICAgIClcbiAgICB9KVxuXG4gICAgY29uc3QgdG9nZ2xlTmljb2xCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2NoYW5nZV9uaWNvbFwiKVxuICAgIGNvbnN0IHRvZ2dsZU5pY29sTGFiZWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI2NoYW5nZV9uaWNvbCArIGxhYmVsXCIpXG5cbiAgICBjb25zdCB0b2dnbGVOaWNvbEhhbmRsZXIgPSBzdGF0ZSA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcblxuICAgICAgICB0b2dnbGVOaWNvbEJ1dHRvbi5jaGVja2VkID0gc3RhdGUuaXNDcm9zc05pY29sXG4gICAgICAgIHN0YXRlLmlzQ3Jvc3NOaWNvbCA9ICFzdGF0ZS5pc0Nyb3NzTmljb2w7XG5cbiAgICAgICAgcmVzKHN0YXRlKVxuICAgIH0pXG5cbiAgICB0b2dnbGVOaWNvbEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcImNsaWNrXCIsXG4gICAgICAgIGUgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cblxuICAgIHRvZ2dsZU5pY29sTGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaFwiLFxuICAgICAgICBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdG9nZ2xlTmljb2xCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaFwiLFxuICAgICAgICBlID0+IHsgZS5wcmV2ZW50RGVmYXVsdCgpIH0sXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG5cbiAgICB0b2dnbGVOaWNvbExhYmVsLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwibW91c2V1cFwiLFxuICAgICAgICBlID0+IHRvZ2dsZU5pY29sSGFuZGxlcihzdGF0ZSlcbiAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHRvZ2dsZU5pY29sTGFiZWwuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICBlID0+IHRvZ2dsZU5pY29sSGFuZGxlcihzdGF0ZSlcbiAgICAgICAgICAgIC50aGVuKHVwZGF0ZVZpZXcpXG4gICAgICAgICAgICAudGhlbihfID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZS5jYW5jZWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIub25jb250ZXh0bWVudSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uX29uX2NhbnZhcyA9IGNhbnZhc0Nvb3JkaW5hdGUoZSlcbiAgICAgICAgY29uc3QgY3VycmVudF9yb3RhdGVfY2VudGVyID0gT2JqZWN0LnZhbHVlcyhzdGF0ZS5yb3RhdGVfY2VudGVyKVxuICAgICAgICBjb25zdCBzaGlmdCA9IFtcbiAgICAgICAgICAgIHBvc2l0aW9uX29uX2NhbnZhc1swXSAtIHN0YXRlLmNhbnZhc1dpZHRoICogMC41LFxuICAgICAgICAgICAgcG9zaXRpb25fb25fY2FudmFzWzFdIC0gc3RhdGUuY2FudmFzSGVpZ2h0ICogMC41XG4gICAgICAgIF1cblxuICAgICAgICBzdGF0ZS5yb3RhdGVfY2VudGVyLnRvX3JpZ2h0ICs9IHBhcnNlSW50KHNoaWZ0WzBdICogc3RhdGUuaW1hZ2VSYWRpdXMgLyBzdGF0ZS5jYW52YXNXaWR0aCAqIDIpXG4gICAgICAgIHN0YXRlLnJvdGF0ZV9jZW50ZXIudG9fYm90dG9tICs9IHBhcnNlSW50KHNoaWZ0WzFdICogc3RhdGUuaW1hZ2VSYWRpdXMgLyBzdGF0ZS5jYW52YXNXaWR0aCAqIDIpXG5cbiAgICAgICAgcGFja2FnZU1hcC5zZXRSb3RhdGVDZW50ZXIoXG4gICAgICAgICAgICBzdGF0ZS5yb3RhdGVfY2VudGVyLnRvX3JpZ2h0LFxuICAgICAgICAgICAgc3RhdGUucm90YXRlX2NlbnRlci50b19ib3R0b21cbiAgICAgICAgKVxuXG4gICAgICAgIGNlbnRlclRvUmlnaHQudmFsdWUgPSBzdGF0ZS5yb3RhdGVfY2VudGVyLnRvX3JpZ2h0XG4gICAgICAgIGNlbnRlclRvQm90dG9tLnZhbHVlID0gc3RhdGUucm90YXRlX2NlbnRlci50b19ib3R0b21cblxuICAgICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgICAgdXBkYXRlVmlldyhzdGF0ZSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNlZG93blwiLFxuICAgICAgICB0b3VjaFN0YXJ0SGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwiZHJhZ3N0YXJ0XCIsXG4gICAgICAgIGUgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJkcmFnXCIsXG4gICAgICAgIGUgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJkcmFnZW5kXCIsXG4gICAgICAgIGUgPT4geyBlLnByZXZlbnREZWZhdWx0KCkgfSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaHN0YXJ0XCIsXG4gICAgICAgIHRvdWNoU3RhcnRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJtb3VzZW1vdmVcIixcbiAgICAgICAgdG91Y2hNb3ZlSGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgdmlld2VyLmFkZEV2ZW50TGlzdGVuZXIoXG4gICAgICAgIFwidG91Y2htb3ZlXCIsXG4gICAgICAgIHRvdWNoTW92ZUhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIm1vdXNldXBcIixcbiAgICAgICAgdG91Y2hFbmRIYW5kbGVyKHN0YXRlKSxcbiAgICAgICAgZmFsc2VcbiAgICApXG5cbiAgICB2aWV3ZXIuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJ0b3VjaGVuZFwiLFxuICAgICAgICB0b3VjaEVuZEhhbmRsZXIoc3RhdGUpLFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHZpZXdlci5hZGRFdmVudExpc3RlbmVyKFxuICAgICAgICBcIndoZWVsXCIsXG4gICAgICAgIHdoZWVsSGFuZGxlcihzdGF0ZSksXG4gICAgICAgIGZhbHNlXG4gICAgKVxuXG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIiNjcmVhdGVfcGFja2FnZV9idXR0b25cIikuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICAgXCJjbGlja1wiLFxuICAgICAgICBlID0+IHtcbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgYXN5bmMgZnVuY3Rpb24gbWFrZVppcCgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsaXN0RW50cnkgPSBwYWNrYWdlTWFwLmdldFNhbXBsZUxpc3RFbnRyeSgpXG4gICAgICAgICAgICAgICAgc2VuZFNhbXBsZUxpc3RFbnRyeShsaXN0RW50cnkpXG5cbiAgICAgICAgICAgICAgICBjb25zdCB6aXAgPSBuZXcgSlNaaXAoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBqcGdaaXAgPSBuZXcgSlNaaXAoKVxuICAgICAgICAgICAgICAgIGNvbnN0IHdlYnBaaXAgPSBuZXcgSlNaaXAoKVxuXG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLm9wZW5faW1hZ2Vfc3Jjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gb3BlbiBOaWNvbCBpbWFnZXMgYXJlIHNlbGVjdGVkLlwiKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUuY3Jvc3NfaW1hZ2Vfc3Jjcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gY3Jvc3NlZCBOaWNvbCBpbWFnZXMgYXJlIHNlbGVjdGVkLlwiKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIFRodW1ibmFpbHNcbiAgICAgICAgICAgICAgICB6aXAuZmlsZShcIm8xLmpwZ1wiLCBjb21wcmVzc0ltYWdlU3JjKHN0YXRlLm9wZW5faW1hZ2Vfc3Jjc1swXSwgXCJqcGVnXCIsIHN0YXRlLmRlc2lyZWRUaHVtYm5haWxJbWFnZVNpemUpKVxuICAgICAgICAgICAgICAgIHppcC5maWxlKFwiYzEuanBnXCIsIGNvbXByZXNzSW1hZ2VTcmMoc3RhdGUuY3Jvc3NfaW1hZ2Vfc3Jjc1swXSwgXCJqcGVnXCIsIHN0YXRlLmRlc2lyZWRUaHVtYm5haWxJbWFnZVNpemUpKVxuXG4gICAgICAgICAgICAgICAgLy8gSW1hZ2Ugc2V0c1xuICAgICAgICAgICAgICAgIHBhY2thZ2VNYXAuc2V0SW1hZ2VGb3JtYXRzKFtcIndlYnBcIiwgXCJqcGdcIl0pXG4gICAgICAgICAgICAgICAgc3RhdGUub3Blbl9pbWFnZV9zcmNzLmZvckVhY2goKHNyYywgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB3ZWJwWmlwLmZpbGUoYG8ke2kgKyAxfS53ZWJwYCwgY29tcHJlc3NJbWFnZVNyYyhzcmMsIFwid2VicFwiLCBzdGF0ZS5kZXNpcmVkSW1hZ2VTaXplKSlcbiAgICAgICAgICAgICAgICAgICAganBnWmlwLmZpbGUoYG8ke2kgKyAxfS5qcGdgLCBjb21wcmVzc0ltYWdlU3JjKHNyYywgXCJqcGVnXCIsIHN0YXRlLmRlc2lyZWRJbWFnZVNpemUpKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgc3RhdGUuY3Jvc3NfaW1hZ2Vfc3Jjcy5mb3JFYWNoKChzcmMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgd2VicFppcC5maWxlKGBjJHtpICsgMX0ud2VicGAsIGNvbXByZXNzSW1hZ2VTcmMoc3JjLCBcIndlYnBcIiwgc3RhdGUuZGVzaXJlZEltYWdlU2l6ZSkpXG4gICAgICAgICAgICAgICAgICAgIGpwZ1ppcC5maWxlKGBjJHtpICsgMX0uanBnYCwgY29tcHJlc3NJbWFnZVNyYyhzcmMsIFwianBlZ1wiLCBzdGF0ZS5kZXNpcmVkSW1hZ2VTaXplKSlcbiAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgY29uc3QgbWV0YSA9IG5ldyBCbG9iKFtKU09OLnN0cmluZ2lmeShwYWNrYWdlTWFwLnRvSlNPTigpLCBudWxsLCAyKV0sIHsgXCJ0eXBlXCI6IFwidGV4dC9qc29uXCIgfSk7XG4gICAgICAgICAgICAgICAgemlwLmZpbGUoXCJtYW5pZmVzdC5qc29uXCIsIG1ldGEpXG4gICAgICAgICAgICAgICAgemlwLmZpbGUoXCJ3ZWJwLnppcFwiLCBhd2FpdCB3ZWJwWmlwLmdlbmVyYXRlQXN5bmMoeyB0eXBlOiBcImJsb2JcIiB9KSlcbiAgICAgICAgICAgICAgICB6aXAuZmlsZShcImpwZy56aXBcIiwgYXdhaXQganBnWmlwLmdlbmVyYXRlQXN5bmMoeyB0eXBlOiBcImJsb2JcIiB9KSlcbiAgICAgICAgICAgICAgICBjb25zdCB6aXBDb250ZW50ID0gYXdhaXQgemlwLmdlbmVyYXRlQXN5bmMoeyB0eXBlOiBcImJsb2JcIiB9KVxuXG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIjd29ya2luZ19hbmNob3JcIilcbiAgICAgICAgICAgICAgICBhLmRvd25sb2FkID0gYCR7cGFja2FnZU1hcC5nZXRQYWNrYWdlSUQoKX0uemlwYFxuICAgICAgICAgICAgICAgIGEuaHJlZiA9IHdpbmRvdy5VUkwuY3JlYXRlT2JqZWN0VVJMKHppcENvbnRlbnQpXG4gICAgICAgICAgICAgICAgYS5jbGljaygpXG5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1ha2VaaXAoKVxuICAgICAgICAgICAgICAgIC50aGVuKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGlkZUVycm9yTWVzc2FnZShcIiNlcnJvcl9tYWtlX3BhY2thZ2VcIilcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIC5jYXRjaChlID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd0Vycm9yTWVzc2FnZShcIiNlcnJvcl9tYWtlX3BhY2thZ2VcIiwgZSlcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICBmYWxzZVxuICAgIClcblxuICAgIHVwZGF0ZVZpZXdlckdlb21ldHJ5KHN0YXRlKVxufSkodXBsb2FkX3N0YXRlKVxuIl0sIm1hcHBpbmdzIjoiOzs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUMvTkE7QUFDQTs7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNkQTtBQUNBO0FBQ0E7OztBQ0ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQy9GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5R0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDNUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2xDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///0\n')}]);